(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _scene3d = require('./scene3d');

var _scene3d2 = _interopRequireDefault(_scene3d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scene3d = void 0;

var resize = function resize() {
  var width = window.innerWidth;
  var height = window.innerHeight;
  scene3d.resize(width, height);
};

window.onload = function () {
  scene3d = (0, _scene3d2.default)();
  document.body.appendChild(scene3d.domElement);
  resize();
  window.onresize = resize;
};

},{"./scene3d":3}],2:[function(require,module,exports){
'use strict';

var _three = require('three');

var _three2 = _interopRequireDefault(_three);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */
/*global THREE, console */

// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
// supported.
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe
//
// This is a drop-in replacement for (most) TrackballControls used in examples.
// That is, include this js file and wherever you see:
//    	controls = new THREE.TrackballControls( camera );
//      controls.target.z = 150;
// Simple substitute "OrbitControls" and the control should work as-is.

_three2.default.OrbitControls = function (object, domElement) {

	this.object = object;
	this.domElement = domElement !== undefined ? domElement : document;
	var domElement = this.domElement;

	// API

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the control orbits around
	// and where it pans with respect to.
	this.target = new _three2.default.Vector3();

	// center is old, deprecated; use "target" instead
	this.center = this.target;

	// This option actually enables dollying in and out; left as "zoom" for
	// backwards compatibility
	this.noZoom = false;
	this.zoomSpeed = 1.0;

	// Limits to how far you can dolly in and out
	this.minDistance = 0;
	this.maxDistance = 8000;

	// Set to true to disable this control
	this.noRotate = false;
	this.rotateSpeed = 1.0;

	// Set to true to disable this control
	this.noPan = false;
	this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI / 2.05; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = -Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to disable use of the keys
	this.noKeys = false;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { ORBIT: _three2.default.MOUSE.LEFT, ZOOM: _three2.default.MOUSE.MIDDLE, PAN: _three2.default.MOUSE.RIGHT };

	////////////
	// internals

	var scope = this;

	var EPS = 0.000001;

	var rotateStart = new _three2.default.Vector2();
	var rotateEnd = new _three2.default.Vector2();
	var rotateDelta = new _three2.default.Vector2();

	var panStart = new _three2.default.Vector2();
	var panEnd = new _three2.default.Vector2();
	var panDelta = new _three2.default.Vector2();
	var panOffset = new _three2.default.Vector3();

	var offset = new _three2.default.Vector3();

	var dollyStart = new _three2.default.Vector2();
	var dollyEnd = new _three2.default.Vector2();
	var dollyDelta = new _three2.default.Vector2();

	var theta;
	var phi;
	var phiDelta = 0;
	var thetaDelta = 0;
	var scale = 1;
	var pan = new _three2.default.Vector3();

	var lastPosition = new _three2.default.Vector3();
	var lastQuaternion = new _three2.default.Quaternion();

	var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	var state = STATE.NONE;

	// for reset

	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();

	// so camera.up is the orbit axis

	var quat = new _three2.default.Quaternion().setFromUnitVectors(object.up, new _three2.default.Vector3(0, 1, 0));
	var quatInverse = quat.clone().inverse();

	// events

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	this.rotateLeft = function (angle) {

		if (angle === undefined) {

			angle = getAutoRotationAngle();
		}

		thetaDelta -= angle;
	};

	this.rotateUp = function (angle) {

		if (angle === undefined) {

			angle = getAutoRotationAngle();
		}

		phiDelta -= angle;
	};

	// pass in distance in world space to move left
	this.panLeft = function (distance) {

		var te = this.object.matrix.elements;

		// get X column of matrix
		panOffset.set(te[0], te[1], te[2]);
		panOffset.multiplyScalar(-distance);

		pan.add(panOffset);
	};

	// pass in distance in world space to move up
	this.panUp = function (distance) {

		var te = this.object.matrix.elements;

		// get Y column of matrix
		panOffset.set(te[4], te[5], te[6]);
		panOffset.multiplyScalar(distance);

		pan.add(panOffset);
	};

	// pass in x,y of change desired in pixel space,
	// right and down are positive
	this.pan = function (deltaX, deltaY) {

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		if (scope.object.fov !== undefined) {

			// perspective
			var position = scope.object.position;
			var offset = position.clone().sub(scope.target);
			var targetDistance = offset.length();

			// half of the fov is center to top of screen
			targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

			// we actually don't use screenWidth, since perspective camera is fixed to screen height
			scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);
			scope.panUp(2 * deltaY * targetDistance / element.clientHeight);
		} else if (scope.object.top !== undefined) {

			// orthographic
			scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);
			scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);
		} else {

			// camera neither orthographic or perspective
			// console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

		}
	};

	this.dollyIn = function (dollyScale) {

		if (dollyScale === undefined) {

			dollyScale = getZoomScale();
		}

		scale /= dollyScale;
	};

	this.dollyOut = function (dollyScale) {

		if (dollyScale === undefined) {

			dollyScale = getZoomScale();
		}

		scale *= dollyScale;
	};

	this.update = function () {

		var position = this.object.position;

		offset.copy(position).sub(this.target);

		// rotate offset to "y-axis-is-up" space
		offset.applyQuaternion(quat);

		// angle from z-axis around y-axis

		theta = Math.atan2(offset.x, offset.z);

		// angle from y-axis

		phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

		if (this.autoRotate && state === STATE.NONE) {

			this.rotateLeft(getAutoRotationAngle());
		}

		theta += thetaDelta;
		phi += phiDelta;

		// restrict theta to be between desired limits
		theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));

		// restrict phi to be between desired limits
		phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

		// restrict phi to be betwee EPS and PI-EPS
		phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

		var radius = offset.length() * scale;

		// restrict radius to be between desired limits
		radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));

		// move target to panned location
		this.target.add(pan);

		offset.x = radius * Math.sin(phi) * Math.sin(theta);
		offset.y = radius * Math.cos(phi);
		offset.z = radius * Math.sin(phi) * Math.cos(theta);

		// rotate offset back to "camera-up-vector-is-up" space
		offset.applyQuaternion(quatInverse);

		position.copy(this.target).add(offset);

		this.object.lookAt(this.target);

		thetaDelta = 0;
		phiDelta = 0;
		scale = 1;
		pan.set(0, 0, 0);

		// update condition is:
		// min(camera displacement, camera rotation in radians)^2 > EPS
		// using small-angle approximation cos(x/2) = 1 - x^2 / 8

		if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {

			this.dispatchEvent(changeEvent);

			lastPosition.copy(this.object.position);
			lastQuaternion.copy(this.object.quaternion);
		}
	};

	this.reset = function () {

		state = STATE.NONE;

		this.target.copy(this.target0);
		this.object.position.copy(this.position0);

		this.update();
	};

	this.getPolarAngle = function () {

		return phi;
	};

	this.getAzimuthalAngle = function () {

		return theta;
	};

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	}

	function getZoomScale() {

		return Math.pow(0.95, scope.zoomSpeed);
	}

	function onMouseDown(event) {

		if (scope.enabled === false) return;
		event.preventDefault();

		if (event.button === scope.mouseButtons.ORBIT) {
			if (scope.noRotate === true) return;

			state = STATE.ROTATE;

			rotateStart.set(event.clientX, event.clientY);
		} else if (event.button === scope.mouseButtons.ZOOM) {
			if (scope.noZoom === true) return;

			state = STATE.DOLLY;

			dollyStart.set(event.clientX, event.clientY);
		} else if (event.button === scope.mouseButtons.PAN) {
			if (scope.noPan === true) return;

			state = STATE.PAN;

			panStart.set(event.clientX, event.clientY);
		}

		if (state !== STATE.NONE) {
			domElement.addEventListener('mousemove', onMouseMove, false);
			domElement.addEventListener('mouseup', onMouseUp, false);
			scope.dispatchEvent(startEvent);
		}
	}

	function onMouseMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		if (state === STATE.ROTATE) {

			if (scope.noRotate === true) return;

			rotateEnd.set(event.clientX, event.clientY);
			rotateDelta.subVectors(rotateEnd, rotateStart);

			// rotating across whole screen goes 360 degrees around
			scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

			rotateStart.copy(rotateEnd);
		} else if (state === STATE.DOLLY) {

			if (scope.noZoom === true) return;

			dollyEnd.set(event.clientX, event.clientY);
			dollyDelta.subVectors(dollyEnd, dollyStart);

			if (dollyDelta.y > 0) {

				scope.dollyIn();
			} else {

				scope.dollyOut();
			}

			dollyStart.copy(dollyEnd);
		} else if (state === STATE.PAN) {

			if (scope.noPan === true) return;

			panEnd.set(event.clientX, event.clientY);
			panDelta.subVectors(panEnd, panStart);

			scope.pan(panDelta.x, panDelta.y);

			panStart.copy(panEnd);
		}

		if (state !== STATE.NONE) scope.update();
	}

	function onMouseUp() /* event */{

		if (scope.enabled === false) return;

		domElement.removeEventListener('mousemove', onMouseMove, false);
		domElement.removeEventListener('mouseup', onMouseUp, false);
		scope.dispatchEvent(endEvent);
		state = STATE.NONE;
	}

	function onMouseWheel(event) {

		if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) return;

		event.preventDefault();
		event.stopPropagation();

		var delta = 0;

		if (event.wheelDelta !== undefined) {
			// WebKit / Opera / Explorer 9

			delta = event.wheelDelta;
		} else if (event.detail !== undefined) {
			// Firefox

			delta = -event.detail;
		}

		if (delta > 0) {

			scope.dollyOut();
		} else {

			scope.dollyIn();
		}

		scope.update();
		scope.dispatchEvent(startEvent);
		scope.dispatchEvent(endEvent);
	}

	function onKeyDown(event) {

		if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) return;

		switch (event.keyCode) {

			case scope.keys.UP:
				scope.dollyOut();
				scope.update();
				break;

			case scope.keys.BOTTOM:
				scope.dollyIn();
				scope.update();
				break;

			case scope.keys.LEFT:
				thetaDelta += 0.1;
				scope.update();
				break;

			case scope.keys.RIGHT:
				thetaDelta -= 0.1;
				scope.update();
				break;

		}
	}

	function touchstart(event) {

		if (scope.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.noRotate === true) return;

				state = STATE.TOUCH_ROTATE;

				rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.noZoom === true) return;

				state = STATE.TOUCH_DOLLY;

				var dx = event.touches[0].pageX - event.touches[1].pageX;
				var dy = event.touches[0].pageY - event.touches[1].pageY;
				var distance = Math.sqrt(dx * dx + dy * dy);
				dollyStart.set(0, distance);
				break;

			case 3:
				// three-fingered touch: pan

				if (scope.noPan === true) return;

				state = STATE.TOUCH_PAN;

				panStart.set(event.touches[0].pageX, event.touches[0].pageY);
				break;

			default:

				state = STATE.NONE;

		}

		if (state !== STATE.NONE) scope.dispatchEvent(startEvent);
	}

	function touchmove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.noRotate === true) return;
				if (state !== STATE.TOUCH_ROTATE) return;

				rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
				rotateDelta.subVectors(rotateEnd, rotateStart);

				// rotating across whole screen goes 360 degrees around
				scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
				// rotating up and down along whole screen attempts to go 360, but limited to 180
				scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

				rotateStart.copy(rotateEnd);

				scope.update();
				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.noZoom === true) return;
				if (state !== STATE.TOUCH_DOLLY) return;

				var dx = event.touches[0].pageX - event.touches[1].pageX;
				var dy = event.touches[0].pageY - event.touches[1].pageY;
				var distance = Math.sqrt(dx * dx + dy * dy);

				dollyEnd.set(0, distance);
				dollyDelta.subVectors(dollyEnd, dollyStart);

				if (dollyDelta.y > 0) {

					scope.dollyOut();
				} else {

					scope.dollyIn();
				}

				dollyStart.copy(dollyEnd);

				scope.update();
				break;

			case 3:
				// three-fingered touch: pan

				if (scope.noPan === true) return;
				if (state !== STATE.TOUCH_PAN) return;

				panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
				panDelta.subVectors(panEnd, panStart);

				scope.pan(panDelta.x, panDelta.y);

				panStart.copy(panEnd);

				scope.update();
				break;

			default:

				state = STATE.NONE;

		}
	}

	function touchend() /* event */{

		if (scope.enabled === false) return;

		scope.dispatchEvent(endEvent);
		state = STATE.NONE;
	}

	this.domElement.addEventListener('contextmenu', function (event) {
		event.preventDefault();
	}, false);
	this.domElement.addEventListener('mousedown', onMouseDown, false);
	this.domElement.addEventListener('mousewheel', onMouseWheel, false);
	this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox

	this.domElement.addEventListener('touchstart', touchstart, false);
	this.domElement.addEventListener('touchend', touchend, false);
	this.domElement.addEventListener('touchmove', touchmove, false);

	window.addEventListener('keydown', onKeyDown, false);

	// force an update at start
	this.update();
}; /* eslint-disable */


_three2.default.OrbitControls.prototype = Object.create(_three2.default.EventDispatcher.prototype);
_three2.default.OrbitControls.prototype.constructor = _three2.default.OrbitControls;

},{"three":4}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = init;

var _three = require('three');

var _three2 = _interopRequireDefault(_three);

require('./lib/OrbitControls');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function init() {
  var scene = new _three2.default.Scene();
  var initialRatio = 300 / 1500;

  var renderer = new _three2.default.WebGLRenderer({ autoClear: true, antialias: true, alpha: true });
  // renderer.setClearColor(0xaa0033, 1);
  // renderer.setClearColor(0xaa0033, 1);
  renderer.setClearColor(0xffffff, 1);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.soft = true;
  renderer.shadowMap.type = _three2.default.PCFSoftShadowMap;
  // renderer.sortObjects = true; -> possibly necessary for transparent textures

  var camera = new _three2.default.PerspectiveCamera(50, 1, 1, 10000);
  camera.position.z = 1500;
  camera.position.x = 0;
  camera.position.y = 300;
  camera.lookAt(new _three2.default.Vector3(0, 0, 0));

  var spot = new _three2.default.SpotLight(0xffffff, 1);
  spot.position.set(300, 300, 300);
  spot.target.position.set(0, 0, 0);
  spot.shadowCameraNear = 1;
  spot.shadowCameraFar = 1024;
  spot.castShadow = true;
  spot.shadowDarkness = 0.3;
  spot.shadowBias = 0.0001;
  spot.shadowMapWidth = 2048;
  spot.shadowMapHeight = 2048;
  scene.add(spot);

  var world = new _three2.default.Mesh(new _three2.default.PlaneGeometry(1000, 1000, 10, 10), new _three2.default.MeshBasicMaterial({ color: 0x000000, wireframe: true }));
  // const world = new THREE.Object3D();
  world.rotation.x -= Math.PI / 2;
  // world.rotation.x += Math.PI / 2;
  // world.rotation.x += Math.PI;

  world.material.side = _three2.default.DoubleSide;
  world.position.y = 50;
  world.position.z = 50;
  world.receiveShadow = true;
  scene.add(world);

  var light = new _three2.default.HemisphereLight(0xffffff, 0x000000, 0.6);
  scene.add(light);

  var controls = new _three2.default.OrbitControls(camera, renderer.domElement);
  // controls.keys = {};
  controls.addEventListener('change', function () {
    // console.log(camera.position, camera.fov);
    render();
  });

  function resize(width, height) {
    // console.log(width,height);
    // const distance;
    // const height = 2 * Math.tan( ( vFOV / 2 ) ) * distance;
    // const vFOV = 2 * Math.atan(height / (2 * distance));
    // const d = 4;
    // const f = 3
    // const h = 2 * f * d; // 24
    // console.log(24 / 3 / 2);

    // const h = height;
    // const vFOV = camera.fov;
    // const a = Math.tan(vFOV / 2);
    // const distance = h / a / 2;
    // console.log(h, vFOV, distance);
    // const focalLength = 25.734; // equivalent to FOV=50
    // const distance = 1000 / Math.tan(camera.fov / focalLength);

    // console.log(distance);

    /*
    tan = opp / adj
    tan = y / z
    z = y / tan
    y = z * tan
      */

    var aspect = width / height;
    // const vFOV = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(camera.fov) * 0.5) / camera.zoom));
    // console.log(vFOV, camera.fov);
    var vFOV = _three2.default.Math.degToRad(camera.fov);
    var hFOV = 2 * Math.atan(Math.tan(vFOV / 2) * aspect);

    // const vWidth = width;
    // const vHeight = width / aspect;
    var dist1 = height / 2 / Math.tan(vFOV / 2);
    var dist2 = height / 2 / Math.tan(hFOV / 2);
    var dist = width > height ? dist2 : dist1;

    // fov = 2 * Math.atan( ( width / aspect ) / ( 2 * dist ) ) * ( 180 / Math.PI );

    // camera.fov / 2 = (Math.atan(height / (2 * dist))); // * ( 180 / Math.PI );

    // THREE.Math.radToDeg((Math.atan(height / (2 * dist)))) = 25

    // const vHeight = height;
    // const vHeight = width / aspect;
    // const dist = vHeight / 2 / (Math.tan(vFOV / 2));


    // const dist = Math.abs(width * Math.sin(THREE.Math.degToRad(camera.fov / 2)));

    // console.log(vHeight, vWidth, dist);
    console.log(dist, camera.position);
    camera.position.z = dist + 500;
    camera.position.y = camera.position.z * initialRatio;

    // camera.position.z = distance;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
    render();
  }

  function render() {
    var vFOV = camera.fov * (Math.PI / 180); // convert vertical fov to radians
    var vHeight = 2 * Math.tan(vFOV / 2) * (camera.position.z - 500); // visible height
    var vWidth = vHeight * camera.aspect; // visible width

    // console.log('W', vWidth, window.innerWidth);
    // console.log('H', vHeight, window.innerHeight);

    var opposite = camera.position.y;
    var adjacent = camera.position.z;
    var ratio = opposite / adjacent;
    // console.log(opposite, adjacent);
    // console.log(ratio, Math.tan(THREE.Math.degToRad(50)));
    // console.log(ratio, initialRatio);

    // console.log('--');

    renderer.render(scene, camera);
  }

  return {
    render: render,
    resize: resize,
    domElement: renderer.domElement
  };
}

},{"./lib/OrbitControls":2,"three":4}],4:[function(require,module,exports){
var self = self || {};// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '73' };

//

if ( typeof define === 'function' && define.amd ) {

		define( 'three', THREE );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

		module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

	// Missing in Android stock browser.

	( function () {

		var lastTime = 0;
		var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

		for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

			self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
			self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

		}

		if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

			self.requestAnimationFrame = function ( callback ) {

				var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
				var id = self.setTimeout( function () {

					callback( currTime + timeToCall );

				}, timeToCall );
				lastTime = currTime + timeToCall;
				return id;

			};

		}

		if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

			self.cancelAnimationFrame = function ( id ) {

				self.clearTimeout( id );

			};

		}

	} )();

}

//

if ( self.performance === undefined ) {

	self.performance = {};

}

if ( self.performance.now === undefined ) {

	( function () {

		var start = Date.now();

		self.performance.now = function () {

			return Date.now() - start;

		}

	} )();

}

//

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, -52 );

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

	// Missing in IE9-11.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

		}

	} );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

// Loop styles for AnimationAction

THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPong = 2202;

// DEPRECATED

THREE.Projector = function () {

	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

};

THREE.CanvasRenderer = function () {

	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElement( 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.fromArray( arguments );

	}

	return this.set( color );

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;

		}

		return function ( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = THREE.Math.euclideanModulo( h, 1 );
			s = THREE.Math.clamp( s, 0, 1 );
			l = THREE.Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = THREE.ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		var order = euler.order;

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		}

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	get width() { return this.x },
	set width( value ) { this.x = value },

	get height() { return this.y },
	set height( value ) { this.y = value },

	//

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
		}

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	lengthManhattan: function() {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
			this.z = 0;
		}

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function applyEuler( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function applyAxisAngle( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function project( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function unproject( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function projectOnVector( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function projectOnPlane( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function reflect( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

		return this.setFromMatrixScale( m );

	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];

		return this;

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		}

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		   && ( Math.abs( m13 - m31 ) < epsilon )
		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			   && ( Math.abs( m13 + m31 ) < epsilon2 )
			   && ( Math.abs( m23 + m32 ) < epsilon2 )
			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						  + ( m13 - m31 ) * ( m13 - m31 )
						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];
		this.w = attribute.array[ index + 3 ];

		return this;

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order);

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function ( q, order, update ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();
			matrix.makeRotationFromQuaternion( q );
			this.setFromRotationMatrix( matrix, order, update );

			return this;

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new THREE.Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),
	
	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var v1 = new THREE.Vector3();

		return function ( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry instanceof THREE.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1;

		return function ( array, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix3( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix3( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new THREE.Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		var te = this.elements;

		xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
		yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
		zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

		return this;

	},

	extractRotation: function () {

		var v1;

		return function ( m ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x, y, z;

		return function ( eye, target, up ) {

			if ( x === undefined ) x = new THREE.Vector3();
			if ( y === undefined ) y = new THREE.Vector3();
			if ( z === undefined ) z = new THREE.Vector3();

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.lengthSq() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.lengthSq() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1;

		return function ( array, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix4( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix4( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	},

	getPosition: function () {

		var v1;

		return function () {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det === 0 ) {

			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},

	rotateX: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},

	rotateY: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},

	rotateZ: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},

	rotateByAxis: function ( axis, angle ) {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector, matrix;

		return function ( position, quaternion, scale ) {

			if ( vector === undefined ) vector = new THREE.Vector3();
			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {

				sx = - sx;

			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new THREE.Vector3();
		var segDir = new THREE.Vector3();
		var diff = new THREE.Vector3();

		return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),


	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	intersectSphere: function () {

		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

		var v1 = new THREE.Vector3();

		return function ( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );

			var tca = v1.dot( this.direction );

			var d2 = v1.dot( v1 ) - tca * tca;

			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, optionalTarget );

		}

	}(),

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	}(),

	intersectBox: function ( box, optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function () {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

					uuid[ i ] = '-';

				} else if ( i === 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}

			}

			return uuid.join( '' );

		};

	}(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function () {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function () {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nearestPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint !== oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function () {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

};

// File:src/core/Channels.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Channels = function () {

	this.mask = 1;

};

THREE.Channels.prototype = {

	constructor: THREE.Channels,

	set: function ( channel ) {

		this.mask = 1 << channel;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel );

	}

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance.now();

		this.oldTime = this.startTime;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {
					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;
				}
			}
		} );

	};

	function descSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	//

	THREE.Raycaster.prototype = {

		constructor: THREE.Raycaster,

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( camera instanceof THREE.PerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( camera instanceof THREE.OrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( descSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( descSort );

			return intersects;

		}

	};

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.channels = new THREE.Channels();
	this.children = [];

	this.up = THREE.Object3D.DefaultUp.clone();

	var position = new THREE.Vector3();
	var rotation = new THREE.Euler();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new THREE.Matrix4()
		},
		normalMatrix: {
			value: new THREE.Matrix3()
		}
	} );

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get eulerOrder () {

		console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set renderDepth ( value ) {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},

	//

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		};

	}(),

	getWorldRotation: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		};

	}(),

	getWorldScale: function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		};

	}(),

	getWorldDirection: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		};

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function ( meta ) {

		var isRootObject = ( meta === undefined );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};

			output.metadata = {
				version: 4.4,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;

		object.matrix = this.matrix.toArray();

		//

		if ( this.geometry !== undefined ) {

			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

			}

			object.geometry = this.geometry.uuid;

		}

		if ( this.material !== undefined ) {

			if ( meta.materials[ this.material.uuid ] === undefined ) {

				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

			}

			object.material = this.material.uuid;

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache ( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.rotationAutoUpdate = source.rotationAutoUpdate;

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

	this.uuid = THREE.Math.generateUUID();

	this.array = array;
	this.itemSize = itemSize;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

};

THREE.BufferAttribute.prototype = {

	constructor: THREE.BufferAttribute,

	get length() {

		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
		return this.array.length;

	},

	get count() {

		return this.array.length / this.itemSize;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new THREE.Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyIndicesArray: function ( indices ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = indices.length; i < l; i ++ ) {

			var index = indices[ i ];

			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new THREE.Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new THREE.Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new THREE.Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
	return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

	THREE.BufferAttribute.call( this, array, itemSize );

	this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

	THREE.BufferAttribute.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride ) {

	this.uuid = THREE.Math.generateUUID();

	this.array = array;
	this.stride = stride;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

	constructor: THREE.InterleavedBuffer,

	get length () {

		return this.array.length;

	},

	get count () {

		return this.array.length / this.stride;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.stride = source.stride;
		this.dynamic = source.dynamic;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

	THREE.InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

	THREE.InterleavedBuffer.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

	this.uuid = THREE.Math.generateUUID();

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

	constructor: THREE.InterleavedBufferAttribute,

	get length() {

		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
		return this.array.length;

	},

	get count() {

		return this.data.array.length / this.data.stride;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

THREE.Geometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new THREE.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var vertices = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];

		for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

			if ( uvs2 !== undefined ) {

				tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

			}

		}

		function addFace( a, b, c ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

			}

		};

		if ( indices !== undefined ) {

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

					}

				}

			} else {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			}

		} else {

			for ( var i = 0; i < vertices.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new THREE.Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof THREE.Geometry === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( mesh instanceof THREE.Mesh === false ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = false; // face.materialIndex !== undefined;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 );
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.vertices = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];

		var vertices = source.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		var faces = source.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'DirectGeometry';

	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

	constructor: THREE.DirectGeometry,

	computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
	computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

	computeFaceNormals: function () {

		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

	},

	computeVertexNormals: function () {

		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

	},

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		if ( morphTargetsLength > 0 ) {

			var morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = [];

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		if ( morphNormalsLength > 0 ) {

			var morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = [];

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		this.index = index;

	},

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			return;

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return;

		}

		this.attributes[ name ] = attribute;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

	},

	get drawcalls() {

		console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
		return this.groups;

	},

	get offsets() {

		console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
		return this.groups;

	},

	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}

		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},

	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new THREE.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

			var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
			var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object instanceof THREE.Mesh ) {

			if ( geometry instanceof THREE.Geometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object instanceof THREE.Mesh ) {

			var direct = geometry.__directGeometry;

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		if ( geometry.verticesNeedUpdate === true ) {

			var attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			var attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			var attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

				var attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			var attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		if ( geometry.indices.length > 0 ) {

			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

				array.push( attribute.copyVector3sArray( morphTarget ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				var bb = this.boundingBox;
				bb.makeEmpty();

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					bb.expandByPoint( vector );

				}

			}

			if ( positions === undefined || positions.length === 0 ) {

				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		};

	}(),

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					box.expandByPoint( vector );

				}

				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var normals = attributes.normal.array;

				for ( var i = 0, il = normals.length; i < il; i ++ ) {

					normals[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				if ( groups.length === 0 ) {

					this.addGroup( 0, indices.length );

				}

				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

					var group = groups[ j ];

					var start = group.start;
					var count = group.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},

	computeOffsets: function ( size ) {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

	},

	merge: function ( geometry, offset ) {

		if ( geometry instanceof THREE.BufferGeometry === false ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count );

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

	THREE.BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

	this.groups.push( {

		start: start,
		count: count,
		instances: instances

	} );

};

THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

	var index = source.index;

	if ( index !== null ) {

		this.setIndex( index.clone() );

	}

	var attributes = source.attributes;

	for ( var name in attributes ) {

		var attribute = attributes[ name ];
		this.addAttribute( name, attribute.clone() );

	}

	var groups = source.groups;

	for ( var i = 0, l = groups.length; i < l; i ++ ) {

		var group = groups[ i ];
		this.addGroup( group.start, group.count, group.instances );

	}

	return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/animation/AnimationAction.js

/**
 *
 * A clip that has been explicitly scheduled.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationAction = function ( clip, startTime, timeScale, weight, loop ) {

	if ( clip === undefined ) throw new Error( 'clip is null' );
	this.clip = clip;
	this.localRoot = null;
	this.startTime = startTime || 0;
	this.timeScale = timeScale || 1;
	this.weight = weight || 1;
	this.loop = loop || THREE.LoopRepeat;
	this.loopCount = 0;
	this.enabled = true;	// allow for easy disabling of the action.

	this.actionTime = - this.startTime;
	this.clipTime = 0;

	this.propertyBindings = [];
};

/*
THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPing = 2202;
*/

THREE.AnimationAction.prototype = {

	constructor: THREE.AnimationAction,

	setLocalRoot: function( localRoot ) {

		this.localRoot = localRoot;

		return this;

	},

	updateTime: function( clipDeltaTime ) {

		var previousClipTime = this.clipTime;
   		var previousLoopCount = this.loopCount;
   		var previousActionTime = this.actionTime;

		var duration = this.clip.duration;

		this.actionTime = this.actionTime + clipDeltaTime;

		if ( this.loop === THREE.LoopOnce ) {

			this.loopCount = 0;
			this.clipTime = Math.min( Math.max( this.actionTime, 0 ), duration );

			// if time is changed since last time, see if we have hit a start/end limit
			if ( this.clipTime !== previousClipTime ) {

				if ( this.clipTime === duration ) {

					this.mixer.dispatchEvent( { type: 'finished', action: this, direction: 1 } );

				} else if ( this.clipTime === 0 ) {

					this.mixer.dispatchEvent( { type: 'finished', action: this, direction: -1 } );

				}

			}


			return this.clipTime;

		}

		this.loopCount = Math.floor( this.actionTime / duration );

		var newClipTime = this.actionTime - this.loopCount * duration;
		newClipTime = newClipTime % duration;

		// if we are ping pong looping, ensure that we go backwards when appropriate
		if ( this.loop == THREE.LoopPingPong ) {

			if ( Math.abs( this.loopCount % 2 ) === 1 ) {

				newClipTime = duration - newClipTime;

			}

		}

		this.clipTime = newClipTime;

		if ( this.loopCount !== previousLoopCount ) {

   			this.mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: ( this.loopCount - this.loopCount ) } );

   		}

	   	return this.clipTime;

	},

	syncWith: function( action ) {

		this.actionTime = action.actionTime;
		this.timeScale = action.timeScale;

		return this;
	},

	warpToDuration: function( duration ) {

		this.timeScale = this.clip.duration / duration;

		return this;
	},

	init: function( time ) {

		this.clipTime = time - this.startTime;

		return this;

	},

	update: function( clipDeltaTime ) {

		this.updateTime( clipDeltaTime );

		var clipResults = this.clip.getAt( this.clipTime );

		return clipResults;

	},

	getTimeScaleAt: function( time ) {

		if ( this.timeScale.getAt ) {
			// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
			return this.timeScale.getAt( time );

		}

		return this.timeScale;

	},

	getWeightAt: function( time ) {

		if ( this.weight.getAt ) {
			// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
			return this.weight.getAt( time );

		}

		return this.weight;

	}

};

// File:src/animation/AnimationClip.js

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationClip = function ( name, duration, tracks ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : -1;

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {
		for ( var i = 0; i < this.tracks.length; i ++ ) {
			var track = this.tracks[i];
			this.duration = Math.max( track.keys[ track.keys.length - 1 ].time );
		}
	}

	// maybe only do these on demand, as doing them here could potentially slow down loading
	// but leaving these here during development as this ensures a lot of testing of these functions
	this.trim();
	this.optimize();

	this.results = [];

};

THREE.AnimationClip.prototype = {

	constructor: THREE.AnimationClip,

	getAt: function( clipTime ) {

		clipTime = Math.max( 0, Math.min( clipTime, this.duration ) );

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			var track = this.tracks[ i ];

			this.results[ i ] = track.getAt( clipTime );

		}

		return this.results;
	},

	trim: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	optimize: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

};


THREE.AnimationClip.CreateFromMorphTargetSequence = function( name, morphTargetSequence, fps ) {


	var numMorphTargets = morphTargetSequence.length;
	var tracks = [];

	for ( var i = 0; i < numMorphTargets; i ++ ) {

		var keys = [];

		keys.push( { time: ( i + numMorphTargets - 1 ) % numMorphTargets, value: 0 } );
		keys.push( { time: i, value: 1 } );
		keys.push( { time: ( i + 1 ) % numMorphTargets, value: 0 } );

		keys.sort( THREE.KeyframeTrack.keyComparer );

		// if there is a key at the first frame, duplicate it as the last frame as well for perfect loop.
		if ( keys[0].time === 0 ) {
			keys.push( {
				time: numMorphTargets,
				value: keys[0].value
			});
		}

		tracks.push( new THREE.NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys ).scale( 1.0 / fps ) );
	}

	return new THREE.AnimationClip( name, -1, tracks );

};

THREE.AnimationClip.findByName = function( clipArray, name ) {

	for ( var i = 0; i < clipArray.length; i ++ ) {

		if ( clipArray[i].name === name ) {

			return clipArray[i];

		}
	}

	return null;

};

THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function( morphTargets, fps ) {

	var animationToMorphTargets = {};

	// tested with https://regex101.com/ on trick sequences such flamingo_flyA_003, flamingo_run1_003, crdeath0059
	var pattern = /^([\w-]*?)([\d]+)$/;

	// sort morph target names into animation groups based patterns like Walk_001, Walk_002, Run_001, Run_002
	for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

		var morphTarget = morphTargets[ i ];
		var parts = morphTarget.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var name = parts[ 1 ];

			var animationMorphTargets = animationToMorphTargets[ name ];
			if ( ! animationMorphTargets ) {
				animationToMorphTargets[ name ] = animationMorphTargets = [];
			}

			animationMorphTargets.push( morphTarget );

		}

	}

	var clips = [];

	for ( var name in animationToMorphTargets ) {

		clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
	}

	return clips;

};

// parse the standard JSON format for clips
THREE.AnimationClip.parse = function( json ) {

	var tracks = [];

	for ( var i = 0; i < json.tracks.length; i ++ ) {

		tracks.push( THREE.KeyframeTrack.parse( json.tracks[i] ).scale( 1.0 / json.fps ) );

	}

	return new THREE.AnimationClip( json.name, json.duration, tracks );

};


// parse the animation.hierarchy format
THREE.AnimationClip.parseAnimation = function( animation, bones, nodeName ) {

	if ( ! animation ) {
		console.error( "  no animation in JSONLoader data" );
		return null;
	}

	var convertTrack = function( trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc ) {

		var keys = [];

		for ( var k = 0; k < animationKeys.length; k ++ ) {

			var animationKey = animationKeys[k];

			if ( animationKey[propertyName] !== undefined ) {

				keys.push( { time: animationKey.time, value: animationKeyToValueFunc( animationKey ) } );
			}

		}

		// only return track if there are actually keys.
		if ( keys.length > 0 ) {

			return new trackType( trackName, keys );

		}

		return null;

	};

	var tracks = [];

	var clipName = animation.name || 'default';
	var duration = animation.length || -1; // automatic length determination in AnimationClip.
	var fps = animation.fps || 30;

	var hierarchyTracks = animation.hierarchy || [];

	for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

		var animationKeys = hierarchyTracks[ h ].keys;

		// skip empty tracks
		if ( ! animationKeys || animationKeys.length == 0 ) {
			continue;
		}

		// process morph targets in a way exactly compatible with AnimationHandler.init( animation )
		if ( animationKeys[0].morphTargets ) {

			// figure out all morph targets used in this track
			var morphTargetNames = {};
			for ( var k = 0; k < animationKeys.length; k ++ ) {

				if ( animationKeys[k].morphTargets ) {
					for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

						morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
					}
				}

			}

			// create a track for each morph target with all zero morphTargetInfluences except for the keys in which the morphTarget is named.
			for ( var morphTargetName in morphTargetNames ) {

				var keys = [];

				for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

					var animationKey = animationKeys[k];

					keys.push( {
							time: animationKey.time,
							value: (( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
						});

				}

				tracks.push( new THREE.NumberKeyframeTrack( nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys ) );

			}

			duration = morphTargetNames.length * ( fps || 1.0 );

		} else {

			var boneName = nodeName + '.bones[' + bones[ h ].name + ']';

			// track contains positions...
			var positionTrack = convertTrack( boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function( animationKey ) {
					return new THREE.Vector3().fromArray( animationKey.pos )
				} );

			if ( positionTrack ) tracks.push( positionTrack );

			// track contains quaternions...
			var quaternionTrack = convertTrack( boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function( animationKey ) {
					if ( animationKey.rot.slerp ) {
						return animationKey.rot.clone();
					} else {
						return new THREE.Quaternion().fromArray( animationKey.rot );
					}
				} );

			if ( quaternionTrack ) tracks.push( quaternionTrack );

			// track contains quaternions...
			var scaleTrack = convertTrack( boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function( animationKey ) {
					return new THREE.Vector3().fromArray( animationKey.scl )
				} );

			if ( scaleTrack ) tracks.push( scaleTrack );

		}
	}

	if ( tracks.length === 0 ) {

		return null;

	}

	var clip = new THREE.AnimationClip( clipName, duration, tracks );

	return clip;

};

// File:src/animation/AnimationMixer.js

/**
 *
 * Mixes together the AnimationClips scheduled by AnimationActions and applies them to the root and subtree
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationMixer = function( root ) {

	this.root = root;
	this.time = 0;
	this.timeScale = 1.0;
	this.actions = [];
	this.propertyBindingMap = {};

};

THREE.AnimationMixer.prototype = {

	constructor: THREE.AnimationMixer,

	addAction: function( action ) {

		// TODO: check for duplicate action names?  Or provide each action with a UUID?

		this.actions.push( action );
		action.init( this.time );
		action.mixer = this;

		var tracks = action.clip.tracks;

		var root = action.localRoot || this.root;

		for ( var i = 0; i < tracks.length; i ++ ) {

			var track = tracks[ i ];

			var propertyBindingKey = root.uuid + '-' + track.name;
			var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

			if ( propertyBinding === undefined ) {

				propertyBinding = new THREE.PropertyBinding( root, track.name );
				this.propertyBindingMap[ propertyBindingKey ] = propertyBinding;

			}

			// push in the same order as the tracks.
			action.propertyBindings.push( propertyBinding );

			// track usages of shared property bindings, because if we leave too many around, the mixer can get slow
			propertyBinding.referenceCount += 1;

		}

	},

	removeAllActions: function() {

		for ( var i = 0; i < this.actions.length; i ++ ) {

			this.actions[i].mixer = null;

		}

		// unbind all property bindings
		for ( var properyBindingKey in this.propertyBindingMap ) {

			this.propertyBindingMap[ properyBindingKey ].unbind();

		}

		this.actions = [];
		this.propertyBindingMap = {};

		return this;

	},

	removeAction: function( action ) {

		var index = this.actions.indexOf( action );

		if ( index !== - 1 ) {

			this.actions.splice( index, 1 );
			action.mixer = null;

		}


		// remove unused property bindings because if we leave them around the mixer can get slow
		var root = action.localRoot || this.root;
		var tracks = action.clip.tracks;

		for ( var i = 0; i < tracks.length; i ++ ) {

			var track = tracks[ i ];

			var propertyBindingKey = root.uuid + '-' + track.name;
			var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

			propertyBinding.referenceCount -= 1;

			if ( propertyBinding.referenceCount <= 0 ) {

				propertyBinding.unbind();

				delete this.propertyBindingMap[ propertyBindingKey ];

			}
		}

		return this;

	},

	// can be optimized if needed
	findActionByName: function( name ) {

		for ( var i = 0; i < this.actions.length; i ++ ) {

			if ( this.actions[i].name === name ) return this.actions[i];

		}

		return null;

	},

	play: function( action, optionalFadeInDuration ) {

		action.startTime = this.time;
		this.addAction( action );

		return this;

	},

	fadeOut: function( action, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: 1 } );
		keys.push( { time: this.time + duration, value: 0 } );

		action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

		return this;

	},

	fadeIn: function( action, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: 0 } );
		keys.push( { time: this.time + duration, value: 1 } );

		action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

		return this;

	},

	warp: function( action, startTimeScale, endTimeScale, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: startTimeScale } );
		keys.push( { time: this.time + duration, value: endTimeScale } );

		action.timeScale = new THREE.NumberKeyframeTrack( "timeScale", keys );

		return this;

	},

	crossFade: function( fadeOutAction, fadeInAction, duration, warp ) {

		this.fadeOut( fadeOutAction, duration );
		this.fadeIn( fadeInAction, duration );

		if ( warp ) {

			var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
			var endStartRatio = 1.0 / startEndRatio;

			this.warp( fadeOutAction, 1.0, startEndRatio, duration );
			this.warp( fadeInAction, endStartRatio, 1.0, duration );

		}

		return this;

	},

	update: function( deltaTime ) {

		var mixerDeltaTime = deltaTime * this.timeScale;
		this.time += mixerDeltaTime;

		for ( var i = 0; i < this.actions.length; i ++ ) {

			var action = this.actions[i];

			var weight = action.getWeightAt( this.time );

			var actionTimeScale = action.getTimeScaleAt( this.time );
			var actionDeltaTime = mixerDeltaTime * actionTimeScale;

			var actionResults = action.update( actionDeltaTime );

			if ( action.weight <= 0 || ! action.enabled ) continue;

			for ( var j = 0; j < actionResults.length; j ++ ) {

				var name = action.clip.tracks[j].name;

				action.propertyBindings[ j ].accumulate( actionResults[j], weight );

			}

		}

		// apply to nodes
		for ( var propertyBindingKey in this.propertyBindingMap ) {

			this.propertyBindingMap[ propertyBindingKey ].apply();

		}

		return this;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );

// File:src/animation/AnimationUtils.js

/**
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationUtils = {

	getEqualsFunc: function( exemplarValue ) {

		if ( exemplarValue.equals ) {
			return function equals_object( a, b ) {
				return a.equals( b );
			}
		}

		return function equals_primitive( a, b ) {
			return ( a === b );
		};

	},

	clone: function( exemplarValue ) {

		var typeName = typeof exemplarValue;
		if ( typeName === "object" ) {
			if ( exemplarValue.clone ) {
				return exemplarValue.clone();
			}
			console.error( "can not figure out how to copy exemplarValue", exemplarValue );
		}

		return exemplarValue;

	},

	lerp: function( a, b, alpha, interTrack ) {

		var lerpFunc = THREE.AnimationUtils.getLerpFunc( a, interTrack );

		return lerpFunc( a, b, alpha );

	},

	lerp_object: function( a, b, alpha ) {
		return a.lerp( b, alpha );
	},

	slerp_object: function( a, b, alpha ) {
		return a.slerp( b, alpha );
	},

	lerp_number: function( a, b, alpha ) {
		return a * ( 1 - alpha ) + b * alpha;
	},

	lerp_boolean: function( a, b, alpha ) {
		return ( alpha < 0.5 ) ? a : b;
	},

	lerp_boolean_immediate: function( a, b, alpha ) {
		return a;
	},

	lerp_string: function( a, b, alpha ) {
		return ( alpha < 0.5 ) ? a : b;
	},

	lerp_string_immediate: function( a, b, alpha ) {
 		return a;
 	},

	// NOTE: this is an accumulator function that modifies the first argument (e.g. a).	This is to minimize memory alocations.
	getLerpFunc: function( exemplarValue, interTrack ) {

		if ( exemplarValue === undefined || exemplarValue === null ) throw new Error( "examplarValue is null" );

		var typeName = typeof exemplarValue;

		switch( typeName ) {

			case "object":
				if ( exemplarValue.lerp ) {
					return THREE.AnimationUtils.lerp_object;
				}

				if ( exemplarValue.slerp ) {
					return THREE.AnimationUtils.slerp_object;
				}
				break;

			case "number":
				return THREE.AnimationUtils.lerp_number;

			case "boolean":
				if ( interTrack ) {
					return THREE.AnimationUtils.lerp_boolean;
				} else {
					return THREE.AnimationUtils.lerp_boolean_immediate;
				}

			case "string":
				if ( interTrack ) {
					return THREE.AnimationUtils.lerp_string;
				} else {
					return THREE.AnimationUtils.lerp_string_immediate;
				}

		}

	}

};

// File:src/animation/KeyframeTrack.js

/**
 *
 * A Track that returns a keyframe interpolated value, currently linearly interpolated
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.KeyframeTrack = function ( name, keys ) {

	if ( name === undefined ) throw new Error( "track name is undefined" );
	if ( keys === undefined || keys.length === 0 ) throw new Error( "no keys in track named " + name );

	this.name = name;
	this.keys = keys;	// time in seconds, value as value

	// the index of the last result, used as a starting point for local search.
	this.lastIndex = 0;

	this.validate();
	this.optimize();

};

THREE.KeyframeTrack.prototype = {

	constructor: THREE.KeyframeTrack,

	getAt: function( time ) {


		// this can not go higher than this.keys.length.
		while( ( this.lastIndex < this.keys.length ) && ( time >= this.keys[this.lastIndex].time ) ) {
			this.lastIndex ++;
		};

		// this can not go lower than 0.
		while( ( this.lastIndex > 0 ) && ( time < this.keys[this.lastIndex - 1].time ) ) {
			this.lastIndex --;
		}

		if ( this.lastIndex >= this.keys.length ) {

			this.setResult( this.keys[ this.keys.length - 1 ].value );

			return this.result;

		}

		if ( this.lastIndex === 0 ) {

			this.setResult( this.keys[ 0 ].value );

			return this.result;

		}

		var prevKey = this.keys[ this.lastIndex - 1 ];
		this.setResult( prevKey.value );

		// if true, means that prev/current keys are identical, thus no interpolation required.
		if ( prevKey.constantToNext ) {

			return this.result;

		}

		// linear interpolation to start with
		var currentKey = this.keys[ this.lastIndex ];
		var alpha = ( time - prevKey.time ) / ( currentKey.time - prevKey.time );
		this.result = this.lerpValues( this.result, currentKey.value, alpha );

		return this.result;

	},

	// move all keyframes either forwards or backwards in time
	shift: function( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			for ( var i = 0; i < this.keys.length; i ++ ) {
				this.keys[i].time += timeOffset;
			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function( timeScale ) {

		if ( timeScale !== 1.0 ) {

			for ( var i = 0; i < this.keys.length; i ++ ) {
				this.keys[i].time *= timeScale;
			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
 	trim: function( startTime, endTime ) {

		var firstKeysToRemove = 0;
		for ( var i = 1; i < this.keys.length; i ++ ) {
			if ( this.keys[i] <= startTime ) {
				firstKeysToRemove ++;
			}
		}

		var lastKeysToRemove = 0;
		for ( var i = this.keys.length - 2; i > 0; i ++ ) {
			if ( this.keys[i] >= endTime ) {
				lastKeysToRemove ++;
			} else {
				break;
			}
		}

		// remove last keys first because it doesn't affect the position of the first keys (the otherway around doesn't work as easily)
		if ( ( firstKeysToRemove + lastKeysToRemove ) > 0 ) {
			this.keys = this.keys.splice( firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove );;
		}

		return this;

	},

	/* NOTE: This is commented out because we really shouldn't have to handle unsorted key lists
	         Tracks with out of order keys should be considered to be invalid.  - bhouston
	sort: function() {

		this.keys.sort( THREE.KeyframeTrack.keyComparer );

		return this;

	},*/

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	// One could eventually ensure that all key.values in a track are all of the same type (otherwise interpolation makes no sense.)
	validate: function() {

		var prevKey = null;

		if ( this.keys.length === 0 ) {
			console.error( "  track is empty, no keys", this );
			return;
		}

		for ( var i = 0; i < this.keys.length; i ++ ) {

			var currKey = this.keys[i];

			if ( ! currKey ) {
				console.error( "  key is null in track", this, i );
				return;
			}

			if ( ( typeof currKey.time ) !== 'number' || isNaN( currKey.time ) ) {
				console.error( "  key.time is not a valid number", this, i, currKey );
				return;
			}

			if ( currKey.value === undefined || currKey.value === null) {
				console.error( "  key.value is null in track", this, i, currKey );
				return;
			}

			if ( prevKey && prevKey.time > currKey.time ) {
				console.error( "  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey );
				return;
			}

			prevKey = currKey;

		}

		return this;

	},

	// currently only removes equivalent sequential keys (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0), which are common in morph target animations
	optimize: function() {

		var newKeys = [];
		var prevKey = this.keys[0];
		newKeys.push( prevKey );

		var equalsFunc = THREE.AnimationUtils.getEqualsFunc( prevKey.value );

		for ( var i = 1; i < this.keys.length - 1; i ++ ) {
			var currKey = this.keys[i];
			var nextKey = this.keys[i+1];

			// if prevKey & currKey are the same time, remove currKey.  If you want immediate adjacent keys, use an epsilon offset
			// it is not possible to have two keys at the same time as we sort them.  The sort is not stable on keys with the same time.
			if ( ( prevKey.time === currKey.time ) ) {

				continue;

			}

			// remove completely unnecessary keyframes that are the same as their prev and next keys
			if ( this.compareValues( prevKey.value, currKey.value ) && this.compareValues( currKey.value, nextKey.value ) ) {

				continue;

			}

			// determine if interpolation is required
			prevKey.constantToNext = this.compareValues( prevKey.value, currKey.value );

			newKeys.push( currKey );
			prevKey = currKey;
		}
		newKeys.push( this.keys[ this.keys.length - 1 ] );

		this.keys = newKeys;

		return this;

	}

};

THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
	return key0.time - key1.time;
};

THREE.KeyframeTrack.parse = function( json ) {

	if ( json.type === undefined ) throw new Error( "track type undefined, can not parse" );

	var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName( json.type );

	return trackType.parse( json );

};

THREE.KeyframeTrack.GetTrackTypeForTypeName = function( typeName ) {
	switch( typeName.toLowerCase() ) {
	 	case "vector":
	 	case "vector2":
	 	case "vector3":
	 	case "vector4":
			return THREE.VectorKeyframeTrack;

	 	case "quaternion":
			return THREE.QuaternionKeyframeTrack;

	 	case "integer":
	 	case "scalar":
	 	case "double":
	 	case "float":
	 	case "number":
			return THREE.NumberKeyframeTrack;

	 	case "bool":
	 	case "boolean":
			return THREE.BooleanKeyframeTrack;

	 	case "string":
	 		return THREE.StringKeyframeTrack;
	};

	throw new Error( "Unsupported typeName: " + typeName );
};

// File:src/animation/PropertyBinding.js

/**
 *
 * A track bound to a real value in the scene graph.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.PropertyBinding = function ( rootNode, trackName ) {

	this.rootNode = rootNode;
	this.trackName = trackName;
	this.referenceCount = 0;
	this.originalValue = null; // the value of the property before it was controlled by this binding

	var parseResults = THREE.PropertyBinding.parseTrackName( trackName );

	this.directoryName = parseResults.directoryName;
	this.nodeName = parseResults.nodeName;
	this.objectName = parseResults.objectName;
	this.objectIndex = parseResults.objectIndex;
	this.propertyName = parseResults.propertyName;
	this.propertyIndex = parseResults.propertyIndex;

	this.node = THREE.PropertyBinding.findNode( rootNode, this.nodeName ) || rootNode;

	this.cumulativeValue = null;
	this.cumulativeWeight = 0;
};

THREE.PropertyBinding.prototype = {

	constructor: THREE.PropertyBinding,

	reset: function() {

		this.cumulativeValue = null;
		this.cumulativeWeight = 0;

	},

	accumulate: function( value, weight ) {

		if ( ! this.isBound ) this.bind();

		if ( this.cumulativeWeight === 0 ) {

			if ( weight > 0 ) {

				if ( this.cumulativeValue === null ) {
					this.cumulativeValue = THREE.AnimationUtils.clone( value );
				}
				this.cumulativeWeight = weight;

			}

		} else {

			var lerpAlpha = weight / ( this.cumulativeWeight + weight );
			this.cumulativeValue = this.lerpValue( this.cumulativeValue, value, lerpAlpha );
			this.cumulativeWeight += weight;

		}

	},

	unbind: function() {

		if ( ! this.isBound ) return;

		this.setValue( this.originalValue );

		this.setValue = null;
		this.getValue = null;
		this.lerpValue = null;
		this.equalsValue = null;
		this.triggerDirty = null;
		this.isBound = false;

	},

	// bind to the real property in the scene graph, remember original value, memorize various accessors for speed/inefficiency
	bind: function() {

		if ( this.isBound ) return;

		var targetObject = this.node;

 		// ensure there is a value node
		if ( ! targetObject ) {
			console.error( "  trying to update node for track: " + this.trackName + " but it wasn't found." );
			return;
		}

		if ( this.objectName ) {
			// special case were we need to reach deeper into the hierarchy to get the face materials....
			if ( this.objectName === "materials" ) {
				if ( ! targetObject.material ) {
					console.error( '  can not bind to material as node does not have a material', this );
					return;
				}
				if ( ! targetObject.material.materials ) {
					console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
					return;
				}
				targetObject = targetObject.material.materials;
			} else if ( this.objectName === "bones" ) {
				if ( ! targetObject.skeleton ) {
					console.error( '  can not bind to bones as node does not have a skeleton', this );
					return;
				}
				// potential future optimization: skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				targetObject = targetObject.skeleton.bones;

				// support resolving morphTarget names into indices.
				for ( var i = 0; i < targetObject.length; i ++ ) {
					if ( targetObject[i].name === this.objectIndex ) {
						this.objectIndex = i;
						break;
					}
				}
			} else {

				if ( targetObject[ this.objectName ] === undefined ) {
					console.error( '  can not bind to objectName of node, undefined', this );
					return;
				}
				targetObject = targetObject[ this.objectName ];
			}

			if ( this.objectIndex !== undefined ) {
				if ( targetObject[ this.objectIndex ] === undefined ) {
					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
					return;
				}

				targetObject = targetObject[ this.objectIndex ];
			}

		}

 		// special case mappings
 		var nodeProperty = targetObject[ this.propertyName ];
		if ( ! nodeProperty ) {
			console.error( "  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject );
			return;
		}

		// access a sub element of the property array (only primitives are supported right now)
		if ( this.propertyIndex !== undefined ) {

			if ( this.propertyName === "morphTargetInfluences" ) {
				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {
					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
				}
				if ( ! targetObject.geometry.morphTargets ) {
					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
				}

				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
					if ( targetObject.geometry.morphTargets[i].name === this.propertyIndex ) {
						this.propertyIndex = i;
						break;
					}
				}
			}

			this.setValue = function setValue_propertyIndexed( value ) {
				if ( ! this.equalsValue( nodeProperty[ this.propertyIndex ], value ) ) {
					nodeProperty[ this.propertyIndex ] = value;
					return true;
				}
				return false;
			};

			this.getValue = function getValue_propertyIndexed() {
				return nodeProperty[ this.propertyIndex ];
			};

		}
		// must use copy for Object3D.Euler/Quaternion
		else if ( nodeProperty.copy ) {

			this.setValue = function setValue_propertyObject( value ) {
				if ( ! this.equalsValue( nodeProperty, value ) ) {
					nodeProperty.copy( value );
					return true;
				}
				return false;
			}

			this.getValue = function getValue_propertyObject() {
				return nodeProperty;
			};

		}
		// otherwise just set the property directly on the node (do not use nodeProperty as it may not be a reference object)
		else {

			this.setValue = function setValue_property( value ) {
				if ( ! this.equalsValue( targetObject[ this.propertyName ], value ) ) {
					targetObject[ this.propertyName ] = value;
					return true;
				}
				return false;
			}

			this.getValue = function getValue_property() {
				return targetObject[ this.propertyName ];
			};

		}

		// trigger node dirty
		if ( targetObject.needsUpdate !== undefined ) { // material

			this.triggerDirty = function triggerDirty_needsUpdate() {
				this.node.needsUpdate = true;
			}

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
				targetObject.matrixWorldNeedsUpdate = true;
			}

		}

		this.originalValue = this.getValue();

		this.equalsValue = THREE.AnimationUtils.getEqualsFunc( this.originalValue );
		this.lerpValue = THREE.AnimationUtils.getLerpFunc( this.originalValue, true );

		this.isBound = true;

	},

	apply: function() {

		// for speed capture the setter pattern as a closure (sort of a memoization pattern: https://en.wikipedia.org/wiki/Memoization)
		if ( ! this.isBound ) this.bind();

		// early exit if there is nothing to apply.
		if ( this.cumulativeWeight > 0 ) {

			// blend with original value
			if ( this.cumulativeWeight < 1 ) {

				var remainingWeight = 1 - this.cumulativeWeight;
				var lerpAlpha = remainingWeight / ( this.cumulativeWeight + remainingWeight );
				this.cumulativeValue = this.lerpValue( this.cumulativeValue, this.originalValue, lerpAlpha );

			}

			var valueChanged = this.setValue( this.cumulativeValue );

			if ( valueChanged && this.triggerDirty ) {
				this.triggerDirty();
			}

			// reset accumulator
			this.cumulativeValue = null;
			this.cumulativeWeight = 0;

		}
	}

};


THREE.PropertyBinding.parseTrackName = function( trackName ) {

	// matches strings in the form of:
	//    nodeName.property
	//    nodeName.property[accessor]
	//    nodeName.material.property[accessor]
	//    uuid.property[accessor]
	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
	//    parentName/nodeName.property
	//    parentName/parentName/nodeName.property[index]
	//	  .bone[Armature.DEF_cog].position
	// created and tested via https://regex101.com/#javascript

	var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
	var matches = re.exec(trackName);

	if ( ! matches ) {
		throw new Error( "cannot parse trackName at all: " + trackName );
	}

    if (matches.index === re.lastIndex) {
        re.lastIndex++;
    }

	var results = {
		directoryName: matches[1],
		nodeName: matches[3], 	// allowed to be null, specified root node.
		objectName: matches[5],
		objectIndex: matches[7],
		propertyName: matches[9],
		propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
	};

	if ( results.propertyName === null || results.propertyName.length === 0 ) {
		throw new Error( "can not parse propertyName from trackName: " + trackName );
	}

	return results;

};

THREE.PropertyBinding.findNode = function( root, nodeName ) {

	function searchSkeleton( skeleton ) {

		for ( var i = 0; i < skeleton.bones.length; i ++ ) {

			var bone = skeleton.bones[i];

			if ( bone.name === nodeName ) {

				return bone;

			}
		}

		return null;

	}

	function searchNodeSubtree( children ) {

		for ( var i = 0; i < children.length; i ++ ) {

			var childNode = children[i];

			if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

				return childNode;

			}

			var result = searchNodeSubtree( childNode.children );

			if ( result ) return result;

		}

		return null;

	}

	//

	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

		return root;

	}

	// search into skeleton bones.
	if ( root.skeleton ) {

		var bone = searchSkeleton( root.skeleton );

		if ( bone ) {

			return bone;

		}
	}

	// search into node subtree.
	if ( root.children ) {

		var subTreeNode = searchNodeSubtree( root.children );

		if ( subTreeNode ) {

			return subTreeNode;

		}

	}

	return null;
}

// File:src/animation/tracks/VectorKeyframeTrack.js

/**
 *
 * A Track that interpolates Vectors
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.VectorKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value.clone();

};

THREE.VectorKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;

THREE.VectorKeyframeTrack.prototype.setResult = function( value ) {

	this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.VectorKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0.lerp( value1, alpha );

};

THREE.VectorKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return value0.equals( value1 );

};

THREE.VectorKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value.clone()
		} );
	}

	return new THREE.VectorKeyframeTrack( this.name, clonedKeys );

};

THREE.VectorKeyframeTrack.parse = function( json ) {

	var elementCount = json.keys[0].value.length;
	var valueType = THREE[ 'Vector' + elementCount ];

	var keys = [];

	for ( var i = 0; i < json.keys.length; i ++ ) {
		var jsonKey = json.keys[i];
		keys.push( {
			value: new valueType().fromArray( jsonKey.value ),
			time: jsonKey.time
		} );
	}

	return new THREE.VectorKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/QuaternionKeyframeTrack.js

/**
 *
 * A Track that interpolates Quaternion
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.QuaternionKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value.clone();

};

THREE.QuaternionKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;

THREE.QuaternionKeyframeTrack.prototype.setResult = function( value ) {

	this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.QuaternionKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0.slerp( value1, alpha );

};

THREE.QuaternionKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return value0.equals( value1 );

};

THREE.QuaternionKeyframeTrack.prototype.multiply = function( quat ) {

	for ( var i = 0; i < this.keys.length; i ++ ) {

		this.keys[i].value.multiply( quat );

	}

	return this;

};

THREE.QuaternionKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value.clone()
		} );
	}

	return new THREE.QuaternionKeyframeTrack( this.name, clonedKeys );

};

THREE.QuaternionKeyframeTrack.parse = function( json ) {

	var keys = [];

	for ( var i = 0; i < json.keys.length; i ++ ) {
		var jsonKey = json.keys[i];
		keys.push( {
			value: new THREE.Quaternion().fromArray( jsonKey.value ),
			time: jsonKey.time
		} );
	}

	return new THREE.QuaternionKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/StringKeyframeTrack.js

/**
 *
 * A Track that interpolates Strings
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.StringKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.StringKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;

THREE.StringKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.StringKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.StringKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.StringKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.StringKeyframeTrack( this.name, clonedKeys );

};

THREE.StringKeyframeTrack.parse = function( json ) {

	return new THREE.StringKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/BooleanKeyframeTrack.js

/**
 *
 * A Track that interpolates Boolean
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.BooleanKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.BooleanKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;

THREE.BooleanKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.BooleanKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.BooleanKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.BooleanKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.BooleanKeyframeTrack( this.name, clonedKeys );

};

THREE.BooleanKeyframeTrack.parse = function( json ) {

	return new THREE.BooleanKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/NumberKeyframeTrack.js

/**
 *
 * A Track that interpolates Numbers
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.NumberKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.NumberKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;

THREE.NumberKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.NumberKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0 * ( 1 - alpha ) + value1 * alpha;

};

THREE.NumberKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.NumberKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.NumberKeyframeTrack( this.name, clonedKeys );

};

THREE.NumberKeyframeTrack.parse = function( json ) {

	return new THREE.NumberKeyframeTrack( json.name, json.keys );

};

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

	var quaternion = new THREE.Quaternion();

	return function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	};

}();

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function () {

	return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.matrixWorldInverse.copy( source.matrixWorldInverse );
	this.projectionMatrix.copy( source.projectionMatrix );

	return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

		renderer.setRenderTarget( null );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	var dx = ( this.right - this.left ) / ( 2 * this.zoom );
	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
	var cx = ( this.right + this.left ) / 2;
	var cy = ( this.top + this.bottom ) / 2;

	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function ( source ) {
	
	THREE.Camera.prototype.copy.call( this, source );
	
	this.left = source.left;
	this.right = source.right;
	this.top = source.top;
	this.bottom = source.bottom;
	this.near = source.near;
	this.far = source.far;
	
	this.zoom = source.zoom;
	
	return this;
		
};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.zoom = this.zoom;
	data.object.left = this.left;
	data.object.right = this.right;
	data.object.top = this.top;
	data.object.bottom = this.bottom;
	data.object.near = this.near;
	data.object.far = this.far;

	return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.zoom = 1;

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
		var bottom = - top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.copy = function ( source ) {
	
	THREE.Camera.prototype.copy.call( this, source );
	
	this.fov = source.fov;
	this.aspect = source.aspect;
	this.near = source.near;
	this.far = source.far;
	
	this.zoom = source.zoom;
	
	return this;
		
};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.zoom = this.zoom;
	data.object.fov = this.fov;
	data.object.aspect = this.aspect;
	data.object.near = this.near;
	data.object.far = this.far;

	return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.type = 'Light';

	this.color = new THREE.Color( color );

	this.receiveShadow = undefined;

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

Object.defineProperties( THREE.Light.prototype, {
	onlyShadow: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
		}
	},
	shadowCameraFov: {
		set: function ( value ) {
			this.shadow.camera.fov = value;
		}
	},
	shadowCameraLeft: {
		set: function ( value ) {
			this.shadow.camera.left = value;
		}
	},
	shadowCameraRight: {
		set: function ( value ) {
			this.shadow.camera.right = value;
		}
	},
	shadowCameraTop: {
		set: function ( value ) {
			this.shadow.camera.top = value;
		}
	},
	shadowCameraBottom: {
		set: function ( value ) {
			this.shadow.camera.bottom = value;
		}
	},
	shadowCameraNear: {
		set: function ( value ) {
			this.shadow.camera.near = value;
		}
	},
	shadowCameraFar: {
		set: function ( value ) {
			this.shadow.camera.far = value;
		}
	},
	shadowCameraVisible: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.' );
		}
	},
	shadowBias: {
		set: function ( value ) {
			this.shadow.bias = value;
		}
	},
	shadowDarkness: {
		set: function ( value ) {
			this.shadow.darkness = value;
		}
	},
	shadowMapWidth: {
		set: function ( value ) {
			this.shadow.mapSize.width = value;
		}
	},
	shadowMapHeight: {
		set: function ( value ) {
			this.shadow.mapSize.height = value;
		}
	}
} );

THREE.Light.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.color.copy( source.color );

	return this;

};

THREE.Light.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.color = this.color.getHex();
	if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

	if ( this.intensity !== undefined ) data.object.intensity = this.intensity;
	if ( this.distance !== undefined ) data.object.distance = this.distance;
	if ( this.angle !== undefined ) data.object.angle = this.angle;
	if ( this.decay !== undefined ) data.object.decay = this.decay;
	if ( this.exponent !== undefined ) data.object.exponent = this.exponent;

	return data;

};

// File:src/lights/LightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LightShadow = function ( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.darkness = 1;

	this.mapSize = new THREE.Vector2( 512, 512 );

	this.map = null;
	this.matrix = null;

};

THREE.LightShadow.prototype = {

	constructor: THREE.LightShadow,

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.darkness = source.darkness;

		this.mapSize.copy( source.mapSize );

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 500, 500, 500, - 500, 50, 5000 ) );

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.target = source.target.clone();

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.groundColor.copy( source.groundColor );
	this.intensity = source.intensity;

	return this;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.PointLight = function ( color, intensity, distance, decay ) {

	THREE.Light.call( this, color );

	this.type = 'PointLight';

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 1, 500 ) );

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.distance = source.distance;
	this.decay = source.decay;

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

	THREE.Light.call( this, color );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 50, 5000 ) );

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.distance = source.distance;
	this.angle = source.angle;
	this.exponent = source.exponent;
	this.decay = source.decay;

	this.target = source.target.clone();

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath, crossOrigin ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

		}

		return array;

	},

	createMaterial: ( function () {

		var color, textureLoader, materialLoader;

		return function ( m, texturePath, crossOrigin ) {

			if ( color === undefined ) color = new THREE.Color();
			if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
			if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();

			// convert from old material format

			var textures = {};

			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + path;
				var loader = THREE.Loader.Handlers.get( fullPath );

				var texture;

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );

				}

				if ( repeat !== undefined ) {

					texture.repeat.fromArray( repeat );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( offset !== undefined ) {

					texture.offset.fromArray( offset );

				}

				if ( wrap !== undefined ) {

					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

				}

				if ( anisotropy !== undefined ) {

					texture.anisotropy = anisotropy;

				}

				var uuid = THREE.Math.generateUUID();

				textures[ uuid ] = texture;

				return uuid;

			}

			//

			var json = {
				uuid: THREE.Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};

			for ( var name in m ) {

				var value = m[ name ];

				switch ( name ) {
					case 'DbgColor':
						json.color = value;
						break;
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						// These were never supported
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = THREE[ value ];
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = THREE.BackSide;
						break;
					case 'doubleSided':
						json.side = THREE.DoubleSide;
						break;
					case 'transparency':
						console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
						json.opacity = value;
						break;
					case 'opacity':
					case 'transparent':
					case 'depthTest':
					case 'depthWrite':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = THREE.VertexColors;
						if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
						break;
					default:
						console.error( 'Loader.createMaterial: Unsupported', name, value );
						break;
				}

			}

			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
			if ( json.opacity < 1 ) json.transparent = true;

			materialLoader.setTextures( textures );

			return materialLoader.parse( json );

		};

	} )()

};

THREE.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		var handlers = this.handlers;

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader  = handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = THREE.Cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

				}, 0 );

			}

			return cached;

		}

		var request = new XMLHttpRequest();
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			var response = event.target.response;

			THREE.Cache.add( url, response );

			if ( onLoad ) onLoad( response );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		request.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
		if ( this.responseType !== undefined ) request.responseType = this.responseType;
		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

		request.send( null );

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;

	}

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = THREE.Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

			} else {

				scope.manager.itemEnd( url );

			}

			return cached;

		}

		var image = document.createElement( 'img' );

		image.addEventListener( 'load', function ( event ) {

			THREE.Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		image.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( manager ) {

	if ( typeof manager === 'boolean' ) {

		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;

	}

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

	constructor: THREE.JSONLoader,

	// Deprecated

	get statusDomElement () {

		if ( this._statusDomElement === undefined ) {

			this._statusDomElement = document.createElement( 'div' );

		}

		console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
		return this._statusDomElement;

	},

	load: function( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			var json = JSON.parse( text );
			var metadata = json.metadata;

			if ( metadata !== undefined ) {

				if ( metadata.type === 'object' ) {

					console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
					return;

				}

				if ( metadata.type === 'scene' ) {

					console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
					return;

				}

			}

			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	parse: function ( json, texturePath ) {

		var geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );
		parseAnimations();

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new THREE.Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		};

		function parseSkin() {

			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}

		};

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;

					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					faces[ i ].color.fromArray( morphColors, i * 3 );

				}

			}

		}

		function parseAnimations() {

			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];
			if ( json.animation !== undefined ) {
				animations.push( json.animation );
			}
			if ( json.animations !== undefined ) {
				if ( json.animations.length ) {
					animations = animations.concat( json.animations );
				} else {
					animations.push( json.animations );
				}
			}

			for ( var i = 0; i < animations.length; i ++ ) {

				var clip = THREE.AnimationClip.parseAnimation( animations[i], geometry.bones );
				if ( clip ) outputAnimations.push( clip );

			}

			// parse implicit morph animations
			if ( geometry.morphTargets ) {

				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
				var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );

			}

			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

		};

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

			return { geometry: geometry, materials: materials };

		}

	}

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var index = json.data.index;

		if ( index !== undefined ) {

			var typedArray = new self[ index.type ]( index.array );
			geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new self[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new THREE.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	this.textures = {};

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setTextures: function ( value ) {

		this.textures = value;

	},

	getTexture: function ( name ) {

		var textures = this.textures;

		if ( textures[ name ] === undefined ) {

			console.warn( 'THREE.MaterialLoader: Undefined texture', name );

		}

		return textures[ name ];

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];
		material.uuid = json.uuid;

		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

		// for PointsMaterial
		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = this.getTexture( json.map );

		if ( json.alphaMap !== undefined ) {

			material.alphaMap = this.getTexture( json.alphaMap );
			material.transparent = true;

		}

		if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
		if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

		if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

		if ( json.envMap !== undefined ) {

			material.envMap = this.getTexture( json.envMap );
			material.combine = THREE.MultiplyOperation;

		}

		if ( json.reflectivity ) material.reflectivity = json.reflectivity;

		if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		// MeshFaceMaterial

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.texturePath === '' ) {

			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

		}

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json, onLoad ) {

		var geometries = this.parseGeometries( json.geometries );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures  = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new THREE[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleBufferGeometry':

						geometry = new THREE.CircleBufferGeometry(
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereBufferGeometry':

						geometry = new THREE.SphereBufferGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':

						geometry = new THREE.DodecahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'OctahedronGeometry':

						geometry = new THREE.OctahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TetrahedronGeometry':

						geometry = new THREE.TetrahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':

						geometry = new THREE.RingGeometry(
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var material = loader.parse( json[ i ] );
				materials[ material.uuid ] = material;

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = THREE.AnimationClip.parse( json[i] );

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new THREE.LoadingManager( onLoad );

			var loader = new THREE.ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

				images[ image.uuid ] = loadImage( path );

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value ) {

			if ( typeof( value ) === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return THREE[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture = new THREE.Texture( images[ data.image ] );
				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;
				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
				if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
				if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
				if ( Array.isArray( data.wrap ) ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ] );
					texture.wrapT = parseConstant( data.wrap[ 1 ] );

				}

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LOD':

					object = new THREE.LOD();

					break;

				case 'Line':

					object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'PointCloud':
				case 'Points':

					object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new THREE.Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new THREE.Group();

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

	}()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new THREE.Texture();

		var loader = new THREE.ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CubeTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.CubeTextureLoader.prototype = {

	constructor: THREE.CubeTextureLoader,

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new THREE.CubeTexture( [] );

		var loader = new THREE.ImageLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

	constructor: THREE.BinaryTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new THREE.DataTexture();

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( ! texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = THREE.LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

	constructor: THREE.CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new THREE.CompressedTexture();
		texture.image = images;

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setResponseType( 'arraybuffer' );

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
 							texture.minFilter = THREE.LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			};

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = THREE.LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this._needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue instanceof THREE.Color ) {

				currentValue.set( newValue );

			} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

				currentValue.copy( newValue );

			} else if ( key === 'overdraw' ) {

				// ensure overdraw is backwards-compatible with legacy boolean type
				this[ key ] = Number( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
		if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
		if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;

		if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap instanceof THREE.Texture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}
		if ( this.normalMap instanceof THREE.Texture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

		}
		if ( this.displacementMap instanceof THREE.Texture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}
		if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.envMap instanceof THREE.Texture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
		if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
		if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
		if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;
		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.side = source.side;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blending = source.blending;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.alphaTest = source.alphaTest;

		this.overdraw = source.overdraw;

		this.visible = source.visible;

		return this;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	// Deprecated

	get wrapAround () {

		console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

	},

	set wrapAround ( boolean ) {

		console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

	},

	get wrapRGB () {

		console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
		return new THREE.Color();

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	
	this.linewidth = source.linewidth;

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
	
	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	
	return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.emissive = new THREE.Color( 0x000000 );

	this.map = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.emissive.copy( source.emissive );

	this.map = source.map;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.emissive.copy( source.emissive );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.metal = source.metal;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissiveMap = source.emissiveMap;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.morphTargets = false;
	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function ( materials ) {

	this.uuid = THREE.Math.generateUUID();

	this.type = 'MultiMaterial';

	this.materials = materials instanceof Array ? materials : [];

	this.visible = true;

};

THREE.MultiMaterial.prototype = {

	constructor: THREE.MultiMaterial,

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

			output.materials.push( this.materials[ i ].toJSON() );

		}

		output.visible = this.visible;

		return output;

	},

	clone: function () {

		var material = new this.constructor();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		material.visible = this.visible;

		return material;

	}

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// backwards compatibility

THREE.PointCloudMaterial = function ( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

THREE.ParticleBasicMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.derivatives = false; // set to use derivatives

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

	this.attributes = source.attributes;
	this.defines = source.defines;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.fog = source.fog;

	this.lights = source.lights;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.derivatives = source.derivatives;

	return this;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = THREE.Material.prototype.toJSON.call( this, meta );

	data.uniforms = this.uniforms;
	data.attributes = this.attributes;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

	THREE.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.map = source.map;

	this.rotation = source.rotation;

	this.fog = source.fog;

	return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.sourceFile = '';

	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this.version = 0;
	this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	set needsUpdate ( value ) {

		if ( value === true ) this.version ++;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;

		return this;

	},

	toJSON: function ( meta ) {

		if ( meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElement( 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		var output = {
			metadata: {
				version: 4.4,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy
		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = THREE.Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== THREE.UVMapping )  return;

		uv.multiply( this.repeat );
		uv.add( this.offset );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case THREE.RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case THREE.ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case THREE.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case THREE.RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case THREE.ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case THREE.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.images = images;
	this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function ( source ) {

	THREE.Texture.prototype.copy.call( this, source );
	
	this.images = source.images;
	
	return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
	
	this.flipY = false;
	this.generateMipmaps  = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	function update() {

		requestAnimationFrame( update );

		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

			scope.needsUpdate = true;

		}

	}

	update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

	THREE.Object3D.call( this );

	this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();

	return function raycast( raycaster, intersects ) {

		var object = this;
		var geometry = object.geometry;
		var threshold = raycaster.params.Points.threshold;

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

				return;

			}

		}

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var localThresholdSq = localThreshold * localThreshold;
		var position = new THREE.Vector3();

		function testPoint( point, index ) {

			var rayPointDistanceSq = ray.distanceSqToPoint( point );

			if ( rayPointDistanceSq < localThresholdSq ) {

				var intersectPoint = ray.closestPointToPoint( point );
				intersectPoint.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					distanceToRay: Math.sqrt( rayPointDistanceSq ),
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object

				} );

			}

		}

		if ( geometry instanceof THREE.BufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, il = indices.length; i < il; i ++ ) {

					var a = indices[ i ];

					position.fromArray( positions, a * 3 );

					testPoint( position, a );

				}

			} else {

				for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

					position.fromArray( positions, i * 3 );

					testPoint( position, i );

				}

			}

		} else {

			var vertices = geometry.vertices;

			for ( var i = 0, l = vertices.length; i < l; i ++ ) {

				testPoint( vertices[ i ], i );

			}

		}

	};

}() );

THREE.Points.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// Backwards compatibility

THREE.PointCloud = function ( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new THREE.Points( geometry, material );

};

THREE.ParticleSystem = function ( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new THREE.Points( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
		return new THREE.LineSegments( geometry, material );

	}

	THREE.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	return function raycast( raycaster, intersects ) {

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = this.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		// Checking boundingSphere distance to ray

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		var vStart = new THREE.Vector3();
		var vEnd = new THREE.Vector3();
		var interSegment = new THREE.Vector3();
		var interRay = new THREE.Vector3();
		var step = this instanceof THREE.LineSegments ? 2 : 1;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;

			if ( index !== null ) {

				var indices = index.array;
				var positions = attributes.position.array;

				for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

					var a = indices[ i ];
					var b = indices[ i + 1 ];

					vStart.fromArray( positions, a * 3 );
					vEnd.fromArray( positions, b * 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				var positions = attributes.position.array;

				for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

					vStart.fromArray( positions, 3 * i );
					vEnd.fromArray( positions, 3 * i + 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;

			for ( var i = 0; i < nbVertices - 1; i += step ) {

				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > precisionSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				var distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	};

}() );

THREE.Line.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

	THREE.Line.call( this, geometry, material );

	this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = - 1;
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

	return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	var tempA = new THREE.Vector3();
	var tempB = new THREE.Vector3();
	var tempC = new THREE.Vector3();

	var uvA = new THREE.Vector2();
	var uvB = new THREE.Vector2();
	var uvC = new THREE.Vector2();

	var barycoord = new THREE.Vector3();

	var intersectionPoint = new THREE.Vector3();
	var intersectionPointWorld = new THREE.Vector3();

	function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

		THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

		uv1.multiplyScalar( barycoord.x );
		uv2.multiplyScalar( barycoord.y );
		uv3.multiplyScalar( barycoord.z );

		uv1.add( uv2 ).add( uv3 );

		return uv1.clone();

	}

	function checkIntersection( object, raycaster, ray, pA, pB, pC, point ){

		var intersect;
		var material = object.material;

		if ( material.side === THREE.BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

		}

		if ( intersect === null ) return null;

		intersectionPointWorld.copy( point );
		intersectionPointWorld.applyMatrix4( object.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

		vA.fromArray( positions, a * 3 );
		vB.fromArray( positions, b * 3 );
		vC.fromArray( positions, c * 3 );

		var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

		if ( intersection ) {

			if ( uvs ) {

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

			}

			intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
			intersection.faceIndex = a;

		}

		return intersection;

	}

	return function raycast( raycaster, intersects ) {

		var geometry = this.geometry;
		var material = this.material;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		var matrixWorld = this.matrixWorld;

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) return;

		// Check boundingBox before continuing

		inverseMatrix.getInverse( matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) return;

		}

		var uvs, intersection;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var a, b, c;
			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( attributes.uv !== undefined ){

				uvs = attributes.uv.array;

			}

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, l = indices.length; i < l; i += 3 ) {

					a = indices[ i ];
					b = indices[ i + 1 ];
					c = indices[ i + 2 ];

					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
						intersects.push( intersection );

					}

				}

			} else {


				for ( var i = 0, l = positions.length; i < l; i += 9 ) {

					a = i / 3;
					b = a + 1;
					c = a + 2;

					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

					if ( intersection ) {

						intersection.index = a; // triangle number in positions buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var fvA, fvB, fvC;
			var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
			var materials = isFaceMaterial === true ? material.materials : null;

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
			if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

			for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

				var face = faces[ f ];
				var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

				if ( faceMaterial === undefined ) continue;

				fvA = vertices[ face.a ];
				fvB = vertices[ face.b ];
				fvC = vertices[ face.c ];

				if ( faceMaterial.morphTargets === true ) {

					var morphTargets = geometry.morphTargets;
					var morphInfluences = this.morphTargetInfluences;

					vA.set( 0, 0, 0 );
					vB.set( 0, 0, 0 );
					vC.set( 0, 0, 0 );

					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

						var influence = morphInfluences[ t ];

						if ( influence === 0 ) continue;

						var targets = morphTargets[ t ].vertices;

						vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
						vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
						vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

					}

					vA.add( fvA );
					vB.add( fvB );
					vC.add( fvC );

					fvA = vA;
					fvB = vB;
					fvC = vC;

				}

				intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

				if ( intersection ) {

					if ( uvs ) {

						var uvs_f = uvs[ f ];
						uvA.copy( uvs_f[ 0 ] );
						uvB.copy( uvs_f[ 1 ] );
						uvC.copy( uvs_f[ 2 ] );

						intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

					}

					intersection.face = face;
					intersection.faceIndex = f;
					intersects.push( intersection );

				}

			}

		}

	};

}() );

THREE.Mesh.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

	THREE.Object3D.call( this );

	this.type = 'Bone';

	this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function ( source ) {
	
	THREE.Object3D.prototype.copy.call( this, source );
	
	this.skin = source.skin;
	
	return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new THREE.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		
		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
		size = Math.max( size, 4 );

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new THREE.Matrix4() );

			}

		}

	}

};

THREE.Skeleton.prototype.calculateInverses = function () {

	this.boneInverses = [];

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		var inverse = new THREE.Matrix4();

		if ( this.bones[ b ] ) {

			inverse.getInverse( this.bones[ b ].matrixWorld );

		}

		this.boneInverses.push( inverse );

	}

};

THREE.Skeleton.prototype.pose = function () {

	var bone;

	// recover the bind-time world matrices

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			bone.matrixWorld.getInverse( this.boneInverses[ b ] );

		}

	}

	// compute the local matrices, positions, rotations and scales

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			if ( bone.parent ) {

				bone.matrix.getInverse( bone.parent.matrixWorld );
				bone.matrix.multiply( bone.matrixWorld );

			} else {

				bone.matrix.copy( bone.matrixWorld );

			}

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		}

	}

};

THREE.Skeleton.prototype.update = ( function () {

	var offsetMatrix = new THREE.Matrix4();

	return function update() {

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform

			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}

	};

} )();

THREE.Skeleton.prototype.clone = function () {

	return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4();
	this.bindMatrixInverse = new THREE.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			bone = new THREE.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.fromArray( gbone.pos );
			bone.quaternion.fromArray( gbone.rotq );
			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 && gbone.parent !== null) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

	this.skeleton = skeleton;

	if ( bindMatrix === undefined ) {

		this.updateMatrixWorld( true );
		
		this.skeleton.calculateInverses();

		bindMatrix = this.matrixWorld;

	}

	this.bindMatrix.copy( bindMatrix );
	this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

	this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

	if ( this.bindMode === "attached" ) {

		this.bindMatrixInverse.getInverse( this.matrixWorld );

	} else if ( this.bindMode === "detached" ) {

		this.bindMatrixInverse.getInverse( this.bindMatrix );

	} else {

		console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

	}

};

THREE.SkinnedMesh.prototype.clone = function() {

	return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		},
		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}
	} );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	var levels = this.levels;

	for ( var l = 0; l < levels.length; l ++ ) {

		if ( distance < levels[ l ].distance ) {

			break;

		}

	}

	levels.splice( l, 0, { distance: distance, object: object } );

	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	var levels = this.levels;

	for ( var i = 1, l = levels.length; i < l; i ++ ) {

		if ( distance < levels[ i ].distance ) {

			break;

		}

	}

	return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function raycast( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( matrixPosition );

		this.getObjectForDistance( distance ).raycast( raycaster, intersects );

	};

}() );

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function update( camera ) {

		var levels = this.levels;

		if ( levels.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			levels[ 0 ].object.visible = true;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source, false );

	var levels = source.levels;

	for ( var i = 0, l = levels.length; i < l; i ++ ) {

		var level = levels[ i ];

		this.addLevel( level.object.clone(), level.distance );

	}

	return this;

};

THREE.LOD.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.levels = [];

	var levels = this.levels;

	for ( var i = 0, l = levels.length; i < l; i ++ ) {

		var level = levels[ i ];

		data.object.levels.push( {
			object: level.object.uuid,
			distance: level.distance
		} );

	}

	return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

	var geometry = new THREE.BufferGeometry();
	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	return function Sprite( material ) {

		THREE.Object3D.call( this );

		this.type = 'Sprite';

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function raycast( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
		var guessSizeSq = this.scale.x * this.scale.y;

		if ( distanceSq > guessSizeSq ) {

			return;

		}

		intersects.push( {

			distance: Math.sqrt( distanceSq ),
			point: this.position,
			face: null,
			object: this

		} );

	};

}() );

THREE.Sprite.prototype.clone = function () {

	return new this.constructor( this.material ).copy( this );

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if ( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if ( size === undefined ) size = - 1;
	if ( distance === undefined ) distance = 0;
	if ( opacity === undefined ) opacity = 1;
	if ( color === undefined ) color = new THREE.Color( 0xffffff );
	if ( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( {
		texture: texture,	// THREE.Texture
		size: size, 		// size in pixels (-1 = use texture.width)
		distance: distance, 	// distance (0-1) from light source (0=at light source)
		x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
		scale: 1, 		// scale
		rotation: 0, 		// rotation
		opacity: opacity,	// opacity
		color: color,		// color
		blending: blending	// blending
	} );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = - this.positionScreen.x * 2;
	var vecY = - this.positionScreen.y * 2;

	for ( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};

THREE.LensFlare.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.positionScreen.copy( source.positionScreen );
	this.customUpdateCallback = source.customUpdateCallback;

	for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

		this.lensFlares.push( source.lensFlares[ i ] );

	}

	return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.type = 'Scene';

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	if ( source.fog !== null ) this.fog = source.fog.clone();
	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

	this.autoUpdate = source.autoUpdate;
	this.matrixAutoUpdate = source.matrixAutoUpdate;

	return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/hemilight_fragment.glsl

THREE.ShaderChunk[ 'hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_phong_fragment.glsl

THREE.ShaderChunk[ 'normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix3 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"specularMap" : { type: "t", value: null },
		"alphaMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: - 1 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 }

	},

	aomap: {

		"aoMap" : { type: "t", value: null },
		"aoMapIntensity" : { type: "f", value: 1 },

	},

	lightmap: {

		"lightMap" : { type: "t", value: null },
		"lightMapIntensity" : { type: "f", value: 1 },

	},

	emissivemap: {

		"emissiveMap" : { type: "t", value: null },

	},

	bumpmap: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

	},

	displacementmap: {

		"displacementMap" : { type: "t", value: null },
		"displacementScale" : { type: "f", value: 1 },
		"displacementBias" : { type: "f", value: 0 }

	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },
		"pointLightDecay" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] },
		"spotLightDecay" : { type: "fv1", value: [] }

	},

	points: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "aomap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

			"	#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	#endif",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "aomap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "aomap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform vec3 emissive;",
			"uniform float opacity;",

			"uniform vec3 ambientLightColor;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = ambientLightColor;",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	#ifdef DOUBLE_SIDED",

			"		if ( gl_FrontFacing )",
			"			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",
			"		else",
			"			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;",

			"	#else",

			"		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",

			"	#endif",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "aomap" ],
			THREE.UniformsLib[ "lightmap" ],
			THREE.UniformsLib[ "emissivemap" ],
			THREE.UniformsLib[ "bumpmap" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "displacementmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",

			"#ifndef FLAT_SHADED",

			"	varying vec3 vNormal;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

			"	vNormal = normalize( transformedNormal );",

			"#endif",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "displacementmap_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"	vViewPosition = - mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"#define PHONG",

			"uniform vec3 diffuse;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "aomap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = ambientLightColor;",
			"	vec3 totalEmissiveLight = emissive;",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "normal_phong_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "hemilight_fragment" ],
				THREE.ShaderChunk[ "aomap_fragment" ],
				THREE.ShaderChunk[ "emissivemap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				"totalDiffuseLight *= shadowMask;",
				"totalSpecularLight *= shadowMask;",

				"#ifdef METAL",

				"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;",

				"#else",

				"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;",

				"#endif",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'points': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "points" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

			"	#ifdef USE_SIZEATTENUATION",
			"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
			"	#else",
			"		gl_PointSize = size;",
			"	#endif",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( psColor, opacity );",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	outgoingLight = diffuseColor.rgb * shadowMask;",

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale"    : { type: "f", value: 1 },
				"dashSize" : { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vLineDistance = scale * lineDistance;",

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

			"		discard;",

			"	}",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],

			"	outgoingLight = diffuseColor.rgb;", // simple shader

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

			"	#else",

			"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"	#endif",

			"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
			"	gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join( "\n" )

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vWorldPosition = transformDirection( position, modelMatrix );",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'equirect': {

		uniforms: { "tEquirect": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vWorldPosition = transformDirection( position, modelMatrix );",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform sampler2D tEquirect;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
				"vec3 direction = normalize( vWorldPosition );",
				"vec2 sampleUV;",
				"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
				"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
				"gl_FragColor = texture2D( tEquirect, sampleUV );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* Depth encoding into RGBA texture
	 *
	 * based on SpiderGL shadow map example
	 * http://spidergl.org/example.php?id=6
	 *
	 * originally from
	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	 *
	 * see also
	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	 */

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"vec4 pack_depth( const in float depth ) {",

			"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
			"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
			"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
			"	res -= res.xxyz * bit_mask;",
			"	return res;",

			"}",

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

			"	#else",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

			"	#endif",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join( "\n" )

	},


	'distanceRGBA': {

		uniforms: {

			"lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }

		},

		vertexShader: [

			"varying vec4 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],

				"vWorldPosition = worldPosition;",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 lightPos;",
			"varying vec4 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],

			"vec4 pack1K ( float depth ) {",

			"   depth /= 1000.0;",
			"   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
  			"	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
   			"	vec4 res = fract( depth * bitSh );",
   			"	res -= res.xxyz * bitMsk;",
   			"	return res; ",

			"}",

			"float unpack1K ( vec4 color ) {",

			"	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"	return dot( color, bitSh ) * 1000.0;",

			"}",

			"void main () {",

			"	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",

			"}"

		].join( "\n" )

	}

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_width = _canvas.width,
	_height = _canvas.height,

	pixelRatio = 1,

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var lights = [];

	var opaqueObjects = [];
	var opaqueObjectsLastIndex = - 1;
	var transparentObjects = [];
	var transparentObjectsLastIndex = - 1;

	var morphInfluences = new Float32Array( 8 );


	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// internal properties

	var _this = this,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryProgram = '',
	_currentCamera = null,

	_usedTextureUnits = 0,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: [], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	},

	// info

	_infoMemory = {

		geometries: 0,
		textures: 0

	},

	_infoRender = {

		calls: 0,
		vertices: 0,
		faces: 0,
		points: 0

	};

	this.info = {

		render: _infoRender,
		memory: _infoMemory,
		programs: null

	};


	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error );

	}

	var extensions = new THREE.WebGLExtensions( _gl );

	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'ANGLE_instanced_arrays' );

	if ( extensions.get( 'OES_element_index_uint' ) ) {

		THREE.BufferGeometry.MaxIndex = 4294967296;

	}

	var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

	var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
	var properties = new THREE.WebGLProperties();
	var objects = new THREE.WebGLObjects( _gl, properties, this.info );
	var programCache = new THREE.WebGLPrograms( this, capabilities );

	this.info.programs = programCache.programs;

	var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
	var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

	//

	function glClearColor( r, g, b, a ) {

		if ( _premultipliedAlpha === true ) {

			r *= a; g *= a; b *= a;

		}

		_gl.clearColor( r, g, b, a );

	}

	function setDefaultGLState() {

		state.init();

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	function resetGLState() {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		_lightsNeedUpdate = true;

		state.reset();

	}

	setDefaultGLState();

	this.context = _gl;
	this.capabilities = capabilities;
	this.extensions = extensions;
	this.state = state;

	// shadow map

	var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

	this.shadowMap = shadowMap;


	// Plugins

	var spritePlugin = new THREE.SpritePlugin( this, sprites );
	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function getMaxAnisotropy() {

			if ( value !== undefined ) return value;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				value = 0;

			}

			return value;

		}

	} )();

	this.getPrecision = function () {

		return capabilities.precision;

	};

	this.getPixelRatio = function () {

		return pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value !== undefined ) pixelRatio = value;

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		_width = width;
		_height = height;

		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * pixelRatio;
		_viewportY = y * pixelRatio;

		_viewportWidth = width * pixelRatio;
		_viewportHeight = height * pixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.getViewport = function ( dimensions ) {

		dimensions.x = _viewportX / pixelRatio;
		dimensions.y = _viewportY / pixelRatio;

		dimensions.z = _viewportWidth / pixelRatio;
		dimensions.w = _viewportHeight / pixelRatio;

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * pixelRatio,
			y * pixelRatio,
			width * pixelRatio,
			height * pixelRatio
		);

	};

	this.enableScissorTest = function ( boolean ) {

		state.setScissorTest( boolean );

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );

		_clearAlpha = alpha !== undefined ? alpha : 1;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	this.dispose = function() {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		resetGLState();
		setDefaultGLState();

		properties.clear();

	};

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_infoMemory.textures --;


	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_infoMemory.textures --;

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.delete( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

		}

		properties.delete( renderTarget.texture );
		properties.delete( renderTarget );

	}

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.delete( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var attributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

			if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

					var array = object.normalArray;

					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;

					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;

					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.normal );

			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.uv );

			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.color );

			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

		setMaterial( material );

		var program = setProgram( camera, lights, fog, material, object );

		var updateBuffers = false;
		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		// morph targets

		var morphTargetInfluences = object.morphTargetInfluences;

		if ( morphTargetInfluences !== undefined ) {

			var activeInfluences = [];

			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

				var influence = morphTargetInfluences[ i ];
				activeInfluences.push( [ influence, i ] );

			}

			activeInfluences.sort( numericalSort );

			if ( activeInfluences.length > 8 ) {

				activeInfluences.length = 8;

			}

			var morphAttributes = geometry.morphAttributes;

			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

				var influence = activeInfluences[ i ];
				morphInfluences[ i ] = influence[ 0 ];

				if ( influence[ 0 ] !== 0 ) {

					var index = influence[ 1 ];

					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

				} else {

					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			var uniforms = program.getUniforms();

			if ( uniforms.morphTargetInfluences !== null ) {

				_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

			}

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;

		if ( material.wireframe === true ) {

			index = objects.getWireframeAttribute( geometry );

		}

		var renderer;

		if ( index !== null ) {

			renderer = indexedBufferRenderer;
			renderer.setIndex( index );

		} else {

			renderer = bufferRenderer;

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

			}

		}

		//

		var dataStart = 0;
		var dataCount = Infinity;

		if ( index !== null ) {

			dataCount = index.count

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start;
		var rangeCount = geometry.drawRange.count;

		var groupStart = group !== null ? group.start : 0;
		var groupCount = group !== null ? group.count : Infinity;

		var drawStart = Math.max( dataStart, rangeStart, groupStart );
		var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		//

		if ( object instanceof THREE.Mesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * pixelRatio );
				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry );

			} else {

				renderer.render( drawStart, drawCount );

			}

		} else if ( object instanceof THREE.Line ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * pixelRatio );

			if ( object instanceof THREE.LineSegments ) {

				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

			renderer.render( drawStart, drawCount );

		} else if ( object instanceof THREE.Points ) {

			renderer.setMode( _gl.POINTS );
			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var extension;

		if ( geometry instanceof THREE.InstancedBufferGeometry ) {

			extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		if ( startIndex === undefined ) startIndex = 0;

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var size = geometryAttribute.itemSize;
					var buffer = objects.getAttributeBuffer( geometryAttribute );

					if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data instanceof THREE.InstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

					} else {

						if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Sorting

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	}

	function painterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var fog = scene.fog;

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;

		opaqueObjectsLastIndex = - 1;
		transparentObjectsLastIndex = - 1;

		sprites.length = 0;
		lensFlares.length = 0;

		projectObject( scene, camera );

		opaqueObjects.length = opaqueObjectsLastIndex + 1;
		transparentObjects.length = transparentObjectsLastIndex + 1;

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		//

		shadowMap.render( scene );

		//

		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		//

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
			renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			state.setBlending( THREE.NoBlending );
			renderObjects( opaqueObjects, camera, lights, fog );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, lights, fog );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget ) {

			var texture = renderTarget.texture;
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
			if ( texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				 updateRenderTargetMipmap( renderTarget );

			}

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.setDepthTest( true );
		state.setDepthWrite( true );
		state.setColorWrite( true );

		// _gl.finish();

	};

	function pushRenderItem( object, geometry, material, z, group ) {

		var array, index;

		// allocate the next position in the appropriate array

		if ( material.transparent ) {

			array = transparentObjects;
			index = ++ transparentObjectsLastIndex;

		} else {

			array = opaqueObjects;
			index = ++ opaqueObjectsLastIndex;

		}

		// recycle existing render item or grow the array

		var renderItem = array[ index ];

		if ( renderItem !== undefined ) {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.z = _vector3.z;
			renderItem.group = group;

		} else {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				z: _vector3.z,
				group: group
			};

			// assert( index === array.length );
			array.push( renderItem );

		}

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		if ( ( object.channels.mask & camera.channels.mask ) !== 0 ) {

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else if ( object instanceof THREE.ImmediateRenderObject ) {

				if ( _this.sortObjects === true ) {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyProjection( _projScreenMatrix );

				}

				pushRenderItem( object, null, object.material, _vector3.z, null );

			} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material instanceof THREE.MeshFaceMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

	function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object instanceof THREE.ImmediateRenderObject ) {

				setMaterial( material );

				var program = setProgram( camera, lights, fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			} else {

				_this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

			}

		}

	}

	function initMaterial( material, lights, fog, object ) {

		var materialProperties = properties.get( material );

		var parameters = programCache.getParameters( material, lights, fog, object );
		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = THREE.ShaderLib[ parameters.shaderID ];

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.__webglShader = materialProperties.__webglShader;

			program = programCache.acquireProgram( material, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var attributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		materialProperties.uniformsList = [];

		var uniformLocations = materialProperties.program.getUniforms();

		for ( var u in materialProperties.__webglShader.uniforms ) {

			var location = uniformLocations[ u ];

			if ( location ) {

				materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

			}

		}

	}

	function setMaterial( material ) {

		setMaterialFaces( material );

		if ( material.transparent === true ) {

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

		} else {

			state.setBlending( THREE.NoBlending );

		}

		state.setDepthFunc( material.depthFunc );
		state.setDepthTest( material.depthTest );
		state.setDepthWrite( material.depthWrite );
		state.setColorWrite( material.colorWrite );
		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	function setMaterialFaces( material ) {

		material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
		state.setFlipSided( material.side === THREE.BackSide );

	}

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );

		if ( material.needsUpdate || ! materialProperties.program ) {

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === - 1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( capabilities.logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) _currentCamera = camera;

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== undefined ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

			}

			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

			}

			if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== undefined ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.skeleton.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== undefined ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== undefined ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

				}

			} else if ( object.skeleton && object.skeleton.boneMatrices ) {

				if ( p_uniforms.boneGlobalMatrices !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights, camera );
					_lightsNeedUpdate = false;

				}

				if ( refreshLights ) {

					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );

				} else {

					markUniformsLightsNeedsUpdate( m_uniforms, false );

				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.PointsMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights, camera );

			}

			// load common uniforms

			loadUniformsGeneric( materialProperties.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== undefined ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		uniforms.diffuse.value = material.color;

		if ( material.emissive ) {

			uniforms.emissive.value = material.emissive;

		}

		uniforms.map.value = material.map;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) uvScaleMap = uvScaleMap.texture;
			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

		uniforms.reflectivity.value = material.reflectivity;
		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			var offset = material.map.offset;
			var repeat = material.map.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;
		uniforms.pointLightDecay.value = lights.point.decays;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;
		uniforms.spotLightDecay.value = lights.spot.decays;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLightColor.needsUpdate = value;
		uniforms.directionalLightDirection.needsUpdate = value;

		uniforms.pointLightColor.needsUpdate = value;
		uniforms.pointLightPosition.needsUpdate = value;
		uniforms.pointLightDistance.needsUpdate = value;
		uniforms.pointLightDecay.needsUpdate = value;

		uniforms.spotLightColor.needsUpdate = value;
		uniforms.spotLightPosition.needsUpdate = value;
		uniforms.spotLightDistance.needsUpdate = value;
		uniforms.spotLightDirection.needsUpdate = value;
		uniforms.spotLightAngleCos.needsUpdate = value;
		uniforms.spotLightExponent.needsUpdate = value;
		uniforms.spotLightDecay.needsUpdate = value;

		uniforms.hemisphereLightSkyColor.needsUpdate = value;
		uniforms.hemisphereLightGroundColor.needsUpdate = value;
		uniforms.hemisphereLightDirection.needsUpdate = value;

	}

	function refreshUniformsShadow ( uniforms, lights, camera ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( light.castShadow === true ) {

					if ( light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) {

						var shadow = light.shadow;

						if ( light instanceof THREE.PointLight ) {

							// for point lights we set the shadow matrix to be a translation-only matrix
							// equal to inverse of the light's position
							_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
							shadow.matrix.identity().setPosition( _vector3 );

							// for point lights we set the sign of the shadowDarkness uniform to be negative
							uniforms.shadowDarkness.value[ j ] = - shadow.darkness;

						} else {

							uniforms.shadowDarkness.value[ j ] = shadow.darkness;

						}

						uniforms.shadowMatrix.value[ j ] = shadow.matrix;
						uniforms.shadowMap.value[ j ] = shadow.map;
						uniforms.shadowMapSize.value[ j ] = shadow.mapSize;
						uniforms.shadowBias.value[ j ] = shadow.bias;

						j ++;

					}

				}

			}

		}

	}

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

		}

	}

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

						uniform._array[ i2 + 0 ] = value[ i ].x;
						uniform._array[ i2 + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

						uniform._array[ i3 + 0 ] = value[ i ].x;
						uniform._array[ i3 + 1 ] = value[ i ].y;
						uniform._array[ i3 + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

						uniform._array[ i4 + 0 ] = value[ i ].x;
						uniform._array[ i4 + 1 ] = value[ i ].y;
						uniform._array[ i4 + 2 ] = value[ i ].z;
						uniform._array[ i4 + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
						 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

						// CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture.texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTarget ) {

						_this.setTexture( texture.texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d or cube)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
							 ( texture.image instanceof Array && texture.image.length === 6 ) ) {

							// CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTarget ) {

							_this.setTexture( texture.texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture.texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	}

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset + 0 ] = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	function setupLights ( lights, camera ) {

		var l, ll, light,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,
		distance,

		zlights = _lights,

		viewMatrix = camera.matrixWorldInverse,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,
		pointDecays = zlights.point.decays,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,
		spotDecays = zlights.spot.decays,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				r += color.r;
				g += color.g;
				b += color.b;

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.transformDirection( viewMatrix );

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset + 0 ] = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				setColorLinear( dirColors, dirOffset, color, intensity );

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				setColorLinear( pointColors, pointOffset, color, intensity );

				_vector3.setFromMatrixPosition( light.matrixWorld );
				_vector3.applyMatrix4( viewMatrix );

				pointPositions[ pointOffset + 0 ] = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				// distance is 0 if decay is 0, because there is no attenuation at all.
				pointDistances[ pointLength ] = distance;
				pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				setColorLinear( spotColors, spotOffset, color, intensity );

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.copy( _direction ).applyMatrix4( viewMatrix );

				spotPositions[ spotOffset + 0 ] = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.transformDirection( viewMatrix );

				spotDirections[ spotOffset + 0 ] = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;
				spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.transformDirection( viewMatrix );

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset + 0 ] = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
				setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			state.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			state.enable( _gl.CULL_FACE );

		}

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		var extension;

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false ) {

			texture.image = makePowerOfTwo( texture.image );

		}

		var image = texture.image,
		isImagePowerOfTwo = isPowerOfTwo( image ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

			}

		}

		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	this.setTexture = function ( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
				return;

			}

			if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
				return;

			}

			uploadTexture( textureProperties, texture, slot );

			return;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElement( 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
		if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;

		return false;

	}

	function makePowerOfTwo( image ) {

		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

			var canvas = document.createElement( 'canvas' );
			canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
			canvas.height = THREE.Math.nearestPowerOfTwo( image.height );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function setCubeTexture ( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );

	}

	function setupRenderBuffer ( renderbuffer, renderTarget ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget ),
				glFormat = paramThreeToGL( renderTarget.texture.format ),
				glType = paramThreeToGL( renderTarget.texture.type );

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];
				renderTargetProperties.__webglRenderbuffer = [];

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
					state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

				}

				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( isCube ) {

				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTargetProperties.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;

				if ( texture.format !== THREE.RGBAFormat
					&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( texture.type !== THREE.UnsignedByteType
					&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
					&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
					&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	function updateRenderTargetMipmap( renderTarget ) {

		var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
		var texture = properties.get( renderTarget.texture ).__webglTexture;

		state.bindTexture( target, texture );
		_gl.generateMipmap( target );
		state.bindTexture( target, null );

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		extension = extensions.get( 'OES_texture_half_float' );

		if ( extension !== null ) {

			if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

		}

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

	// DEPRECATED

	this.supportsFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return extensions.get( 'OES_texture_float' );

	};

	this.supportsHalfFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return extensions.get( 'OES_texture_half_float' );

	};

	this.supportsStandardDerivatives = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return extensions.get( 'OES_standard_derivatives' );

	};

	this.supportsCompressedTextureS3TC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	this.supportsCompressedTexturePVRTC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	this.supportsBlendMinMax = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return extensions.get( 'EXT_blend_minmax' );

	};

	this.supportsVertexTextures = function () {

		return capabilities.vertexTextures;

	};

	this.supportsInstancedArrays = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return extensions.get( 'ANGLE_instanced_arrays' );

	};

	//

	this.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	this.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	this.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	this.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

	Object.defineProperties( this, {
		shadowMapEnabled: {
			get: function () {

				return shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				return shadowMap.cullFace;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
				shadowMap.cullFace = value;

			}
		},
		shadowMapDebug: {
			get: function () {

				return shadowMap.debug;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
				shadowMap.debug = value;

			}
		}
	} );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.uuid = THREE.Math.generateUUID();

	this.width = width;
	this.height = height;

	options = options || {};

	if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;

	this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	get wrapS() {

		console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

		return this.texture.wrapS;

	},

	set wrapS( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

		this.texture.wrapS = value;

	},

	get wrapT() {

		console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

		return this.texture.wrapT;

	},

	set wrapT( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

		this.texture.wrapT = value;

	},

	get magFilter() {

		console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

		return this.texture.magFilter;

	},

	set magFilter( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

		this.texture.magFilter = value;

	},

	get minFilter() {

		console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

		return this.texture.minFilter;

	},

	set minFilter( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

		this.texture.minFilter = value;

	},

	get anisotropy() {

		console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

		return this.texture.anisotropy;

	},

	set anisotropy( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

		this.texture.anisotropy = value;

	},

	get offset() {

		console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

		return this.texture.offset;

	},

	set offset( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

		this.texture.offset = value;

	},

	get repeat() {

		console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

		return this.texture.repeat;

	},

	set repeat( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

		this.texture.repeat = value;

	},

	get format() {

		console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

		return this.texture.format;

	},

	set format( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

		this.texture.format = value;

	},

	get type() {

		console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

		return this.texture.type;

	},

	set type( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

		this.texture.type = value;

	},

	get generateMipmaps() {

		console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

		return this.texture.generateMipmaps;

	},

	set generateMipmaps( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

		this.texture.generateMipmaps = value;

	},

	//

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		this.shareDepthFrom = source.shareDepthFrom;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		_gl.drawArrays( mode, start, count );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var position = geometry.attributes.position;

		if ( position instanceof THREE.InterleavedBufferAttribute ) {

			extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

		} else {

			extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

		}

	}

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, size;

	function setIndex( index ) {

		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

			type = _gl.UNSIGNED_INT;
			size = 4;

		} else {

			type = _gl.UNSIGNED_SHORT;
			size = 2;

		}

	}

	function render( start, count ) {

		_gl.drawElements( mode, count, type, start * size );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var index = geometry.index;

		extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

	}

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		if ( extension === null ) {

			console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	this.getMaxPrecision = getMaxPrecision;

	this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
	this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

	this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	this.vertexTextures = this.maxVertexTextures > 0;
	this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

	var _maxPrecision = getMaxPrecision( this.precision );

	if ( _maxPrecision !== this.precision ) {

		console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
		this.precision = _maxPrecision;

	}

	if ( this.logarithmicDepthBuffer ) {

		this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

	}

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLGeometries = function ( gl, properties, info ) {

	var geometries = {};

	function get( object ) {

		var geometry = object.geometry;

		if ( geometries[ geometry.id ] !== undefined ) {

			return geometries[ geometry.id ];

		}

		geometry.addEventListener( 'dispose', onGeometryDispose );

		var buffergeometry;

		if ( geometry instanceof THREE.BufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry instanceof THREE.Geometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries[ geometry.id ] = buffergeometry;

		info.memory.geometries ++;

		return buffergeometry;

	}

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		deleteAttributes( buffergeometry.attributes );

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		var property = properties.get( geometry );
		if ( property.wireframe ) deleteAttribute( property.wireframe );

		info.memory.geometries --;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function deleteAttribute( attribute ) {

		var buffer = getAttributeBuffer( attribute );

		if ( buffer !== undefined ) {

			gl.deleteBuffer( buffer );
			removeAttributeBuffer( attribute );

		}

	}

	function deleteAttributes( attributes ) {

		for ( var name in attributes ) {

			deleteAttribute( attributes[ name ] );

		}

	}

	function removeAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			properties.delete( attribute.data );

		} else {

			properties.delete( attribute );

		}

	}

	this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLObjects = function ( gl, properties, info ) {

	var geometries = new THREE.WebGLGeometries( gl, properties, info );

	//

	function update( object ) {

		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

		var geometry = geometries.get( object );

		if ( object.geometry instanceof THREE.Geometry ) {

			geometry.updateFromObject( object );

		}

		var index = geometry.index;
		var attributes = geometry.attributes;

		if ( index !== null ) {

			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in attributes ) {

			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

			}

		}

		return geometry;

	}

	function updateAttribute( attribute, bufferType ) {

		var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

		var attributeProperties = properties.get( data );

		if ( attributeProperties.__webglBuffer === undefined ) {

			createBuffer( attributeProperties, data, bufferType );

		} else if ( attributeProperties.version !== data.version ) {

			updateBuffer( attributeProperties, data, bufferType );

		}

	}

	function createBuffer( attributeProperties, data, bufferType ) {

		attributeProperties.__webglBuffer = gl.createBuffer();
		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		gl.bufferData( bufferType, data.array, usage );

		attributeProperties.version = data.version;

	}

	function updateBuffer( attributeProperties, data, bufferType ) {

		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, data.array );

		} else if ( data.updateRange.count === 0 ) {

			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

			data.updateRange.count = 0; // reset range

		}

		attributeProperties.version = data.version;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function getWireframeAttribute( geometry ) {

		var property = properties.get( geometry );

		if ( property.wireframe !== undefined ) {

			return property.wireframe;

		}

		var indices = [];

		var index = geometry.index;
		var attributes = geometry.attributes;
		var position = attributes.position;

		// console.time( 'wireframe' );

		if ( index !== null ) {

			var edges = {};
			var array = index.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				if ( checkEdge( edges, a, b ) ) indices.push( a, b );
				if ( checkEdge( edges, b, c ) ) indices.push( b, c );
				if ( checkEdge( edges, c, a ) ) indices.push( c, a );

			}

		} else {

			var array = attributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
		var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

		property.wireframe = attribute;

		return attribute;

	}

	function checkEdge( edges, a, b ) {

		if ( a > b ) {

			var tmp = a;
			a = b;
			b = tmp;

		}

		var list = edges[ a ];

		if ( list === undefined ) {

			edges[ a ] = [ b ];
			return true;

		} else if ( list.indexOf( b ) === -1 ) {

			list.push( b );
			return true;

		}

		return false;

	}

	this.getAttributeBuffer = getAttributeBuffer;
	this.getWireframeAttribute = getWireframeAttribute;

	this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

	var programIdCount = 0;

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchUniformLocations( gl, program, identifiers ) {

		var uniforms = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveUniform( program, i );
			var name = info.name;
			var location = gl.getUniformLocation( program, name );

			// console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

			var suffixPos = name.lastIndexOf( '[0]' );
			if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

				uniforms[ name.substr( 0, suffixPos ) ] = location;

			}

			uniforms[ name ] = location;

		}

		return uniforms;

	}

	function fetchAttributeLocations( gl, program, identifiers ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	return function WebGLProgram( renderer, code, material, parameters ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case THREE.CubeReflectionMapping:
				case THREE.CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case THREE.EquirectangularReflectionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case THREE.SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case THREE.CubeRefractionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case THREE.MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case THREE.MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case THREE.AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefixVertex = '';
			prefixFragment = '';

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				renderer.gammaInput ? '#define GAMMA_INPUT' : '',
				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

				'#define MAX_SHADOWS ' + parameters.maxShadows,

				'#define MAX_BONES ' + parameters.maxBones,

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
				parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

				'#define MAX_SHADOWS ' + parameters.maxShadows,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

				renderer.gammaInput ? '#define GAMMA_INPUT' : '',
				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.metal ? '#define METAL' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
				parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program );
		var vertexLog = gl.getShaderInfoLog( glVertexShader );
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

		var runnable = true;
		var haveDiagnostics = true;

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function() {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = fetchUniformLocations( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function() {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function() {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function() {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function() {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function ( renderer, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
		"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
		"maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows",
		"shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
		"flipSided"
	];


	function allocateBones ( object ) {

		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

	}

	function allocateShadows( lights ) {

		var maxShadows = 0;
		var pointLightShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) maxShadows ++;
			if ( light instanceof THREE.PointLight ) {

				maxShadows ++;
				pointLightShadows ++;

			}

		}

		return { 'maxShadows': maxShadows, 'pointLightShadows': pointLightShadows };

	}

	this.getParameters = function ( material, lights, fog, object ) {

		var shaderID = shaderIDs[ material.type ];
		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxLightCount = allocateLights( lights );
		var allocatedShadows = allocateShadows( lights );
		var maxBones = allocateBones( object );
		var precision = renderer.getPrecision();

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,

			map: !! material.map,
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			flatShading: material.shading === THREE.FlatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: allocatedShadows.maxShadows,
			pointLightShadows: allocatedShadows.pointLightShadows,
			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
			shadowMapType: renderer.shadowMap.type,
			shadowMapDebug: renderer.shadowMap.debug,

			alphaTest: material.alphaTest,
			metal: material.metal,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var chunks = [];

		if ( parameters.shaderID ) {

			chunks.push( parameters.shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				chunks.push( name );
				chunks.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			var parameterName = parameterNames[ i ];
			chunks.push( parameterName );
			chunks.push( parameters[ parameterName ] );

		}

		return chunks.join();

	};

	this.acquireProgram = function ( material, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new THREE.WebGLProgram( renderer, code, material, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
* @author fordacious / fordacious.github.io
*/

THREE.WebGLProperties = function () {

	var properties = {};

	this.get = function ( object ) {

		var uuid = object.uuid;
		var map = properties[ uuid ];

		if ( map === undefined ) {

			map = {};
			properties[ uuid ] = map;

		}

		return map;

	};

	this.delete = function ( object ) {

		delete properties[ object.uuid ];

	};

	this.clear = function () {

		properties = {};

	};

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	return function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

	var _gl = _renderer.context,
	_state = _renderer.state,
	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_lookTarget = new THREE.Vector3(),
	_lightPositionWorld = new THREE.Vector3(),

	_renderList = [],

	_MorphingFlag = 1,
	_SkinningFlag = 2,

	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

	_depthMaterials = new Array( _NumberOfMaterialVariants ),
	_distanceMaterials = new Array( _NumberOfMaterialVariants );

	var cubeDirections = [
		new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
		new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
	];

	var _vector4 = new THREE.Vector4();

	// init

	var depthShader = THREE.ShaderLib[ "depthRGBA" ];
	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

	var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
	var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning
		} );

		depthMaterial._shadowPass = true;

		_depthMaterials[ i ] = depthMaterial;

		var distanceMaterial = new THREE.ShaderMaterial( {
			uniforms: distanceUniforms,
			vertexShader: distanceShader.vertexShader,
			fragmentShader: distanceShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning
		} );

		distanceMaterial._shadowPass = true;

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = THREE.PCFShadowMap;
	this.cullFace = THREE.CullFaceFront;

	this.render = function ( scene ) {

		var faceCount, isPointLight;

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		// Set GL state for depth map.
		_gl.clearColor( 1, 1, 1, 1 );
		_state.disable( _gl.BLEND );
		_state.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );
		_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
		_state.setDepthTest( true );

		// save the existing viewport so it can be restored later
		_renderer.getViewport( _vector4 );

		// render depth map

		for ( var i = 0, il = _lights.length; i < il; i ++ ) {

			var light = _lights[ i ];

			if ( light.castShadow === true ) {

				var shadow = light.shadow;
				var shadowCamera = shadow.camera;
				var shadowMapSize = shadow.mapSize;

				if ( light instanceof THREE.PointLight ) {

					faceCount = 6;
					isPointLight = true;

					var vpWidth = shadowMapSize.x / 4.0;
					var vpHeight = shadowMapSize.y / 2.0;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				} else {

					faceCount = 1;
					isPointLight = false;

				}

				if ( shadow.map === null ) {

					var shadowFilter = THREE.LinearFilter;

					if ( scope.type === THREE.PCFSoftShadowMap ) {

						shadowFilter = THREE.NearestFilter;

					}

					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

					shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
					shadow.matrix = new THREE.Matrix4();

					//

					if ( light instanceof THREE.SpotLight ) {

						shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;

					}

					shadowCamera.updateProjectionMatrix();

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						var vpDimensions = cube2DViewPorts[ face ];
						_renderer.setViewport( vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w );

					} else {

						_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
						shadowCamera.lookAt( _lookTarget );

					}

					shadowCamera.updateMatrixWorld();
					shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					_renderList.length = 0;

					projectObject( scene, shadowCamera );

					// render shadow map
					// render regular objects

					for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

						var object = _renderList[ j ];
						var geometry = _objects.update( object );
						var material = object.material;

						if ( material instanceof THREE.MeshFaceMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

								var group = groups[ k ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
									_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, group );

								}

							}

						} else {

							var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
							_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, null );

						}

					}

				}

				// We must call _renderer.resetGLState() at the end of each iteration of
				// the light loop in order to force material updates for each light.
				_renderer.resetGLState();

			}

		}

		_renderer.setViewport( _vector4.x, _vector4.y, _vector4.z, _vector4.w );

		// Restore GL state.
		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();
		_renderer.setClearColor( clearColor, clearAlpha );
		_state.enable( _gl.BLEND );

		if ( scope.cullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.resetGLState();

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

		var geometry = object.geometry;

		var newMaterial = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = geometry.morphTargets !== undefined &&
					geometry.morphTargets.length > 0 && material.morphTargets;

			var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;

			newMaterial = materialVariants[ variantIndex ];

		} else {

			newMaterial = customMaterial;

		}

		newMaterial.visible = material.visible;
		newMaterial.wireframe = material.wireframe;
		newMaterial.wireframeLinewidth = material.wireframeLinewidth;

		if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {

			newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );

		}

		return newMaterial;

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

				var material = object.material;

				if ( material.visible === true ) {

					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( object );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

	var _this = this;

	var newAttributes = new Uint8Array( 16 );
	var enabledAttributes = new Uint8Array( 16 );
	var attributeDivisors = new Uint8Array( 16 );

	var capabilities = {};

	var compressedTextureFormats = null;

	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;

	var currentDepthFunc = null;
	var currentDepthWrite = null;

	var currentColorWrite = null;

	var currentFlipSided = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

	var currentTextureSlot = undefined;
	var currentBoundTextures = {};

	this.init = function () {

		gl.clearColor( 0, 0, 0, 1 );
		gl.clearDepth( 1 );
		gl.clearStencil( 0 );

		this.enable( gl.DEPTH_TEST );
		gl.depthFunc( gl.LEQUAL );

		gl.frontFace( gl.CCW );
		gl.cullFace( gl.BACK );
		this.enable( gl.CULL_FACE );

		this.enable( gl.BLEND );
		gl.blendEquation( gl.FUNC_ADD );
		gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

	};

	this.initAttributes = function () {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	};

	this.enableAttribute = function ( attribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== 0 ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;

		}

	};

	this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	};

	this.disableUnusedAttributes = function () {

		for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	};

	this.enable = function ( id ) {

		if ( capabilities[ id ] !== true ) {

			gl.enable( id );
			capabilities[ id ] = true;

		}

	};

	this.disable = function ( id ) {

		if ( capabilities[ id ] !== false ) {

			gl.disable( id );
			capabilities[ id ] = false;

		}

	};

	this.getCompressedTextureFormats = function () {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

		if ( blending !== currentBlending ) {

			if ( blending === THREE.NoBlending ) {

				this.disable( gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				this.enable( gl.BLEND );

			} else {

				this.enable( gl.BLEND );
				gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
				gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

			}

			currentBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

		} else {

			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;

		}

	};

	this.setDepthFunc = function ( depthFunc ) {

		if ( currentDepthFunc !== depthFunc ) {

			if ( depthFunc ) {

				switch ( depthFunc ) {

					case THREE.NeverDepth:

						gl.depthFunc( gl.NEVER );
						break;

					case THREE.AlwaysDepth:

						gl.depthFunc( gl.ALWAYS );
						break;

					case THREE.LessDepth:

						gl.depthFunc( gl.LESS );
						break;

					case THREE.LessEqualDepth:

						gl.depthFunc( gl.LEQUAL );
						break;

					case THREE.EqualDepth:

						gl.depthFunc( gl.EQUAL );
						break;

					case THREE.GreaterEqualDepth:

						gl.depthFunc( gl.GEQUAL );
						break;

					case THREE.GreaterDepth:

						gl.depthFunc( gl.GREATER );
						break;

					case THREE.NotEqualDepth:

						gl.depthFunc( gl.NOTEQUAL );
						break;

					default:

						gl.depthFunc( gl.LEQUAL );

				}

			} else {

				gl.depthFunc( gl.LEQUAL );

			}

			currentDepthFunc = depthFunc;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( depthTest ) {

			this.enable( gl.DEPTH_TEST );

		} else {

			this.disable( gl.DEPTH_TEST );

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( currentDepthWrite !== depthWrite ) {

			gl.depthMask( depthWrite );
			currentDepthWrite = depthWrite;

		}

	};

	this.setColorWrite = function ( colorWrite ) {

		if ( currentColorWrite !== colorWrite ) {

			gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
			currentColorWrite = colorWrite;

		}

	};

	this.setFlipSided = function ( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	};

	this.setLineWidth = function ( width ) {

		if ( width !== currentLineWidth ) {

			gl.lineWidth( width );

			currentLineWidth = width;

		}

	};

	this.setPolygonOffset = function ( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			this.enable( gl.POLYGON_OFFSET_FILL );

		} else {

			this.disable( gl.POLYGON_OFFSET_FILL );

		}

		if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

			gl.polygonOffset( factor, units );

			currentPolygonOffsetFactor = factor;
			currentPolygonOffsetUnits = units;

		}

	};

	this.setScissorTest = function ( scissorTest ) {

		if ( scissorTest ) {

			this.enable( gl.SCISSOR_TEST );

		} else {

			this.disable( gl.SCISSOR_TEST );

		}

	};

	// texture

	this.activeTexture = function ( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	this.bindTexture = function ( webglType, webglTexture ) {

		if ( currentTextureSlot === undefined ) {

			_this.activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	};

	this.compressedTexImage2D = function () {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	this.texImage2D = function () {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	//

	this.reset = function () {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		capabilities = {};

		compressedTextureFormats = null;

		currentBlending = null;

		currentDepthWrite = null;
		currentColorWrite = null;

		currentFlipSided = null;

	};

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;
	var hasVertexTexture;

	var tempTexture, occlusionTexture;

	function init() {

		var vertices = new Float32Array( [
			- 1, - 1,  0, 0,
			 1, - 1,  1, 0,
			 1,  1,  1, 1,
			- 1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

		var shader;

		if ( hasVertexTexture ) {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"uniform sampler2D occlusionMap;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if ( renderType == 2 ) {",

							"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

							"vVisibility =        visibility.r / 9.0;",
							"vVisibility *= 1.0 - visibility.g / 9.0;",
							"vVisibility *=       visibility.b / 9.0;",
							"vVisibility *= 1.0 - visibility.a / 9.0;",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						// pink square

						"if ( renderType == 0 ) {",

							"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

						// restore

						"} else if ( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * vVisibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		} else {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if ( renderType == 2 ) {",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"precision mediump float;",

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform sampler2D occlusionMap;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",

					"void main() {",

						// pink square

						"if ( renderType == 0 ) {",

							"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

						// restore

						"} else if ( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
							"visibility = ( 1.0 - visibility / 4.0 );",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * visibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		}

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		};

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	}

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/uniforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		state.disable( gl.CULL_FACE );
		gl.depthMask( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition );

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );

				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition );

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		gl.depthMask( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new THREE.Vector3();
	var spriteRotation = new THREE.Quaternion();
	var spriteScale = new THREE.Vector3();

	function init() {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new THREE.Texture( canvas );
		texture.needsUpdate = true;

	}

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				renderer.setTexture( material.map, 0 );

			} else {

				renderer.setTexture( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		state.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	}

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	}

};

// File:src/extras/CurveUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.CurveUtils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3  t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof THREE.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new THREE.TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new THREE.CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

	}

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Group();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/ShapeUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	triangulate: ( function () {

		/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */

		function snip( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

			}

			return true;

		}

		// takes in an contour array and returns

		return function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		}

	} )(),

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

			// inOtherPt needs to be collinear to the inSegment
			if ( inSegPt1.x !== inSegPt2.x ) {

				if ( inSegPt1.x < inSegPt2.x ) {

					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

				} else {

					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

				}

			} else {

				if ( inSegPt1.y < inSegPt2.y ) {

					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

				} else {

					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

				}

			}

		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs( limit ) > Number.EPSILON ) {

				// not parallel

				var perpSeg2;
				if ( limit > 0 ) {

					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

				} else {

					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 === 0 ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];

				}
				if ( perpSeg2 === limit ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];

				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {

				// parallel or collinear
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {

					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
					return [ inSeg1Pt1 ];                 						// they are the same point

				}
				// segment#1  is a single point
				if ( seg1Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return [ inSeg1Pt1 ];

				}
				// segment#2  is a single point
				if ( seg2Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return [ inSeg2Pt1 ];

				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {

					// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

					}

				} else {

					// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

					}

				}
				if ( seg1minVal <= seg2minVal ) {

					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];

				} else {

					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];

				}

			}

		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

			// The order of legs is important

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

				// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {

					// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

				} else {

					// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

				}

			} else {

				// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );

			}

		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;

				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;

				}

				return	true;

			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {

				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;

				}

				return	false;

			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {

				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

					chkHole = holes[ indepHoles[ ihIdx ]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

				}
				return	false;

			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {

				counter --;
				if ( counter < 0 ) {

					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;

				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {

						holeIdx = indepHoles[ h ];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;

						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice( h, 1 );

							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[ cutKey ] = true;			// remember failure

					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found

				}

			}

			return shape; 			/* shape with no holes */

		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[ h ] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.warn( "THREE.Shape: Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.ShapeUtils.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2: ( function () {

		function b2p0( t, p ) {

			var k = 1 - t;
			return k * k * p;

		}

		function b2p1( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		}

		function b2p2( t, p ) {

			return t * t * p;

		}

		return function ( t, p0, p1, p2 ) {

			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

		};

	} )(),

	// Cubic Bezier Functions

	b3: ( function () {

		function b3p0( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		}

		function b3p1( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		}

		function b3p2( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		}

		function b3p3( t, p ) {

			return t * t * t * p;

		}

		return function ( t, p0, p1, p2, p3 ) {

			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

		};

	} )()

};

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

	THREE.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();
	this.source.onended = this.onEnded.bind( this );

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

	this.autoplay = false;

	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

	var scope = this;

	var request = new XMLHttpRequest();
	request.open( 'GET', file, true );
	request.responseType = 'arraybuffer';
	request.onload = function ( e ) {

		scope.context.decodeAudioData( this.response, function ( buffer ) {

			scope.source.buffer = buffer;

			if ( scope.autoplay ) scope.play();

		} );

	};
	request.send();

	return this;

};

THREE.Audio.prototype.play = function () {

	if ( this.isPlaying === true ) {

		console.warn( 'THREE.Audio: Audio is already playing.' );
		return;

	}

	var source = this.context.createBufferSource();

	source.buffer = this.source.buffer;
	source.loop = this.source.loop;
	source.onended = this.source.onended;
	source.start( 0, this.startTime );
	source.playbackRate.value = this.playbackRate;

	this.isPlaying = true;

	this.source = source;

	this.connect();

};

THREE.Audio.prototype.pause = function () {

	this.source.stop();
	this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

	this.source.stop();
	this.startTime = 0;

};

THREE.Audio.prototype.connect = function () {

	if ( this.filter !== undefined ) {

		this.source.connect( this.filter );
		this.filter.connect( this.panner );

	} else {

		this.source.connect( this.panner );

	}

};

THREE.Audio.prototype.disconnect = function () {

	if ( this.filter !== undefined ) {

		this.source.disconnect( this.filter );
		this.filter.disconnect( this.panner );

	} else {

		this.source.disconnect( this.panner );

	}

};

THREE.Audio.prototype.setFilter = function ( value ) {

	if ( this.isPlaying === true ) {

		this.disconnect();
		this.filter = value;
		this.connect();

	} else {

		this.filter = value;

	}

};

THREE.Audio.prototype.getFilter = function () {

	return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function ( value ) {

	this.playbackRate = value;

	if ( this.isPlaying === true ) {

		this.source.playbackRate.value = this.playbackRate;

	}

};

THREE.Audio.prototype.getPlaybackRate = function () {

	return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

	this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

	this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function () {

	return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

	this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function () {

	return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

	this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function () {

	return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function ( value ) {

	this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function () {

	return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();

	return function updateMatrixWorld( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this.panner.setPosition( position.x, position.y, position.z );

	};

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

	THREE.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3();

	var orientation = new THREE.Vector3();

	return function updateMatrixWorld( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;
		var up = this.up;

		this.matrixWorld.decompose( position, quaternion, scale );

		orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		listener.setPosition( position.x, position.y, position.z );
		listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

	};

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

THREE.Curve.prototype = {

	constructor: THREE.Curve,

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( t ) {

		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	},

	updateArcLengths: function() {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	}

}

THREE.Curve.Utils = THREE.CurveUtils; // backwards compatibility

// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.constructor = constructor;
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];

	this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

/*
THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};
*/

THREE.CurvePath.prototype.closePath = function() {

	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[ 0 ].getPoint( 0 );
	var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

	if ( ! startPoint.equals( endPoint ) ) {

		this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

	}

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			var diff = curveLengths[ i ] - d;
			var curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};
*/

// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

		return this.cacheLengths;

	}

	// Get length of sub-curve
	// Push sums into cached array

	var lengths = [], sums = 0;

	for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0, l = points.length; i < l; i ++ ) {

		var point = points[ i ];
		geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );

	}

	return geometry;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call( this );

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var i = 1, l = vectors.length; i < l; i ++ ) {

		this.lineTo( vectors[ i ].x, vectors[ i ].y );

	}

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	this.actions.push( { action: 'moveTo', args: [ x, y ] } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: 'lineTo', args: [ x, y ] } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve(
		new THREE.Vector2( x0, y0 ),
		new THREE.Vector2( aCPx, aCPy ),
		new THREE.Vector2( aX, aY )
	);

	this.curves.push( curve );

	this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve(
		new THREE.Vector2( x0, y0 ),
		new THREE.Vector2( aCP1x, aCP1y ),
		new THREE.Vector2( aCP2x, aCP2y ),
		new THREE.Vector2( aX, aY )
	);

	this.curves.push( curve );

	this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: 'splineThru', args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc( aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	var args = [
		aX, aY,
		xRadius, yRadius,
		aStartAngle, aEndAngle,
		aClockwise,
		aRotation || 0 // aRotation is optional.
	];

	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	this.curves.push( curve );

	var lastPoint = curve.getPoint( 1 );
	args.push( lastPoint.x );
	args.push( lastPoint.y );

	this.actions.push( { action: 'ellipse', args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if ( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	divisions = divisions || 12;

	var b2 = THREE.ShapeUtils.b2;
	var b3 = THREE.ShapeUtils.b3;

	var points = [];

	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, tx, ty;

	for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

		var item = this.actions[ i ];

		var action = item.action;
		var args = item.args;

		switch ( action ) {

		case 'moveTo':

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case 'lineTo':

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case 'quadraticCurveTo':

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( var j = 1; j <= divisions; j ++ ) {

				var t = j / divisions;

				tx = b2( t, cpx0, cpx1, cpx );
				ty = b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case 'bezierCurveTo':

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( var j = 1; j <= divisions; j ++ ) {

				var t = j / divisions;

				tx = b3( t, cpx0, cpx1, cpx2, cpx );
				ty = b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case 'splineThru':

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( var j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) );

			}

			break;

		case 'arc':

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !! args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( var j = 1; j <= tdivisions; j ++ ) {

				var t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

			break;

		case 'ellipse':

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !! args[ 6 ],
				aRotation = args[ 7 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			var cos, sin;
			if ( aRotation !== 0 ) {

				cos = Math.cos( aRotation );
				sin = Math.sin( aRotation );

			}

			for ( var j = 1; j <= tdivisions; j ++ ) {

				var t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				if ( aRotation !== 0 ) {

					var x = tx, y = ty;

					// Rotate the point about the center of the ellipse.
					tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
					ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

				}

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

			break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1 ];
	if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
			 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
		points.splice( points.length - 1, 1 );
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

	function extractSubpaths( inActions ) {

		var subPaths = [], lastPath = new THREE.Path();

		for ( var i = 0, l = inActions.length; i < l; i ++ ) {

			var item = inActions[ i ];

			var args = item.args;
			var action = item.action;

			if ( action === 'moveTo' ) {

				if ( lastPath.actions.length !== 0 ) {

					subPaths.push( lastPath );
					lastPath = new THREE.Path();

				}

			}

			lastPath[ action ].apply( lastPath, args );

		}

		if ( lastPath.actions.length !== 0 ) {

			subPaths.push( lastPath );

		}

		// console.log(subPaths);

		return	subPaths;

	}

	function toShapesNoHoles( inSubpaths ) {

		var shapes = [];

		for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

			var tmpPath = inSubpaths[ i ];

			var tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;

			shapes.push( tmpShape );

		}

		//console.log("shape", shapes);

		return shapes;

	}

	function isPointInsidePolygon( inPt, inPolygon ) {

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs( edgeDy ) > Number.EPSILON ) {

				// not parallel
				if ( edgeDy < 0 ) {

					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y === edgeLowPt.y ) {

					if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!

				} else {

					var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
					if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = ! inside;		// true intersection left of inPt

				}

			} else {

				// parallel or collinear
				if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
				// edge lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;

			}

		}

		return	inside;

	}

	var isClockWise = THREE.ShapeUtils.isClockWise;

	var subPaths = extractSubpaths( this.actions );
	if ( subPaths.length === 0 ) return [];

	if ( noHoles === true )	return	toShapesNoHoles( subPaths );


	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length === 1 ) {

		tmpPath = subPaths[ 0 ];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? ! holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);

	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[ mainIdx ] = undefined;
	newShapeHoles[ mainIdx ] = [];

	for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = isClockWise( tmpPoints );
		solid = isCCW ? ! solid : solid;

		if ( solid ) {

			if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

			newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[ mainIdx ].s.actions = tmpPath.actions;
			newShapes[ mainIdx ].s.curves = tmpPath.curves;

			if ( holesFirst )	mainIdx ++;
			newShapeHoles[ mainIdx ] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

			//console.log('ccw', i);

		}

	}

	// only Holes? -> probably all Shapes with wrong orientation
	if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


	if ( newShapes.length > 1 ) {

		var ambiguous = false;
		var toChange = [];

		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

			betterShapeHoles[ sIdx ] = [];

		}

		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

			var sho = newShapeHoles[ sIdx ];

			for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

				var ho = sho[ hIdx ];
				var hole_unassigned = true;

				for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

					if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

						if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {

							hole_unassigned = false;
							betterShapeHoles[ s2Idx ].push( ho );

						} else {

							ambiguous = true;

						}

					}

				}
				if ( hole_unassigned ) {

					betterShapeHoles[ sIdx ].push( ho );

				}

			}

		}
		// console.log("ambiguous: ", ambiguous);
		if ( toChange.length > 0 ) {

			// console.log("to change: ", toChange);
			if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

		}

	}

	var tmpHoles;

	for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

		tmpShape = newShapes[ i ].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[ i ];

		for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

			tmpShape.holes.push( tmpHoles[ j ].h );

		}

	}

	//console.log("shape", shapes);

	return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );

	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	return new THREE.ExtrudeGeometry( this, options );

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	return new THREE.ShapeGeometry( this, options );

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var holesPts = [];

	for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getPoints( divisions );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	return this.extractAllPoints( divisions );

};

THREE.Shape.Utils = THREE.ShapeUtils; // backwards compatibility

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub( this.v1 );
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var b2 = THREE.ShapeUtils.b2;

	return new THREE.Vector2(
		b2( t, this.v0.x, this.v1.x, this.v2.x ),
		b2( t, this.v0.y, this.v1.y, this.v2.y )
	);

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

	return new THREE.Vector2(
		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
	).normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var b3 = THREE.ShapeUtils.b3;

	return new THREE.Vector2( 
		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	);

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

	return new THREE.Vector2( 
		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	).normalize();

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var point1 = points[ intPoint ];
	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	var interpolate = THREE.CurveUtils.interpolate;

	return new THREE.Vector2(
		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
	);

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;
	
	this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}
	
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x, ty = y;

		// Rotate the point about the center of the ellipse.
		x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
		y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

	}

	return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var b2 = THREE.ShapeUtils.b2;		

		return new THREE.Vector3(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y ),
			b2( t, this.v0.z, this.v1.z, this.v2.z )
		);

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var b3 = THREE.ShapeUtils.b3;

		return new THREE.Vector3(
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
		);

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */ ) {

		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

	var
		tmp = new THREE.Vector3(),
		px = new CubicPoly(),
		py = new CubicPoly(),
		pz = new CubicPoly();

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

	}

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

		this.c0 = x0;
		this.c1 = t0;
		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

	};

	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

		// compute tangents when parameterized in [t1,t2]
		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

		// rescale tangents for parametrization in [0,1]
		t1 *= dt1;
		t2 *= dt1;

		// initCubicPoly
		this.init( x1, x2, t1, t2 );

	};

	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

	};

	CubicPoly.prototype.calc = function( t ) {

		var t2 = t * t;
		var t3 = t2 * t;
		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

	};

	// Subclass Three.js curve
	return THREE.Curve.create(

		function ( p /* array of Vector3 */ ) {

			this.points = p || [];

		},

		function ( t ) {

			var points = this.points,
				point, intPoint, weight, l;

			l = points.length;

			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

			point = ( l - 1 ) * t;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p1, p2, p3;

			if ( intPoint === 0 ) {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			} else {

				p0 = points[ intPoint - 1 ];

			}

			p1 = points[ intPoint ];
			p2 = points[ intPoint + 1 ];

			if ( intPoint + 2 < l ) {

				p3 = points[ intPoint + 2 ]

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
				p3 = tmp;

			}

			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.type === 'catmullrom' ) {

				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

			}

			var v = new THREE.Vector3(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return v;

		}

	);

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		var point0 = points[ ( intPoint - 1 ) % points.length ];
		var point1 = points[ ( intPoint     ) % points.length ];
		var point2 = points[ ( intPoint + 1 ) % points.length ];
		var point3 = points[ ( intPoint + 2 ) % points.length ];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var scope = this;

	var width_half = width / 2;
	var height_half = height / 2;
	var depth_half = depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.BoxGeometry(
		parameters.width,
		parameters.height,
		parameters.depth,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.depthSegments
	);

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CircleGeometry(
		parameters.radius,
		parameters.segments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var vertices = segments + 2;

	var positions = new Float32Array( vertices * 3 );
	var normals = new Float32Array( vertices * 3 );
	var uvs = new Float32Array( vertices * 2 );

	// center data is already zero, but need to set a few extras
	normals[ 2 ] = 1.0;
	uvs[ 0 ] = 0.5;
	uvs[ 1 ] = 0.5;

	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

		var segment = thetaStart + s / segments * thetaLength;

		positions[ i ] = radius * Math.cos( segment );
		positions[ i + 1 ] = radius * Math.sin( segment );

		normals[ i + 2 ] = 1; // normal z

		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

	}

	var indices = [];

	for ( var i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CircleBufferGeometry(
		parameters.radius,
		parameters.segments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = radialSegments || 8;
	heightSegments = heightSegments || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ heightSegments ][ x + 1 ];
			var v2 = vertices[ heightSegments ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
			var uv2 = uvs[ heightSegments ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CylinderGeometry(
		parameters.radiusTop,
		parameters.radiusBottom,
		parameters.height,
		parameters.radialSegments,
		parameters.heightSegments,
		parameters.openEnded,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

	THREE.BufferGeometry.call( this );

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	var geometry2;

	if ( geometry instanceof THREE.BufferGeometry ) {

		geometry2 = new THREE.Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = [];

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

			var vertex = vertices[ h.vert1 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

			vertex = vertices[ h.vert2 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

		}

	}

	this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {

		shapes = [];
		return;

	}

	THREE.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {

		var shape = shapes[ s ];
		this.addShape( shape, options );

	}

};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initialization

	var ahole, h, hl; // looping of holes
	var scope = this;

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.ShapeUtils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;


	// Find directions for point movement


	function getBevelVec( inPt, inPrev, inNext ) {

		// computes for inPt the corresponding point inPt' on a new contour
		//   shifted by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.

		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

		// check for collinear edges
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

			// not collinear

			// length of vectors for normalizing

			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

			// shift adjacent points by unit vectors to the left

			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

			// scaling factor for v_prev to intersection point

			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			// vector from inPt to intersection point

			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {

				return	new THREE.Vector2( v_trans_x, v_trans_y );

			} else {

				shrink_by = Math.sqrt( v_trans_lensq / 2 );

			}

		} else {

			// handle special case of collinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > Number.EPSILON ) {

				if ( v_next_x > Number.EPSILON ) {

					direction_eq = true;

				}

			} else {

				if ( v_prev_x < - Number.EPSILON ) {

					if ( v_next_x < - Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

						direction_eq = true;

					}

				}

			}

			if ( direction_eq ) {

				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );

			} else {

				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );

			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {

		//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
		//bs = bevelSize * t; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}

		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( -- i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}

		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
		scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );

		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new THREE.Vector2( a.x, a.y ),
			new THREE.Vector2( b.x, b.y ),
			new THREE.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {

			return [
				new THREE.Vector2( a.x, 1 - a.z ),
				new THREE.Vector2( b.x, 1 - b.z ),
				new THREE.Vector2( c.x, 1 - c.z ),
				new THREE.Vector2( d.x, 1 - d.z )
			];

		} else {

			return [
				new THREE.Vector2( a.y, 1 - a.z ),
				new THREE.Vector2( b.y, 1 - b.z ),
				new THREE.Vector2( c.y, 1 - c.z ),
				new THREE.Vector2( d.y, 1 - d.z )
			];

		}

	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( THREE.ShapeUtils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

	// Vertices

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PlaneGeometry(
		parameters.width,
		parameters.height,
		parameters.widthSegments,
		parameters.heightSegments
	);

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2 ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PlaneBufferGeometry(
		parameters.width,
		parameters.height,
		parameters.widthSegments,
		parameters.heightSegments
	);

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i < phiSegments + 1; i ++ ) {

		// concentric circles inside ring

		for ( o = 0; o < thetaSegments + 1; o ++ ) {

			// number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) {

		// concentric circles inside ring

		var thetaSegment = i * ( thetaSegments + 1 );

		for ( o = 0; o < thetaSegments ; o ++ ) {

			// number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment;
			var v2 = segment + thetaSegments + 1;
			var v3 = segment + thetaSegments + 2;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

			v1 = segment;
			v2 = segment + thetaSegments + 2;
			v3 = segment + 1;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

		}

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.RingGeometry(
		parameters.innerRadius,
		parameters.outerRadius,
		parameters.thetaSegments,
		parameters.phiSegments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.SphereGeometry(
		parameters.radius,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.phiStart,
		parameters.phiLength,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = thetaStart + thetaLength;

	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

	var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	var index = 0, vertices = [], normal = new THREE.Vector3();

	for ( var y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];

		var v = y / heightSegments;

		for ( var x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;

			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			var py = radius * Math.cos( thetaStart + v * thetaLength );
			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			normal.set( px, py, pz ).normalize();

			positions.setXYZ( index, px, py, pz );
			normals.setXYZ( index, normal.x, normal.y, normal.z );
			uvs.setXY( index, u, 1 - v );

			verticesRow.push( index );

			index ++;

		}

		vertices.push( verticesRow );

	}

	var indices = [];

	for ( var y = 0; y < heightSegments; y ++ ) {

		for ( var x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

		}

	}

	this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
	this.addAttribute( 'position', positions );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.SphereBufferGeometry(
		parameters.radius,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.phiStart,
		parameters.phiLength,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 8;
	tubularSegments = tubularSegments || 6;
	arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= radialSegments; j ++ ) {

		for ( var i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}

	for ( var j = 1; j <= radialSegments; j ++ ) {

		for ( var i = 1; i <= tubularSegments; i ++ ) {

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TorusGeometry(
		parameters.radius,
		parameters.tube,
		parameters.radialSegments,
		parameters.tubularSegments,
		parameters.arc
	);

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		p: p,
		q: q,
		heightScale: heightScale
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 64;
	tubularSegments = tubularSegments || 8;
	p = p || 2;
	q = q || 3;
	heightScale = heightScale || 1;

	var grid = new Array( radialSegments );
	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < radialSegments; ++ i ) {

		grid[ i ] = new Array( tubularSegments );
		var u = i / radialSegments * 2 * p * Math.PI;
		var p1 = getPos( u, q, p, radius, heightScale );
		var p2 = getPos( u + 0.01, q, p, radius, heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var v = j / tubularSegments * 2 * Math.PI;
			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			grid[ i ][ j ] = this.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < radialSegments; ++ i ) {

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % radialSegments;
			var jp = ( j + 1 ) % tubularSegments;

			var a = grid[ i ][ j ];
			var b = grid[ ip ][ j ];
			var c = grid[ ip ][ jp ];
			var d = grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TorusKnotGeometry(
		parameters.radius,
		parameters.tube,
		parameters.radialSegments,
		parameters.tubularSegments,
		parameters.p,
		parameters.q,
		parameters.heightScale
	);

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

	THREE.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed,
		taper: taper
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;
	taper = taper || THREE.TubeGeometry.NoTaper;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		u, v, r,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	// construct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		r = radius * taper( u );

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = r * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}

	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
			jp = ( j + 1 ) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new THREE.Vector2( i / segments, j / radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
THREE.TubeGeometry.prototype.clone = function() {

	return new this.constructor( this.parameters.path,
		this.parameters.segments, this.parameters.radius, this.parameters.radialSegments,
		this.parameters.closed, this.parameters.taper
	);

};

THREE.TubeGeometry.NoTaper = function ( u ) {

	return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

	return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	normal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		smallest,

		tx, ty, tz,
		i, u;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {

			smallest = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= smallest ) {

			smallest = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= smallest ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i - 1 ].clone();

		binormals[ i ] = binormals[ i - 1 ].clone();

		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

		if ( vec.length() > Number.EPSILON ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	THREE.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

	}

	var centroid = new THREE.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, x1, x2 );
		var min = Math.min( x0, x1, x2 );

		if ( max > 0.9 && min < 0.1 ) {

			// 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3, materialIndex ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow( 2, detail );
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		var materialIndex = face.materialIndex;

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k ],
						v[ i ][ k ],
						materialIndex
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k + 1 ],
						v[ i + 1 ][ k ],
						materialIndex
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PolyhedronGeometry(
		parameters.vertices,
		parameters.indices,
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (1, 1, 1)
		- 1, - 1, - 1,    - 1, - 1,  1,
		- 1,  1, - 1,    - 1,  1,  1,
		 1, - 1, - 1,     1, - 1,  1,
		 1,  1, - 1,     1,  1,  1,

		// (0, 1/, )
		 0, - r, - t,     0, - r,  t,
		 0,  r, - t,     0,  r,  t,

		// (1/, , 0)
		- r, - t,  0,    - r,  t,  0,
		 r, - t,  0,     r,  t,  0,

		// (, 0, 1/)
		- t,  0, - r,     t,  0, - r,
		- t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.DodecahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.IcosahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.OctahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TetrahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, j, p;
	var u, v;

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}

	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = ( i + 1 ) * sliceCount + j + 1;
			d = ( i + 1 ) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

	THREE.BufferGeometry.call( this );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	if ( geometry instanceof THREE.Geometry ) {

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j ] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	} else if ( geometry instanceof THREE.BufferGeometry ) {

		if ( geometry.index !== null ) {

			// Indexed BufferGeometry

			var indices = geometry.index.array;
			var vertices = geometry.attributes.position;
			var drawcalls = geometry.drawcalls;
			var numEdges = 0;

			if ( drawcalls.length === 0 ) {

				geometry.addGroup( 0, indices.length );

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

				var drawcall = drawcalls[ o ];

				var start = drawcall.start;
				var count = drawcall.count;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = indices[ i + j ];
						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = edges[ 2 * i + j ];

					coords[ index + 0 ] = vertices.getX( index2 );
					coords[ index + 1 ] = vertices.getY( index2 );
					coords[ index + 2 ] = vertices.getZ( index2 );

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else {

			// non-indexed BufferGeometry

			var vertices = geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		}

	}

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.translate( 0, - 0.5, 0 );

	return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		THREE.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );
		
		if ( headLength < length ) {
			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
		}

		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new THREE.Vector3();
	var radians;

	return function setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	if ( headLength < length ){
		this.line.scale.set( 1, length - headLength, 1 );
		this.line.updateMatrix();
	}

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

	if ( this.line !== undefined ) this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new THREE.BufferGeometry();
	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function () {

	var box = new THREE.Box3();

	return function ( object ) {

		box.setFromObject( object );

		if ( box.empty() ) return;

		var min = box.min;
		var max = box.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	}

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.LineSegments.call( this, geometry, material );

	this.camera = camera;
	this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

	var geometry, pointMap;

	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();

	function setPoint( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	}

	return function () {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3( - size,   size, 0 ),
		new THREE.Vector3(   size,   size, 0 ),
		new THREE.Vector3(   size, - size, 0 ),
		new THREE.Vector3( - size, - size, 0 ),
		new THREE.Vector3( - size,   size, 0 )
	);

	var material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(),
		new THREE.Vector3()
	);

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	// FaceNormalsHelper only supports THREE.Geometry

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof THREE.Geometry ) {

		nNormals = objGeometry.faces.length;

	} else {

		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

	}

	//

	var geometry = new THREE.BufferGeometry();

	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;
	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var normalMatrix = new THREE.Matrix3();

	return function update() {

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		var vertices = objGeometry.vertices;

		var faces = objGeometry.faces;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var normal = face.normal;

			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );

			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

			position.setXYZ( idx, v1.x, v1.y, v1.z );

			idx = idx + 1;

			position.setXYZ( idx, v2.x, v2.y, v2.z );

			idx = idx + 1;

		}

		position.needsUpdate = true;

		return this;

	}

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.rotateX( - Math.PI / 2 );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {

	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

		}

	}

	geometry.dynamic = true;

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	THREE.LineSegments.call( this, geometry, material );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof THREE.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new THREE.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.translate( 0, - 0.5, 0 );
	geometry.rotateX( - Math.PI / 2 );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof THREE.Geometry ) {

		nNormals = objGeometry.faces.length * 3;

	} else if ( objGeometry instanceof THREE.BufferGeometry ) {

		nNormals = objGeometry.attributes.normal.count

	}

	//

	var geometry = new THREE.BufferGeometry();

	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var normalMatrix = new THREE.Matrix3();

	return function update() {

		var keys = [ 'a', 'b', 'c' ];

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertex = vertices[ face[ keys[ j ] ] ];

					var normal = face.vertexNormals[ j ];

					v1.copy( vertex ).applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

		} else if ( objGeometry instanceof THREE.BufferGeometry ) {

			var objPos = objGeometry.attributes.position;

			var objNorm = objGeometry.attributes.normal;

			var idx = 0;

			// for simplicity, ignore index and drawcalls, and render every normal

			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

		}

		position.needsUpdate = true;

		return this;

	}

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function ( material ) {

	THREE.Object3D.call( this );

	this.material = material;
	this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		start: start,
		end: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		if ( animation.currentFrame !== animation.lastFrame ) {

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		} else {

			this.morphTargetInfluences[ animation.currentFrame ] = weight;

		}

	}

};


// Export the THREE object for **Node.js**, with
// backwards-compatibility for the old `require()` API. If we're in
// the browser, add `_` as a global object via a string identifier,
// for Closure Compiler "advanced" mode.
if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9hcHAuanMiLCJqcy9saWIvT3JiaXRDb250cm9scy5qcyIsImpzL3NjZW5lM2QuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvdGhyZWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBOzs7Ozs7QUFFQSxJQUFJLGdCQUFKOztBQUVBLElBQU0sU0FBUyxTQUFULE1BQVMsR0FBTTtBQUNuQixNQUFNLFFBQVEsT0FBTyxVQUFyQjtBQUNBLE1BQU0sU0FBUyxPQUFPLFdBQXRCO0FBQ0EsVUFBUSxNQUFSLENBQWUsS0FBZixFQUFzQixNQUF0QjtBQUNELENBSkQ7O0FBTUEsT0FBTyxNQUFQLEdBQWdCLFlBQU07QUFDcEIsWUFBVSx3QkFBVjtBQUNBLFdBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsUUFBUSxVQUFsQztBQUNBO0FBQ0EsU0FBTyxRQUFQLEdBQWtCLE1BQWxCO0FBQ0QsQ0FMRDs7Ozs7QUNUQTs7Ozs7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBTSxhQUFOLEdBQXNCLFVBQVcsTUFBWCxFQUFtQixVQUFuQixFQUFnQzs7QUFFckQsTUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLE1BQUssVUFBTCxHQUFvQixlQUFlLFNBQWpCLEdBQStCLFVBQS9CLEdBQTRDLFFBQTlEO0FBQ0EsS0FBSSxhQUFhLEtBQUssVUFBdEI7O0FBRUE7O0FBRUE7QUFDQSxNQUFLLE9BQUwsR0FBZSxJQUFmOztBQUVBO0FBQ0E7QUFDQSxNQUFLLE1BQUwsR0FBYyxJQUFJLGdCQUFNLE9BQVYsRUFBZDs7QUFFQTtBQUNBLE1BQUssTUFBTCxHQUFjLEtBQUssTUFBbkI7O0FBRUE7QUFDQTtBQUNBLE1BQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxNQUFLLFNBQUwsR0FBaUIsR0FBakI7O0FBRUE7QUFDQSxNQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFDQSxNQUFLLFdBQUwsR0FBbUIsSUFBbkI7O0FBRUE7QUFDQSxNQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxNQUFLLFdBQUwsR0FBbUIsR0FBbkI7O0FBRUE7QUFDQSxNQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsTUFBSyxXQUFMLEdBQW1CLEdBQW5CLENBakNxRCxDQWlDN0I7O0FBRXhCO0FBQ0EsTUFBSyxVQUFMLEdBQWtCLEtBQWxCO0FBQ0EsTUFBSyxlQUFMLEdBQXVCLEdBQXZCLENBckNxRCxDQXFDekI7O0FBRTVCO0FBQ0E7QUFDQSxNQUFLLGFBQUwsR0FBcUIsQ0FBckIsQ0F6Q3FELENBeUM3QjtBQUN4QixNQUFLLGFBQUwsR0FBcUIsS0FBSyxFQUFMLEdBQVUsSUFBL0IsQ0ExQ3FELENBMENoQjs7QUFFckM7QUFDQTtBQUNBLE1BQUssZUFBTCxHQUF1QixDQUFFLFFBQXpCLENBOUNxRCxDQThDbEI7QUFDbkMsTUFBSyxlQUFMLEdBQXVCLFFBQXZCLENBL0NxRCxDQStDcEI7O0FBRWpDO0FBQ0EsTUFBSyxNQUFMLEdBQWMsS0FBZDs7QUFFQTtBQUNBLE1BQUssSUFBTCxHQUFZLEVBQUUsTUFBTSxFQUFSLEVBQVksSUFBSSxFQUFoQixFQUFvQixPQUFPLEVBQTNCLEVBQStCLFFBQVEsRUFBdkMsRUFBWjs7QUFFQTtBQUNBLE1BQUssWUFBTCxHQUFvQixFQUFFLE9BQU8sZ0JBQU0sS0FBTixDQUFZLElBQXJCLEVBQTJCLE1BQU0sZ0JBQU0sS0FBTixDQUFZLE1BQTdDLEVBQXFELEtBQUssZ0JBQU0sS0FBTixDQUFZLEtBQXRFLEVBQXBCOztBQUVBO0FBQ0E7O0FBRUEsS0FBSSxRQUFRLElBQVo7O0FBRUEsS0FBSSxNQUFNLFFBQVY7O0FBRUEsS0FBSSxjQUFjLElBQUksZ0JBQU0sT0FBVixFQUFsQjtBQUNBLEtBQUksWUFBWSxJQUFJLGdCQUFNLE9BQVYsRUFBaEI7QUFDQSxLQUFJLGNBQWMsSUFBSSxnQkFBTSxPQUFWLEVBQWxCOztBQUVBLEtBQUksV0FBVyxJQUFJLGdCQUFNLE9BQVYsRUFBZjtBQUNBLEtBQUksU0FBUyxJQUFJLGdCQUFNLE9BQVYsRUFBYjtBQUNBLEtBQUksV0FBVyxJQUFJLGdCQUFNLE9BQVYsRUFBZjtBQUNBLEtBQUksWUFBWSxJQUFJLGdCQUFNLE9BQVYsRUFBaEI7O0FBRUEsS0FBSSxTQUFTLElBQUksZ0JBQU0sT0FBVixFQUFiOztBQUVBLEtBQUksYUFBYSxJQUFJLGdCQUFNLE9BQVYsRUFBakI7QUFDQSxLQUFJLFdBQVcsSUFBSSxnQkFBTSxPQUFWLEVBQWY7QUFDQSxLQUFJLGFBQWEsSUFBSSxnQkFBTSxPQUFWLEVBQWpCOztBQUVBLEtBQUksS0FBSjtBQUNBLEtBQUksR0FBSjtBQUNBLEtBQUksV0FBVyxDQUFmO0FBQ0EsS0FBSSxhQUFhLENBQWpCO0FBQ0EsS0FBSSxRQUFRLENBQVo7QUFDQSxLQUFJLE1BQU0sSUFBSSxnQkFBTSxPQUFWLEVBQVY7O0FBRUEsS0FBSSxlQUFlLElBQUksZ0JBQU0sT0FBVixFQUFuQjtBQUNBLEtBQUksaUJBQWlCLElBQUksZ0JBQU0sVUFBVixFQUFyQjs7QUFFQSxLQUFJLFFBQVEsRUFBRSxNQUFPLENBQUMsQ0FBVixFQUFhLFFBQVMsQ0FBdEIsRUFBeUIsT0FBUSxDQUFqQyxFQUFvQyxLQUFNLENBQTFDLEVBQTZDLGNBQWUsQ0FBNUQsRUFBK0QsYUFBYyxDQUE3RSxFQUFnRixXQUFZLENBQTVGLEVBQVo7O0FBRUEsS0FBSSxRQUFRLE1BQU0sSUFBbEI7O0FBRUE7O0FBRUEsTUFBSyxPQUFMLEdBQWUsS0FBSyxNQUFMLENBQVksS0FBWixFQUFmO0FBQ0EsTUFBSyxTQUFMLEdBQWlCLEtBQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsS0FBckIsRUFBakI7O0FBRUE7O0FBRUEsS0FBSSxPQUFPLElBQUksZ0JBQU0sVUFBVixHQUF1QixrQkFBdkIsQ0FBMkMsT0FBTyxFQUFsRCxFQUFzRCxJQUFJLGdCQUFNLE9BQVYsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsQ0FBdEQsQ0FBWDtBQUNBLEtBQUksY0FBYyxLQUFLLEtBQUwsR0FBYSxPQUFiLEVBQWxCOztBQUVBOztBQUVBLEtBQUksY0FBYyxFQUFFLE1BQU0sUUFBUixFQUFsQjtBQUNBLEtBQUksYUFBYSxFQUFFLE1BQU0sT0FBUixFQUFqQjtBQUNBLEtBQUksV0FBVyxFQUFFLE1BQU0sS0FBUixFQUFmOztBQUVBLE1BQUssVUFBTCxHQUFrQixVQUFXLEtBQVgsRUFBbUI7O0FBRXBDLE1BQUssVUFBVSxTQUFmLEVBQTJCOztBQUUxQixXQUFRLHNCQUFSO0FBRUE7O0FBRUQsZ0JBQWMsS0FBZDtBQUVBLEVBVkQ7O0FBWUEsTUFBSyxRQUFMLEdBQWdCLFVBQVcsS0FBWCxFQUFtQjs7QUFFbEMsTUFBSyxVQUFVLFNBQWYsRUFBMkI7O0FBRTFCLFdBQVEsc0JBQVI7QUFFQTs7QUFFRCxjQUFZLEtBQVo7QUFFQSxFQVZEOztBQVlBO0FBQ0EsTUFBSyxPQUFMLEdBQWUsVUFBVyxRQUFYLEVBQXNCOztBQUVwQyxNQUFJLEtBQUssS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixRQUE1Qjs7QUFFQTtBQUNBLFlBQVUsR0FBVixDQUFlLEdBQUksQ0FBSixDQUFmLEVBQXdCLEdBQUksQ0FBSixDQUF4QixFQUFpQyxHQUFJLENBQUosQ0FBakM7QUFDQSxZQUFVLGNBQVYsQ0FBMEIsQ0FBRSxRQUE1Qjs7QUFFQSxNQUFJLEdBQUosQ0FBUyxTQUFUO0FBRUEsRUFWRDs7QUFZQTtBQUNBLE1BQUssS0FBTCxHQUFhLFVBQVcsUUFBWCxFQUFzQjs7QUFFbEMsTUFBSSxLQUFLLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsUUFBNUI7O0FBRUE7QUFDQSxZQUFVLEdBQVYsQ0FBZSxHQUFJLENBQUosQ0FBZixFQUF3QixHQUFJLENBQUosQ0FBeEIsRUFBaUMsR0FBSSxDQUFKLENBQWpDO0FBQ0EsWUFBVSxjQUFWLENBQTBCLFFBQTFCOztBQUVBLE1BQUksR0FBSixDQUFTLFNBQVQ7QUFFQSxFQVZEOztBQVlBO0FBQ0E7QUFDQSxNQUFLLEdBQUwsR0FBVyxVQUFXLE1BQVgsRUFBbUIsTUFBbkIsRUFBNEI7O0FBRXRDLE1BQUksVUFBVSxNQUFNLFVBQU4sS0FBcUIsUUFBckIsR0FBZ0MsTUFBTSxVQUFOLENBQWlCLElBQWpELEdBQXdELE1BQU0sVUFBNUU7O0FBRUEsTUFBSyxNQUFNLE1BQU4sQ0FBYSxHQUFiLEtBQXFCLFNBQTFCLEVBQXNDOztBQUVyQztBQUNBLE9BQUksV0FBVyxNQUFNLE1BQU4sQ0FBYSxRQUE1QjtBQUNBLE9BQUksU0FBUyxTQUFTLEtBQVQsR0FBaUIsR0FBakIsQ0FBc0IsTUFBTSxNQUE1QixDQUFiO0FBQ0EsT0FBSSxpQkFBaUIsT0FBTyxNQUFQLEVBQXJCOztBQUVBO0FBQ0EscUJBQWtCLEtBQUssR0FBTCxDQUFZLE1BQU0sTUFBTixDQUFhLEdBQWIsR0FBbUIsQ0FBckIsR0FBMkIsS0FBSyxFQUFoQyxHQUFxQyxLQUEvQyxDQUFsQjs7QUFFQTtBQUNBLFNBQU0sT0FBTixDQUFlLElBQUksTUFBSixHQUFhLGNBQWIsR0FBOEIsUUFBUSxZQUFyRDtBQUNBLFNBQU0sS0FBTixDQUFhLElBQUksTUFBSixHQUFhLGNBQWIsR0FBOEIsUUFBUSxZQUFuRDtBQUVBLEdBZEQsTUFjTyxJQUFLLE1BQU0sTUFBTixDQUFhLEdBQWIsS0FBcUIsU0FBMUIsRUFBc0M7O0FBRTVDO0FBQ0EsU0FBTSxPQUFOLENBQWUsVUFBVSxNQUFNLE1BQU4sQ0FBYSxLQUFiLEdBQXFCLE1BQU0sTUFBTixDQUFhLElBQTVDLElBQW9ELFFBQVEsV0FBM0U7QUFDQSxTQUFNLEtBQU4sQ0FBYSxVQUFVLE1BQU0sTUFBTixDQUFhLEdBQWIsR0FBbUIsTUFBTSxNQUFOLENBQWEsTUFBMUMsSUFBb0QsUUFBUSxZQUF6RTtBQUVBLEdBTk0sTUFNQTs7QUFFTjtBQUNBOztBQUVBO0FBRUQsRUEvQkQ7O0FBaUNBLE1BQUssT0FBTCxHQUFlLFVBQVcsVUFBWCxFQUF3Qjs7QUFFdEMsTUFBSyxlQUFlLFNBQXBCLEVBQWdDOztBQUUvQixnQkFBYSxjQUFiO0FBRUE7O0FBRUQsV0FBUyxVQUFUO0FBRUEsRUFWRDs7QUFZQSxNQUFLLFFBQUwsR0FBZ0IsVUFBVyxVQUFYLEVBQXdCOztBQUV2QyxNQUFLLGVBQWUsU0FBcEIsRUFBZ0M7O0FBRS9CLGdCQUFhLGNBQWI7QUFFQTs7QUFFRCxXQUFTLFVBQVQ7QUFFQSxFQVZEOztBQVlBLE1BQUssTUFBTCxHQUFjLFlBQVk7O0FBRXpCLE1BQUksV0FBVyxLQUFLLE1BQUwsQ0FBWSxRQUEzQjs7QUFFQSxTQUFPLElBQVAsQ0FBYSxRQUFiLEVBQXdCLEdBQXhCLENBQTZCLEtBQUssTUFBbEM7O0FBRUE7QUFDQSxTQUFPLGVBQVAsQ0FBd0IsSUFBeEI7O0FBRUE7O0FBRUEsVUFBUSxLQUFLLEtBQUwsQ0FBWSxPQUFPLENBQW5CLEVBQXNCLE9BQU8sQ0FBN0IsQ0FBUjs7QUFFQTs7QUFFQSxRQUFNLEtBQUssS0FBTCxDQUFZLEtBQUssSUFBTCxDQUFXLE9BQU8sQ0FBUCxHQUFXLE9BQU8sQ0FBbEIsR0FBc0IsT0FBTyxDQUFQLEdBQVcsT0FBTyxDQUFuRCxDQUFaLEVBQW9FLE9BQU8sQ0FBM0UsQ0FBTjs7QUFFQSxNQUFLLEtBQUssVUFBTCxJQUFtQixVQUFVLE1BQU0sSUFBeEMsRUFBK0M7O0FBRTlDLFFBQUssVUFBTCxDQUFpQixzQkFBakI7QUFFQTs7QUFFRCxXQUFTLFVBQVQ7QUFDQSxTQUFPLFFBQVA7O0FBRUE7QUFDQSxVQUFRLEtBQUssR0FBTCxDQUFVLEtBQUssZUFBZixFQUFnQyxLQUFLLEdBQUwsQ0FBVSxLQUFLLGVBQWYsRUFBZ0MsS0FBaEMsQ0FBaEMsQ0FBUjs7QUFFQTtBQUNBLFFBQU0sS0FBSyxHQUFMLENBQVUsS0FBSyxhQUFmLEVBQThCLEtBQUssR0FBTCxDQUFVLEtBQUssYUFBZixFQUE4QixHQUE5QixDQUE5QixDQUFOOztBQUVBO0FBQ0EsUUFBTSxLQUFLLEdBQUwsQ0FBVSxHQUFWLEVBQWUsS0FBSyxHQUFMLENBQVUsS0FBSyxFQUFMLEdBQVUsR0FBcEIsRUFBeUIsR0FBekIsQ0FBZixDQUFOOztBQUVBLE1BQUksU0FBUyxPQUFPLE1BQVAsS0FBa0IsS0FBL0I7O0FBRUE7QUFDQSxXQUFTLEtBQUssR0FBTCxDQUFVLEtBQUssV0FBZixFQUE0QixLQUFLLEdBQUwsQ0FBVSxLQUFLLFdBQWYsRUFBNEIsTUFBNUIsQ0FBNUIsQ0FBVDs7QUFFQTtBQUNBLE9BQUssTUFBTCxDQUFZLEdBQVosQ0FBaUIsR0FBakI7O0FBRUEsU0FBTyxDQUFQLEdBQVcsU0FBUyxLQUFLLEdBQUwsQ0FBVSxHQUFWLENBQVQsR0FBMkIsS0FBSyxHQUFMLENBQVUsS0FBVixDQUF0QztBQUNBLFNBQU8sQ0FBUCxHQUFXLFNBQVMsS0FBSyxHQUFMLENBQVUsR0FBVixDQUFwQjtBQUNBLFNBQU8sQ0FBUCxHQUFXLFNBQVMsS0FBSyxHQUFMLENBQVUsR0FBVixDQUFULEdBQTJCLEtBQUssR0FBTCxDQUFVLEtBQVYsQ0FBdEM7O0FBRUE7QUFDQSxTQUFPLGVBQVAsQ0FBd0IsV0FBeEI7O0FBRUEsV0FBUyxJQUFULENBQWUsS0FBSyxNQUFwQixFQUE2QixHQUE3QixDQUFrQyxNQUFsQzs7QUFFQSxPQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW9CLEtBQUssTUFBekI7O0FBRUEsZUFBYSxDQUFiO0FBQ0EsYUFBVyxDQUFYO0FBQ0EsVUFBUSxDQUFSO0FBQ0EsTUFBSSxHQUFKLENBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxDQUFmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLLGFBQWEsaUJBQWIsQ0FBZ0MsS0FBSyxNQUFMLENBQVksUUFBNUMsSUFBeUQsR0FBekQsSUFDRSxLQUFLLElBQUksZUFBZSxHQUFmLENBQW1CLEtBQUssTUFBTCxDQUFZLFVBQS9CLENBQVQsSUFBdUQsR0FEOUQsRUFDb0U7O0FBRW5FLFFBQUssYUFBTCxDQUFvQixXQUFwQjs7QUFFQSxnQkFBYSxJQUFiLENBQW1CLEtBQUssTUFBTCxDQUFZLFFBQS9CO0FBQ0Esa0JBQWUsSUFBZixDQUFxQixLQUFLLE1BQUwsQ0FBWSxVQUFqQztBQUVBO0FBRUQsRUF6RUQ7O0FBNEVBLE1BQUssS0FBTCxHQUFhLFlBQVk7O0FBRXhCLFVBQVEsTUFBTSxJQUFkOztBQUVBLE9BQUssTUFBTCxDQUFZLElBQVosQ0FBa0IsS0FBSyxPQUF2QjtBQUNBLE9BQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsSUFBckIsQ0FBMkIsS0FBSyxTQUFoQzs7QUFFQSxPQUFLLE1BQUw7QUFFQSxFQVREOztBQVdBLE1BQUssYUFBTCxHQUFxQixZQUFZOztBQUVoQyxTQUFPLEdBQVA7QUFFQSxFQUpEOztBQU1BLE1BQUssaUJBQUwsR0FBeUIsWUFBWTs7QUFFcEMsU0FBTyxLQUFQO0FBRUEsRUFKRDs7QUFNQSxVQUFTLG9CQUFULEdBQWdDOztBQUUvQixTQUFPLElBQUksS0FBSyxFQUFULEdBQWMsRUFBZCxHQUFtQixFQUFuQixHQUF3QixNQUFNLGVBQXJDO0FBRUE7O0FBRUQsVUFBUyxZQUFULEdBQXdCOztBQUV2QixTQUFPLEtBQUssR0FBTCxDQUFVLElBQVYsRUFBZ0IsTUFBTSxTQUF0QixDQUFQO0FBRUE7O0FBRUQsVUFBUyxXQUFULENBQXNCLEtBQXRCLEVBQThCOztBQUU3QixNQUFLLE1BQU0sT0FBTixLQUFrQixLQUF2QixFQUErQjtBQUMvQixRQUFNLGNBQU47O0FBRUEsTUFBSyxNQUFNLE1BQU4sS0FBaUIsTUFBTSxZQUFOLENBQW1CLEtBQXpDLEVBQWlEO0FBQ2hELE9BQUssTUFBTSxRQUFOLEtBQW1CLElBQXhCLEVBQStCOztBQUUvQixXQUFRLE1BQU0sTUFBZDs7QUFFQSxlQUFZLEdBQVosQ0FBaUIsTUFBTSxPQUF2QixFQUFnQyxNQUFNLE9BQXRDO0FBRUEsR0FQRCxNQU9PLElBQUssTUFBTSxNQUFOLEtBQWlCLE1BQU0sWUFBTixDQUFtQixJQUF6QyxFQUFnRDtBQUN0RCxPQUFLLE1BQU0sTUFBTixLQUFpQixJQUF0QixFQUE2Qjs7QUFFN0IsV0FBUSxNQUFNLEtBQWQ7O0FBRUEsY0FBVyxHQUFYLENBQWdCLE1BQU0sT0FBdEIsRUFBK0IsTUFBTSxPQUFyQztBQUVBLEdBUE0sTUFPQSxJQUFLLE1BQU0sTUFBTixLQUFpQixNQUFNLFlBQU4sQ0FBbUIsR0FBekMsRUFBK0M7QUFDckQsT0FBSyxNQUFNLEtBQU4sS0FBZ0IsSUFBckIsRUFBNEI7O0FBRTVCLFdBQVEsTUFBTSxHQUFkOztBQUVBLFlBQVMsR0FBVCxDQUFjLE1BQU0sT0FBcEIsRUFBNkIsTUFBTSxPQUFuQztBQUVBOztBQUVELE1BQUssVUFBVSxNQUFNLElBQXJCLEVBQTRCO0FBQzNCLGNBQVcsZ0JBQVgsQ0FBNkIsV0FBN0IsRUFBMEMsV0FBMUMsRUFBdUQsS0FBdkQ7QUFDQSxjQUFXLGdCQUFYLENBQTZCLFNBQTdCLEVBQXdDLFNBQXhDLEVBQW1ELEtBQW5EO0FBQ0EsU0FBTSxhQUFOLENBQXFCLFVBQXJCO0FBQ0E7QUFFRDs7QUFFRCxVQUFTLFdBQVQsQ0FBc0IsS0FBdEIsRUFBOEI7O0FBRTdCLE1BQUssTUFBTSxPQUFOLEtBQWtCLEtBQXZCLEVBQStCOztBQUUvQixRQUFNLGNBQU47O0FBRUEsTUFBSSxVQUFVLE1BQU0sVUFBTixLQUFxQixRQUFyQixHQUFnQyxNQUFNLFVBQU4sQ0FBaUIsSUFBakQsR0FBd0QsTUFBTSxVQUE1RTs7QUFFQSxNQUFLLFVBQVUsTUFBTSxNQUFyQixFQUE4Qjs7QUFFN0IsT0FBSyxNQUFNLFFBQU4sS0FBbUIsSUFBeEIsRUFBK0I7O0FBRS9CLGFBQVUsR0FBVixDQUFlLE1BQU0sT0FBckIsRUFBOEIsTUFBTSxPQUFwQztBQUNBLGVBQVksVUFBWixDQUF3QixTQUF4QixFQUFtQyxXQUFuQzs7QUFFQTtBQUNBLFNBQU0sVUFBTixDQUFrQixJQUFJLEtBQUssRUFBVCxHQUFjLFlBQVksQ0FBMUIsR0FBOEIsUUFBUSxXQUF0QyxHQUFvRCxNQUFNLFdBQTVFOztBQUVBO0FBQ0EsU0FBTSxRQUFOLENBQWdCLElBQUksS0FBSyxFQUFULEdBQWMsWUFBWSxDQUExQixHQUE4QixRQUFRLFlBQXRDLEdBQXFELE1BQU0sV0FBM0U7O0FBRUEsZUFBWSxJQUFaLENBQWtCLFNBQWxCO0FBRUEsR0FmRCxNQWVPLElBQUssVUFBVSxNQUFNLEtBQXJCLEVBQTZCOztBQUVuQyxPQUFLLE1BQU0sTUFBTixLQUFpQixJQUF0QixFQUE2Qjs7QUFFN0IsWUFBUyxHQUFULENBQWMsTUFBTSxPQUFwQixFQUE2QixNQUFNLE9BQW5DO0FBQ0EsY0FBVyxVQUFYLENBQXVCLFFBQXZCLEVBQWlDLFVBQWpDOztBQUVBLE9BQUssV0FBVyxDQUFYLEdBQWUsQ0FBcEIsRUFBd0I7O0FBRXZCLFVBQU0sT0FBTjtBQUVBLElBSkQsTUFJTzs7QUFFTixVQUFNLFFBQU47QUFFQTs7QUFFRCxjQUFXLElBQVgsQ0FBaUIsUUFBakI7QUFFQSxHQW5CTSxNQW1CQSxJQUFLLFVBQVUsTUFBTSxHQUFyQixFQUEyQjs7QUFFakMsT0FBSyxNQUFNLEtBQU4sS0FBZ0IsSUFBckIsRUFBNEI7O0FBRTVCLFVBQU8sR0FBUCxDQUFZLE1BQU0sT0FBbEIsRUFBMkIsTUFBTSxPQUFqQztBQUNBLFlBQVMsVUFBVCxDQUFxQixNQUFyQixFQUE2QixRQUE3Qjs7QUFFQSxTQUFNLEdBQU4sQ0FBVyxTQUFTLENBQXBCLEVBQXVCLFNBQVMsQ0FBaEM7O0FBRUEsWUFBUyxJQUFULENBQWUsTUFBZjtBQUVBOztBQUVELE1BQUssVUFBVSxNQUFNLElBQXJCLEVBQTRCLE1BQU0sTUFBTjtBQUU1Qjs7QUFFRCxVQUFTLFNBQVQsR0FBb0IsV0FBYzs7QUFFakMsTUFBSyxNQUFNLE9BQU4sS0FBa0IsS0FBdkIsRUFBK0I7O0FBRS9CLGFBQVcsbUJBQVgsQ0FBZ0MsV0FBaEMsRUFBNkMsV0FBN0MsRUFBMEQsS0FBMUQ7QUFDQSxhQUFXLG1CQUFYLENBQWdDLFNBQWhDLEVBQTJDLFNBQTNDLEVBQXNELEtBQXREO0FBQ0EsUUFBTSxhQUFOLENBQXFCLFFBQXJCO0FBQ0EsVUFBUSxNQUFNLElBQWQ7QUFFQTs7QUFFRCxVQUFTLFlBQVQsQ0FBdUIsS0FBdkIsRUFBK0I7O0FBRTlCLE1BQUssTUFBTSxPQUFOLEtBQWtCLEtBQWxCLElBQTJCLE1BQU0sTUFBTixLQUFpQixJQUE1QyxJQUFvRCxVQUFVLE1BQU0sSUFBekUsRUFBZ0Y7O0FBRWhGLFFBQU0sY0FBTjtBQUNBLFFBQU0sZUFBTjs7QUFFQSxNQUFJLFFBQVEsQ0FBWjs7QUFFQSxNQUFLLE1BQU0sVUFBTixLQUFxQixTQUExQixFQUFzQztBQUFFOztBQUV2QyxXQUFRLE1BQU0sVUFBZDtBQUVBLEdBSkQsTUFJTyxJQUFLLE1BQU0sTUFBTixLQUFpQixTQUF0QixFQUFrQztBQUFFOztBQUUxQyxXQUFRLENBQUUsTUFBTSxNQUFoQjtBQUVBOztBQUVELE1BQUssUUFBUSxDQUFiLEVBQWlCOztBQUVoQixTQUFNLFFBQU47QUFFQSxHQUpELE1BSU87O0FBRU4sU0FBTSxPQUFOO0FBRUE7O0FBRUQsUUFBTSxNQUFOO0FBQ0EsUUFBTSxhQUFOLENBQXFCLFVBQXJCO0FBQ0EsUUFBTSxhQUFOLENBQXFCLFFBQXJCO0FBRUE7O0FBRUQsVUFBUyxTQUFULENBQW9CLEtBQXBCLEVBQTRCOztBQUUzQixNQUFLLE1BQU0sT0FBTixLQUFrQixLQUFsQixJQUEyQixNQUFNLE1BQU4sS0FBaUIsSUFBNUMsSUFBb0QsTUFBTSxLQUFOLEtBQWdCLElBQXpFLEVBQWdGOztBQUVoRixVQUFTLE1BQU0sT0FBZjs7QUFFQyxRQUFLLE1BQU0sSUFBTixDQUFXLEVBQWhCO0FBQ0MsVUFBTSxRQUFOO0FBQ0EsVUFBTSxNQUFOO0FBQ0E7O0FBRUQsUUFBSyxNQUFNLElBQU4sQ0FBVyxNQUFoQjtBQUNDLFVBQU0sT0FBTjtBQUNBLFVBQU0sTUFBTjtBQUNBOztBQUVELFFBQUssTUFBTSxJQUFOLENBQVcsSUFBaEI7QUFDQyxrQkFBYyxHQUFkO0FBQ0EsVUFBTSxNQUFOO0FBQ0E7O0FBRUQsUUFBSyxNQUFNLElBQU4sQ0FBVyxLQUFoQjtBQUNDLGtCQUFjLEdBQWQ7QUFDQSxVQUFNLE1BQU47QUFDQTs7QUFwQkY7QUF3QkE7O0FBRUQsVUFBUyxVQUFULENBQXFCLEtBQXJCLEVBQTZCOztBQUU1QixNQUFLLE1BQU0sT0FBTixLQUFrQixLQUF2QixFQUErQjs7QUFFL0IsVUFBUyxNQUFNLE9BQU4sQ0FBYyxNQUF2Qjs7QUFFQyxRQUFLLENBQUw7QUFBUTs7QUFFUCxRQUFLLE1BQU0sUUFBTixLQUFtQixJQUF4QixFQUErQjs7QUFFL0IsWUFBUSxNQUFNLFlBQWQ7O0FBRUEsZ0JBQVksR0FBWixDQUFpQixNQUFNLE9BQU4sQ0FBZSxDQUFmLEVBQW1CLEtBQXBDLEVBQTJDLE1BQU0sT0FBTixDQUFlLENBQWYsRUFBbUIsS0FBOUQ7QUFDQTs7QUFFRCxRQUFLLENBQUw7QUFBUTs7QUFFUCxRQUFLLE1BQU0sTUFBTixLQUFpQixJQUF0QixFQUE2Qjs7QUFFN0IsWUFBUSxNQUFNLFdBQWQ7O0FBRUEsUUFBSSxLQUFLLE1BQU0sT0FBTixDQUFlLENBQWYsRUFBbUIsS0FBbkIsR0FBMkIsTUFBTSxPQUFOLENBQWUsQ0FBZixFQUFtQixLQUF2RDtBQUNBLFFBQUksS0FBSyxNQUFNLE9BQU4sQ0FBZSxDQUFmLEVBQW1CLEtBQW5CLEdBQTJCLE1BQU0sT0FBTixDQUFlLENBQWYsRUFBbUIsS0FBdkQ7QUFDQSxRQUFJLFdBQVcsS0FBSyxJQUFMLENBQVcsS0FBSyxFQUFMLEdBQVUsS0FBSyxFQUExQixDQUFmO0FBQ0EsZUFBVyxHQUFYLENBQWdCLENBQWhCLEVBQW1CLFFBQW5CO0FBQ0E7O0FBRUQsUUFBSyxDQUFMO0FBQVE7O0FBRVAsUUFBSyxNQUFNLEtBQU4sS0FBZ0IsSUFBckIsRUFBNEI7O0FBRTVCLFlBQVEsTUFBTSxTQUFkOztBQUVBLGFBQVMsR0FBVCxDQUFjLE1BQU0sT0FBTixDQUFlLENBQWYsRUFBbUIsS0FBakMsRUFBd0MsTUFBTSxPQUFOLENBQWUsQ0FBZixFQUFtQixLQUEzRDtBQUNBOztBQUVEOztBQUVDLFlBQVEsTUFBTSxJQUFkOztBQWxDRjs7QUFzQ0EsTUFBSyxVQUFVLE1BQU0sSUFBckIsRUFBNEIsTUFBTSxhQUFOLENBQXFCLFVBQXJCO0FBRTVCOztBQUVELFVBQVMsU0FBVCxDQUFvQixLQUFwQixFQUE0Qjs7QUFFM0IsTUFBSyxNQUFNLE9BQU4sS0FBa0IsS0FBdkIsRUFBK0I7O0FBRS9CLFFBQU0sY0FBTjtBQUNBLFFBQU0sZUFBTjs7QUFFQSxNQUFJLFVBQVUsTUFBTSxVQUFOLEtBQXFCLFFBQXJCLEdBQWdDLE1BQU0sVUFBTixDQUFpQixJQUFqRCxHQUF3RCxNQUFNLFVBQTVFOztBQUVBLFVBQVMsTUFBTSxPQUFOLENBQWMsTUFBdkI7O0FBRUMsUUFBSyxDQUFMO0FBQVE7O0FBRVAsUUFBSyxNQUFNLFFBQU4sS0FBbUIsSUFBeEIsRUFBK0I7QUFDL0IsUUFBSyxVQUFVLE1BQU0sWUFBckIsRUFBb0M7O0FBRXBDLGNBQVUsR0FBVixDQUFlLE1BQU0sT0FBTixDQUFlLENBQWYsRUFBbUIsS0FBbEMsRUFBeUMsTUFBTSxPQUFOLENBQWUsQ0FBZixFQUFtQixLQUE1RDtBQUNBLGdCQUFZLFVBQVosQ0FBd0IsU0FBeEIsRUFBbUMsV0FBbkM7O0FBRUE7QUFDQSxVQUFNLFVBQU4sQ0FBa0IsSUFBSSxLQUFLLEVBQVQsR0FBYyxZQUFZLENBQTFCLEdBQThCLFFBQVEsV0FBdEMsR0FBb0QsTUFBTSxXQUE1RTtBQUNBO0FBQ0EsVUFBTSxRQUFOLENBQWdCLElBQUksS0FBSyxFQUFULEdBQWMsWUFBWSxDQUExQixHQUE4QixRQUFRLFlBQXRDLEdBQXFELE1BQU0sV0FBM0U7O0FBRUEsZ0JBQVksSUFBWixDQUFrQixTQUFsQjs7QUFFQSxVQUFNLE1BQU47QUFDQTs7QUFFRCxRQUFLLENBQUw7QUFBUTs7QUFFUCxRQUFLLE1BQU0sTUFBTixLQUFpQixJQUF0QixFQUE2QjtBQUM3QixRQUFLLFVBQVUsTUFBTSxXQUFyQixFQUFtQzs7QUFFbkMsUUFBSSxLQUFLLE1BQU0sT0FBTixDQUFlLENBQWYsRUFBbUIsS0FBbkIsR0FBMkIsTUFBTSxPQUFOLENBQWUsQ0FBZixFQUFtQixLQUF2RDtBQUNBLFFBQUksS0FBSyxNQUFNLE9BQU4sQ0FBZSxDQUFmLEVBQW1CLEtBQW5CLEdBQTJCLE1BQU0sT0FBTixDQUFlLENBQWYsRUFBbUIsS0FBdkQ7QUFDQSxRQUFJLFdBQVcsS0FBSyxJQUFMLENBQVcsS0FBSyxFQUFMLEdBQVUsS0FBSyxFQUExQixDQUFmOztBQUVBLGFBQVMsR0FBVCxDQUFjLENBQWQsRUFBaUIsUUFBakI7QUFDQSxlQUFXLFVBQVgsQ0FBdUIsUUFBdkIsRUFBaUMsVUFBakM7O0FBRUEsUUFBSyxXQUFXLENBQVgsR0FBZSxDQUFwQixFQUF3Qjs7QUFFdkIsV0FBTSxRQUFOO0FBRUEsS0FKRCxNQUlPOztBQUVOLFdBQU0sT0FBTjtBQUVBOztBQUVELGVBQVcsSUFBWCxDQUFpQixRQUFqQjs7QUFFQSxVQUFNLE1BQU47QUFDQTs7QUFFRCxRQUFLLENBQUw7QUFBUTs7QUFFUCxRQUFLLE1BQU0sS0FBTixLQUFnQixJQUFyQixFQUE0QjtBQUM1QixRQUFLLFVBQVUsTUFBTSxTQUFyQixFQUFpQzs7QUFFakMsV0FBTyxHQUFQLENBQVksTUFBTSxPQUFOLENBQWUsQ0FBZixFQUFtQixLQUEvQixFQUFzQyxNQUFNLE9BQU4sQ0FBZSxDQUFmLEVBQW1CLEtBQXpEO0FBQ0EsYUFBUyxVQUFULENBQXFCLE1BQXJCLEVBQTZCLFFBQTdCOztBQUVBLFVBQU0sR0FBTixDQUFXLFNBQVMsQ0FBcEIsRUFBdUIsU0FBUyxDQUFoQzs7QUFFQSxhQUFTLElBQVQsQ0FBZSxNQUFmOztBQUVBLFVBQU0sTUFBTjtBQUNBOztBQUVEOztBQUVDLFlBQVEsTUFBTSxJQUFkOztBQWhFRjtBQW9FQTs7QUFFRCxVQUFTLFFBQVQsR0FBbUIsV0FBYzs7QUFFaEMsTUFBSyxNQUFNLE9BQU4sS0FBa0IsS0FBdkIsRUFBK0I7O0FBRS9CLFFBQU0sYUFBTixDQUFxQixRQUFyQjtBQUNBLFVBQVEsTUFBTSxJQUFkO0FBRUE7O0FBRUQsTUFBSyxVQUFMLENBQWdCLGdCQUFoQixDQUFrQyxhQUFsQyxFQUFpRCxVQUFXLEtBQVgsRUFBbUI7QUFBRSxRQUFNLGNBQU47QUFBeUIsRUFBL0YsRUFBaUcsS0FBakc7QUFDQSxNQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLENBQWtDLFdBQWxDLEVBQStDLFdBQS9DLEVBQTRELEtBQTVEO0FBQ0EsTUFBSyxVQUFMLENBQWdCLGdCQUFoQixDQUFrQyxZQUFsQyxFQUFnRCxZQUFoRCxFQUE4RCxLQUE5RDtBQUNBLE1BQUssVUFBTCxDQUFnQixnQkFBaEIsQ0FBa0MsZ0JBQWxDLEVBQW9ELFlBQXBELEVBQWtFLEtBQWxFLEVBOW5CcUQsQ0E4bkJzQjs7QUFFM0UsTUFBSyxVQUFMLENBQWdCLGdCQUFoQixDQUFrQyxZQUFsQyxFQUFnRCxVQUFoRCxFQUE0RCxLQUE1RDtBQUNBLE1BQUssVUFBTCxDQUFnQixnQkFBaEIsQ0FBa0MsVUFBbEMsRUFBOEMsUUFBOUMsRUFBd0QsS0FBeEQ7QUFDQSxNQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLENBQWtDLFdBQWxDLEVBQStDLFNBQS9DLEVBQTBELEtBQTFEOztBQUVBLFFBQU8sZ0JBQVAsQ0FBeUIsU0FBekIsRUFBb0MsU0FBcEMsRUFBK0MsS0FBL0M7O0FBRUE7QUFDQSxNQUFLLE1BQUw7QUFFQSxDQXpvQkQsQyxDQTFCQTs7O0FBcXFCQSxnQkFBTSxhQUFOLENBQW9CLFNBQXBCLEdBQWdDLE9BQU8sTUFBUCxDQUFlLGdCQUFNLGVBQU4sQ0FBc0IsU0FBckMsQ0FBaEM7QUFDQSxnQkFBTSxhQUFOLENBQW9CLFNBQXBCLENBQThCLFdBQTlCLEdBQTRDLGdCQUFNLGFBQWxEOzs7Ozs7OztrQkNucUJ3QixJOztBQUh4Qjs7OztBQUNBOzs7O0FBRWUsU0FBUyxJQUFULEdBQWdCO0FBQzdCLE1BQU0sUUFBUSxJQUFJLGdCQUFNLEtBQVYsRUFBZDtBQUNBLE1BQU0sZUFBZSxNQUFNLElBQTNCOztBQUVBLE1BQU0sV0FBVyxJQUFJLGdCQUFNLGFBQVYsQ0FBd0IsRUFBRSxXQUFXLElBQWIsRUFBbUIsV0FBVyxJQUE5QixFQUFvQyxPQUFPLElBQTNDLEVBQXhCLENBQWpCO0FBQ0E7QUFDQTtBQUNBLFdBQVMsYUFBVCxDQUF1QixRQUF2QixFQUFpQyxDQUFqQztBQUNBLFdBQVMsU0FBVCxDQUFtQixPQUFuQixHQUE2QixJQUE3QjtBQUNBLFdBQVMsU0FBVCxDQUFtQixJQUFuQixHQUEwQixJQUExQjtBQUNBLFdBQVMsU0FBVCxDQUFtQixJQUFuQixHQUEwQixnQkFBTSxnQkFBaEM7QUFDQTs7QUFFQSxNQUFNLFNBQVMsSUFBSSxnQkFBTSxpQkFBVixDQUE0QixFQUE1QixFQUFnQyxDQUFoQyxFQUFtQyxDQUFuQyxFQUFzQyxLQUF0QyxDQUFmO0FBQ0EsU0FBTyxRQUFQLENBQWdCLENBQWhCLEdBQW9CLElBQXBCO0FBQ0EsU0FBTyxRQUFQLENBQWdCLENBQWhCLEdBQW9CLENBQXBCO0FBQ0EsU0FBTyxRQUFQLENBQWdCLENBQWhCLEdBQW9CLEdBQXBCO0FBQ0EsU0FBTyxNQUFQLENBQWMsSUFBSSxnQkFBTSxPQUFWLENBQWtCLENBQWxCLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCLENBQWQ7O0FBRUEsTUFBTSxPQUFPLElBQUksZ0JBQU0sU0FBVixDQUFvQixRQUFwQixFQUE4QixDQUE5QixDQUFiO0FBQ0EsT0FBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixHQUFsQixFQUF1QixHQUF2QixFQUE0QixHQUE1QjtBQUNBLE9BQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsR0FBckIsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsQ0FBL0I7QUFDQSxPQUFLLGdCQUFMLEdBQXdCLENBQXhCO0FBQ0EsT0FBSyxlQUFMLEdBQXVCLElBQXZCO0FBQ0EsT0FBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsT0FBSyxjQUFMLEdBQXNCLEdBQXRCO0FBQ0EsT0FBSyxVQUFMLEdBQWtCLE1BQWxCO0FBQ0EsT0FBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsT0FBSyxlQUFMLEdBQXVCLElBQXZCO0FBQ0EsUUFBTSxHQUFOLENBQVUsSUFBVjs7QUFFQSxNQUFNLFFBQVEsSUFBSSxnQkFBTSxJQUFWLENBQ1osSUFBSSxnQkFBTSxhQUFWLENBQXdCLElBQXhCLEVBQThCLElBQTlCLEVBQW9DLEVBQXBDLEVBQXdDLEVBQXhDLENBRFksRUFFWixJQUFJLGdCQUFNLGlCQUFWLENBQTRCLEVBQUUsT0FBTyxRQUFULEVBQW1CLFdBQVcsSUFBOUIsRUFBNUIsQ0FGWSxDQUFkO0FBSUE7QUFDQSxRQUFNLFFBQU4sQ0FBZSxDQUFmLElBQW9CLEtBQUssRUFBTCxHQUFVLENBQTlCO0FBQ0E7QUFDQTs7QUFFQSxRQUFNLFFBQU4sQ0FBZSxJQUFmLEdBQXNCLGdCQUFNLFVBQTVCO0FBQ0EsUUFBTSxRQUFOLENBQWUsQ0FBZixHQUFtQixFQUFuQjtBQUNBLFFBQU0sUUFBTixDQUFlLENBQWYsR0FBbUIsRUFBbkI7QUFDQSxRQUFNLGFBQU4sR0FBc0IsSUFBdEI7QUFDQSxRQUFNLEdBQU4sQ0FBVSxLQUFWOztBQUVBLE1BQU0sUUFBUSxJQUFJLGdCQUFNLGVBQVYsQ0FBMEIsUUFBMUIsRUFBb0MsUUFBcEMsRUFBOEMsR0FBOUMsQ0FBZDtBQUNBLFFBQU0sR0FBTixDQUFVLEtBQVY7O0FBRUEsTUFBTSxXQUFXLElBQUksZ0JBQU0sYUFBVixDQUF3QixNQUF4QixFQUFnQyxTQUFTLFVBQXpDLENBQWpCO0FBQ0E7QUFDQSxXQUFTLGdCQUFULENBQTBCLFFBQTFCLEVBQW9DLFlBQU07QUFDeEM7QUFDQTtBQUNELEdBSEQ7O0FBTUEsV0FBUyxNQUFULENBQWdCLEtBQWhCLEVBQXVCLE1BQXZCLEVBQStCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUFTQSxRQUFNLFNBQVMsUUFBUSxNQUF2QjtBQUNBO0FBQ0E7QUFDQSxRQUFNLE9BQU8sZ0JBQU0sSUFBTixDQUFXLFFBQVgsQ0FBb0IsT0FBTyxHQUEzQixDQUFiO0FBQ0EsUUFBTSxPQUFPLElBQUksS0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLENBQVMsT0FBTyxDQUFoQixJQUFxQixNQUEvQixDQUFqQjs7QUFHQTtBQUNBO0FBQ0EsUUFBTSxRQUFRLFNBQVMsQ0FBVCxHQUFjLEtBQUssR0FBTCxDQUFTLE9BQU8sQ0FBaEIsQ0FBNUI7QUFDQSxRQUFNLFFBQVEsU0FBUyxDQUFULEdBQWMsS0FBSyxHQUFMLENBQVMsT0FBTyxDQUFoQixDQUE1QjtBQUNBLFFBQU0sT0FBTyxRQUFRLE1BQVIsR0FBaUIsS0FBakIsR0FBeUIsS0FBdEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLFlBQVEsR0FBUixDQUFZLElBQVosRUFBa0IsT0FBTyxRQUF6QjtBQUNBLFdBQU8sUUFBUCxDQUFnQixDQUFoQixHQUFvQixPQUFPLEdBQTNCO0FBQ0EsV0FBTyxRQUFQLENBQWdCLENBQWhCLEdBQW9CLE9BQU8sUUFBUCxDQUFnQixDQUFoQixHQUFvQixZQUF4Qzs7QUFHQTtBQUNBLFdBQU8sTUFBUCxHQUFnQixRQUFRLE1BQXhCO0FBQ0EsV0FBTyxzQkFBUDtBQUNBLGFBQVMsT0FBVCxDQUFpQixLQUFqQixFQUF3QixNQUF4QjtBQUNBO0FBQ0Q7O0FBR0QsV0FBUyxNQUFULEdBQWtCO0FBQ2hCLFFBQU0sT0FBTyxPQUFPLEdBQVAsSUFBYyxLQUFLLEVBQUwsR0FBVSxHQUF4QixDQUFiLENBRGdCLENBQzJCO0FBQzNDLFFBQU0sVUFBVSxJQUFJLEtBQUssR0FBTCxDQUFTLE9BQU8sQ0FBaEIsQ0FBSixJQUEwQixPQUFPLFFBQVAsQ0FBZ0IsQ0FBaEIsR0FBb0IsR0FBOUMsQ0FBaEIsQ0FGZ0IsQ0FFb0Q7QUFDcEUsUUFBTSxTQUFTLFVBQVUsT0FBTyxNQUFoQyxDQUhnQixDQUd3Qjs7QUFFeEM7QUFDQTs7QUFFQSxRQUFNLFdBQVcsT0FBTyxRQUFQLENBQWdCLENBQWpDO0FBQ0EsUUFBTSxXQUFXLE9BQU8sUUFBUCxDQUFnQixDQUFqQztBQUNBLFFBQU0sUUFBUSxXQUFXLFFBQXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQVMsTUFBVCxDQUFnQixLQUFoQixFQUF1QixNQUF2QjtBQUNEOztBQUdELFNBQU87QUFDTCxrQkFESztBQUVMLGtCQUZLO0FBR0wsZ0JBQVksU0FBUztBQUhoQixHQUFQO0FBS0Q7OztBQzNKRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCBjcmVhdGVTY2VuZTNEIGZyb20gJy4vc2NlbmUzZCc7XG5cbmxldCBzY2VuZTNkO1xuXG5jb25zdCByZXNpemUgPSAoKSA9PiB7XG4gIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgc2NlbmUzZC5yZXNpemUod2lkdGgsIGhlaWdodCk7XG59O1xuXG53aW5kb3cub25sb2FkID0gKCkgPT4ge1xuICBzY2VuZTNkID0gY3JlYXRlU2NlbmUzRCgpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjZW5lM2QuZG9tRWxlbWVudCk7XG4gIHJlc2l6ZSgpO1xuICB3aW5kb3cub25yZXNpemUgPSByZXNpemU7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBUSFJFRSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cbiAqL1xuLypnbG9iYWwgVEhSRUUsIGNvbnNvbGUgKi9cblxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuIEl0IG1haW50YWluc1xuLy8gdGhlIFwidXBcIiBkaXJlY3Rpb24gYXMgK1ksIHVubGlrZSB0aGUgVHJhY2tiYWxsQ29udHJvbHMuIFRvdWNoIG9uIHRhYmxldCBhbmQgcGhvbmVzIGlzXG4vLyBzdXBwb3J0ZWQuXG4vL1xuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxuLy8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28gZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcbi8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbnRlciBzd2lwZVxuLy9cbi8vIFRoaXMgaXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciAobW9zdCkgVHJhY2tiYWxsQ29udHJvbHMgdXNlZCBpbiBleGFtcGxlcy5cbi8vIFRoYXQgaXMsIGluY2x1ZGUgdGhpcyBqcyBmaWxlIGFuZCB3aGVyZXZlciB5b3Ugc2VlOlxuLy8gICAgXHRjb250cm9scyA9IG5ldyBUSFJFRS5UcmFja2JhbGxDb250cm9scyggY2FtZXJhICk7XG4vLyAgICAgIGNvbnRyb2xzLnRhcmdldC56ID0gMTUwO1xuLy8gU2ltcGxlIHN1YnN0aXR1dGUgXCJPcmJpdENvbnRyb2xzXCIgYW5kIHRoZSBjb250cm9sIHNob3VsZCB3b3JrIGFzLWlzLlxuXG5USFJFRS5PcmJpdENvbnRyb2xzID0gZnVuY3Rpb24gKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XG5cblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cdHZhciBkb21FbGVtZW50ID0gdGhpcy5kb21FbGVtZW50O1xuXG5cdC8vIEFQSVxuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBjb250cm9sIG9yYml0cyBhcm91bmRcblx0Ly8gYW5kIHdoZXJlIGl0IHBhbnMgd2l0aCByZXNwZWN0IHRvLlxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0Ly8gY2VudGVyIGlzIG9sZCwgZGVwcmVjYXRlZDsgdXNlIFwidGFyZ2V0XCIgaW5zdGVhZFxuXHR0aGlzLmNlbnRlciA9IHRoaXMudGFyZ2V0O1xuXG5cdC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3Jcblx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0dGhpcy5ub1pvb20gPSBmYWxzZTtcblx0dGhpcy56b29tU3BlZWQgPSAxLjA7XG5cblx0Ly8gTGltaXRzIHRvIGhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0XG5cdHRoaXMubWluRGlzdGFuY2UgPSAwO1xuXHR0aGlzLm1heERpc3RhbmNlID0gODAwMDtcblxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuXHR0aGlzLm5vUm90YXRlID0gZmFsc2U7XG5cdHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XG5cblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcblx0dGhpcy5ub1BhbiA9IGZhbHNlO1xuXHR0aGlzLmtleVBhblNwZWVkID0gNy4wO1x0Ly8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXG5cdC8vIFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgcm90YXRlIGFyb3VuZCB0aGUgdGFyZ2V0XG5cdHRoaXMuYXV0b1JvdGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcblxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cblx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG5cdHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcblx0dGhpcy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSSAvIDIuMDU7IC8vIHJhZGlhbnNcblxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgaG9yaXpvbnRhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHQvLyBJZiBzZXQsIG11c3QgYmUgYSBzdWItaW50ZXJ2YWwgb2YgdGhlIGludGVydmFsIFsgLSBNYXRoLlBJLCBNYXRoLlBJIF0uXG5cdHRoaXMubWluQXppbXV0aEFuZ2xlID0gLSBJbmZpbml0eTsgLy8gcmFkaWFuc1xuXHR0aGlzLm1heEF6aW11dGhBbmdsZSA9IEluZmluaXR5OyAvLyByYWRpYW5zXG5cblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB1c2Ugb2YgdGhlIGtleXNcblx0dGhpcy5ub0tleXMgPSBmYWxzZTtcblxuXHQvLyBUaGUgZm91ciBhcnJvdyBrZXlzXG5cdHRoaXMua2V5cyA9IHsgTEVGVDogMzcsIFVQOiAzOCwgUklHSFQ6IDM5LCBCT1RUT006IDQwIH07XG5cblx0Ly8gTW91c2UgYnV0dG9uc1xuXHR0aGlzLm1vdXNlQnV0dG9ucyA9IHsgT1JCSVQ6IFRIUkVFLk1PVVNFLkxFRlQsIFpPT006IFRIUkVFLk1PVVNFLk1JRERMRSwgUEFOOiBUSFJFRS5NT1VTRS5SSUdIVCB9O1xuXG5cdC8vLy8vLy8vLy8vL1xuXHQvLyBpbnRlcm5hbHNcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBFUFMgPSAwLjAwMDAwMTtcblxuXHR2YXIgcm90YXRlU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHJvdGF0ZURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHR2YXIgcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHBhbkRlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIGRvbGx5U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgZG9sbHlFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmFyIHRoZXRhO1xuXHR2YXIgcGhpO1xuXHR2YXIgcGhpRGVsdGEgPSAwO1xuXHR2YXIgdGhldGFEZWx0YSA9IDA7XG5cdHZhciBzY2FsZSA9IDE7XG5cdHZhciBwYW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHZhciBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgbGFzdFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdHZhciBTVEFURSA9IHsgTk9ORSA6IC0xLCBST1RBVEUgOiAwLCBET0xMWSA6IDEsIFBBTiA6IDIsIFRPVUNIX1JPVEFURSA6IDMsIFRPVUNIX0RPTExZIDogNCwgVE9VQ0hfUEFOIDogNSB9O1xuXG5cdHZhciBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0Ly8gZm9yIHJlc2V0XG5cblx0dGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcblx0dGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuXG5cdC8vIHNvIGNhbWVyYS51cCBpcyB0aGUgb3JiaXQgYXhpc1xuXG5cdHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMoIG9iamVjdC51cCwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXHR2YXIgcXVhdEludmVyc2UgPSBxdWF0LmNsb25lKCkuaW52ZXJzZSgpO1xuXG5cdC8vIGV2ZW50c1xuXG5cdHZhciBjaGFuZ2VFdmVudCA9IHsgdHlwZTogJ2NoYW5nZScgfTtcblx0dmFyIHN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzdGFydCd9O1xuXHR2YXIgZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnfTtcblxuXHR0aGlzLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0aWYgKCBhbmdsZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cblx0XHR9XG5cblx0XHR0aGV0YURlbHRhIC09IGFuZ2xlO1xuXG5cdH07XG5cblx0dGhpcy5yb3RhdGVVcCA9IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGFuZ2xlID0gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKTtcblxuXHRcdH1cblxuXHRcdHBoaURlbHRhIC09IGFuZ2xlO1xuXG5cdH07XG5cblx0Ly8gcGFzcyBpbiBkaXN0YW5jZSBpbiB3b3JsZCBzcGFjZSB0byBtb3ZlIGxlZnRcblx0dGhpcy5wYW5MZWZ0ID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMub2JqZWN0Lm1hdHJpeC5lbGVtZW50cztcblxuXHRcdC8vIGdldCBYIGNvbHVtbiBvZiBtYXRyaXhcblx0XHRwYW5PZmZzZXQuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICk7XG5cdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XG5cblx0XHRwYW4uYWRkKCBwYW5PZmZzZXQgKTtcblxuXHR9O1xuXG5cdC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSB1cFxuXHR0aGlzLnBhblVwID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMub2JqZWN0Lm1hdHJpeC5lbGVtZW50cztcblxuXHRcdC8vIGdldCBZIGNvbHVtbiBvZiBtYXRyaXhcblx0XHRwYW5PZmZzZXQuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XG5cdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApO1xuXG5cdFx0cGFuLmFkZCggcGFuT2Zmc2V0ICk7XG5cblx0fTtcblxuXHQvLyBwYXNzIGluIHgseSBvZiBjaGFuZ2UgZGVzaXJlZCBpbiBwaXhlbCBzcGFjZSxcblx0Ly8gcmlnaHQgYW5kIGRvd24gYXJlIHBvc2l0aXZlXG5cdHRoaXMucGFuID0gZnVuY3Rpb24gKCBkZWx0YVgsIGRlbHRhWSApIHtcblxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0aWYgKCBzY29wZS5vYmplY3QuZm92ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIHBlcnNwZWN0aXZlXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcG9zaXRpb24uY2xvbmUoKS5zdWIoIHNjb3BlLnRhcmdldCApO1xuXHRcdFx0dmFyIHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG5cdFx0XHQvLyBoYWxmIG9mIHRoZSBmb3YgaXMgY2VudGVyIHRvIHRvcCBvZiBzY3JlZW5cblx0XHRcdHRhcmdldERpc3RhbmNlICo9IE1hdGgudGFuKCAoIHNjb3BlLm9iamVjdC5mb3YgLyAyICkgKiBNYXRoLlBJIC8gMTgwLjAgKTtcblxuXHRcdFx0Ly8gd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHNjcmVlbldpZHRoLCBzaW5jZSBwZXJzcGVjdGl2ZSBjYW1lcmEgaXMgZml4ZWQgdG8gc2NyZWVuIGhlaWdodFxuXHRcdFx0c2NvcGUucGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblx0XHRcdHNjb3BlLnBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCApO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LnRvcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBvcnRob2dyYXBoaWNcblx0XHRcdHNjb3BlLnBhbkxlZnQoIGRlbHRhWCAqIChzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCkgLyBlbGVtZW50LmNsaWVudFdpZHRoICk7XG5cdFx0XHRzY29wZS5wYW5VcCggZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjYW1lcmEgbmVpdGhlciBvcnRob2dyYXBoaWMgb3IgcGVyc3BlY3RpdmVcblx0XHRcdC8vIGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHBhbiBkaXNhYmxlZC4nICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmRvbGx5SW4gPSBmdW5jdGlvbiAoIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRpZiAoIGRvbGx5U2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xuXG5cdFx0fVxuXG5cdFx0c2NhbGUgLz0gZG9sbHlTY2FsZTtcblxuXHR9O1xuXG5cdHRoaXMuZG9sbHlPdXQgPSBmdW5jdGlvbiAoIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRpZiAoIGRvbGx5U2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xuXG5cdFx0fVxuXG5cdFx0c2NhbGUgKj0gZG9sbHlTY2FsZTtcblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5vYmplY3QucG9zaXRpb247XG5cblx0XHRvZmZzZXQuY29weSggcG9zaXRpb24gKS5zdWIoIHRoaXMudGFyZ2V0ICk7XG5cblx0XHQvLyByb3RhdGUgb2Zmc2V0IHRvIFwieS1heGlzLWlzLXVwXCIgc3BhY2Vcblx0XHRvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ICk7XG5cblx0XHQvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG5cblx0XHR0aGV0YSA9IE1hdGguYXRhbjIoIG9mZnNldC54LCBvZmZzZXQueiApO1xuXG5cdFx0Ly8gYW5nbGUgZnJvbSB5LWF4aXNcblxuXHRcdHBoaSA9IE1hdGguYXRhbjIoIE1hdGguc3FydCggb2Zmc2V0LnggKiBvZmZzZXQueCArIG9mZnNldC56ICogb2Zmc2V0LnogKSwgb2Zmc2V0LnkgKTtcblxuXHRcdGlmICggdGhpcy5hdXRvUm90YXRlICYmIHN0YXRlID09PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHR0aGlzLnJvdGF0ZUxlZnQoIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoZXRhICs9IHRoZXRhRGVsdGE7XG5cdFx0cGhpICs9IHBoaURlbHRhO1xuXG5cdFx0Ly8gcmVzdHJpY3QgdGhldGEgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdHRoZXRhID0gTWF0aC5tYXgoIHRoaXMubWluQXppbXV0aEFuZ2xlLCBNYXRoLm1pbiggdGhpcy5tYXhBemltdXRoQW5nbGUsIHRoZXRhICkgKTtcblxuXHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cdFx0cGhpID0gTWF0aC5tYXgoIHRoaXMubWluUG9sYXJBbmdsZSwgTWF0aC5taW4oIHRoaXMubWF4UG9sYXJBbmdsZSwgcGhpICkgKTtcblxuXHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWUgRVBTIGFuZCBQSS1FUFNcblx0XHRwaGkgPSBNYXRoLm1heCggRVBTLCBNYXRoLm1pbiggTWF0aC5QSSAtIEVQUywgcGhpICkgKTtcblxuXHRcdHZhciByYWRpdXMgPSBvZmZzZXQubGVuZ3RoKCkgKiBzY2FsZTtcblxuXHRcdC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cdFx0cmFkaXVzID0gTWF0aC5tYXgoIHRoaXMubWluRGlzdGFuY2UsIE1hdGgubWluKCB0aGlzLm1heERpc3RhbmNlLCByYWRpdXMgKSApO1xuXG5cdFx0Ly8gbW92ZSB0YXJnZXQgdG8gcGFubmVkIGxvY2F0aW9uXG5cdFx0dGhpcy50YXJnZXQuYWRkKCBwYW4gKTtcblxuXHRcdG9mZnNldC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0b2Zmc2V0LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggcGhpICk7XG5cdFx0b2Zmc2V0LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpICkgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdC8vIHJvdGF0ZSBvZmZzZXQgYmFjayB0byBcImNhbWVyYS11cC12ZWN0b3ItaXMtdXBcIiBzcGFjZVxuXHRcdG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXRJbnZlcnNlICk7XG5cblx0XHRwb3NpdGlvbi5jb3B5KCB0aGlzLnRhcmdldCApLmFkZCggb2Zmc2V0ICk7XG5cblx0XHR0aGlzLm9iamVjdC5sb29rQXQoIHRoaXMudGFyZ2V0ICk7XG5cblx0XHR0aGV0YURlbHRhID0gMDtcblx0XHRwaGlEZWx0YSA9IDA7XG5cdFx0c2NhbGUgPSAxO1xuXHRcdHBhbi5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdC8vIHVwZGF0ZSBjb25kaXRpb24gaXM6XG5cdFx0Ly8gbWluKGNhbWVyYSBkaXNwbGFjZW1lbnQsIGNhbWVyYSByb3RhdGlvbiBpbiByYWRpYW5zKV4yID4gRVBTXG5cdFx0Ly8gdXNpbmcgc21hbGwtYW5nbGUgYXBwcm94aW1hdGlvbiBjb3MoeC8yKSA9IDEgLSB4XjIgLyA4XG5cblx0XHRpZiAoIGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5vYmplY3QucG9zaXRpb24gKSA+IEVQU1xuXHRcdCAgICB8fCA4ICogKDEgLSBsYXN0UXVhdGVybmlvbi5kb3QodGhpcy5vYmplY3QucXVhdGVybmlvbikpID4gRVBTICkge1xuXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XG5cblx0XHRcdGxhc3RQb3NpdGlvbi5jb3B5KCB0aGlzLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0bGFzdFF1YXRlcm5pb24uY29weSAodGhpcy5vYmplY3QucXVhdGVybmlvbiApO1xuXG5cdFx0fVxuXG5cdH07XG5cblxuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0dGhpcy50YXJnZXQuY29weSggdGhpcy50YXJnZXQwICk7XG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24uY29weSggdGhpcy5wb3NpdGlvbjAgKTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fTtcblxuXHR0aGlzLmdldFBvbGFyQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gcGhpO1xuXG5cdH07XG5cblx0dGhpcy5nZXRBemltdXRoYWxBbmdsZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGV0YVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSB7XG5cblx0XHRyZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogc2NvcGUuYXV0b1JvdGF0ZVNwZWVkO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRab29tU2NhbGUoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5wb3coIDAuOTUsIHNjb3BlLnpvb21TcGVlZCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlRG93biggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gc2NvcGUubW91c2VCdXR0b25zLk9SQklUICkge1xuXHRcdFx0aWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0c3RhdGUgPSBTVEFURS5ST1RBVEU7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fSBlbHNlIGlmICggZXZlbnQuYnV0dG9uID09PSBzY29wZS5tb3VzZUJ1dHRvbnMuWk9PTSApIHtcblx0XHRcdGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLkRPTExZO1xuXG5cdFx0XHRkb2xseVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fSBlbHNlIGlmICggZXZlbnQuYnV0dG9uID09PSBzY29wZS5tb3VzZUJ1dHRvbnMuUEFOICkge1xuXHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0c3RhdGUgPSBTVEFURS5QQU47XG5cblx0XHRcdHBhblN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblx0XHRcdGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdFx0ZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHRpZiAoIHN0YXRlID09PSBTVEFURS5ST1RBVEUgKSB7XG5cblx0XHRcdGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblx0XHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcblxuXHRcdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuXHRcdFx0c2NvcGUucm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuXHRcdFx0c2NvcGUucm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHR9IGVsc2UgaWYgKCBzdGF0ZSA9PT0gU1RBVEUuRE9MTFkgKSB7XG5cblx0XHRcdGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0XHRkb2xseUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblx0XHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcblxuXHRcdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRcdHNjb3BlLmRvbGx5SW4oKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzY29wZS5kb2xseU91dCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHN0YXRlID09PSBTVEFURS5QQU4gKSB7XG5cblx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRcdHBhbkVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcblxuXHRcdFx0c2NvcGUucGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlVXAoIC8qIGV2ZW50ICovICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdGRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSB8fCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHR2YXIgZGVsdGEgPSAwO1xuXG5cdFx0aWYgKCBldmVudC53aGVlbERlbHRhICE9PSB1bmRlZmluZWQgKSB7IC8vIFdlYktpdCAvIE9wZXJhIC8gRXhwbG9yZXIgOVxuXG5cdFx0XHRkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGE7XG5cblx0XHR9IGVsc2UgaWYgKCBldmVudC5kZXRhaWwgIT09IHVuZGVmaW5lZCApIHsgLy8gRmlyZWZveFxuXG5cdFx0XHRkZWx0YSA9IC0gZXZlbnQuZGV0YWlsO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkZWx0YSA+IDAgKSB7XG5cblx0XHRcdHNjb3BlLmRvbGx5T3V0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzY29wZS5kb2xseUluKCk7XG5cblx0XHR9XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUubm9LZXlzID09PSB0cnVlIHx8IHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxuXHRcdFx0XHRzY29wZS5kb2xseU91dCgpO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5CT1RUT006XG5cdFx0XHRcdHNjb3BlLmRvbGx5SW4oKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuTEVGVDpcblx0XHRcdFx0dGhldGFEZWx0YSArPSAwLjE7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLlJJR0hUOlxuXHRcdFx0XHR0aGV0YURlbHRhIC09IDAuMTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0b3VjaHN0YXJ0KCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0Y2FzZSAxOlx0Ly8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG5cdFx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMjpcdC8vIHR3by1maW5nZXJlZCB0b3VjaDogZG9sbHlcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZO1xuXG5cdFx0XHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHRcdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cdFx0XHRcdGRvbGx5U3RhcnQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cblx0XHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcblxuXHRcdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSBzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRvdWNobW92ZSggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XG5cblx0XHRcdGNhc2UgMTogLy8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ST1RBVEUgKSByZXR1cm47XG5cblx0XHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xuXG5cdFx0XHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcblx0XHRcdFx0c2NvcGUucm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cdFx0XHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuXHRcdFx0XHRzY29wZS5yb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cblx0XHRcdFx0aWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX0RPTExZICkgcmV0dXJuO1xuXG5cdFx0XHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHRcdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cblx0XHRcdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXHRcdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cblx0XHRcdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRcdFx0c2NvcGUuZG9sbHlPdXQoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2NvcGUuZG9sbHlJbigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9QQU4gKSByZXR1cm47XG5cblx0XHRcdFx0cGFuRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRcdFx0cGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuXG5cdFx0XHRcdHNjb3BlLnBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0XHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHRvdWNoZW5kKCAvKiBldmVudCAqLyApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHR9XG5cblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIGZ1bmN0aW9uICggZXZlbnQgKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH0sIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V3aGVlbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UgKTtcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdET01Nb3VzZVNjcm9sbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UgKTsgLy8gZmlyZWZveFxuXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCB0b3VjaGVuZCwgZmFsc2UgKTtcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCB0b3VjaG1vdmUsIGZhbHNlICk7XG5cblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSApO1xuXG5cdC8vIGZvcmNlIGFuIHVwZGF0ZSBhdCBzdGFydFxuXHR0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5PcmJpdENvbnRyb2xzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTtcblRIUkVFLk9yYml0Q29udHJvbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuT3JiaXRDb250cm9scztcbiIsImltcG9ydCBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgJy4vbGliL09yYml0Q29udHJvbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0KCkge1xuICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICBjb25zdCBpbml0aWFsUmF0aW8gPSAzMDAgLyAxNTAwO1xuXG4gIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhdXRvQ2xlYXI6IHRydWUsIGFudGlhbGlhczogdHJ1ZSwgYWxwaGE6IHRydWUgfSk7XG4gIC8vIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhhYTAwMzMsIDEpO1xuICAvLyByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4YWEwMDMzLCAxKTtcbiAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweGZmZmZmZiwgMSk7XG4gIHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZTtcbiAgcmVuZGVyZXIuc2hhZG93TWFwLnNvZnQgPSB0cnVlO1xuICByZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gIC8vIHJlbmRlcmVyLnNvcnRPYmplY3RzID0gdHJ1ZTsgLT4gcG9zc2libHkgbmVjZXNzYXJ5IGZvciB0cmFuc3BhcmVudCB0ZXh0dXJlc1xuXG4gIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg1MCwgMSwgMSwgMTAwMDApO1xuICBjYW1lcmEucG9zaXRpb24ueiA9IDE1MDA7XG4gIGNhbWVyYS5wb3NpdGlvbi54ID0gMDtcbiAgY2FtZXJhLnBvc2l0aW9uLnkgPSAzMDA7XG4gIGNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkpO1xuXG4gIGNvbnN0IHNwb3QgPSBuZXcgVEhSRUUuU3BvdExpZ2h0KDB4ZmZmZmZmLCAxKTtcbiAgc3BvdC5wb3NpdGlvbi5zZXQoMzAwLCAzMDAsIDMwMCk7XG4gIHNwb3QudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgc3BvdC5zaGFkb3dDYW1lcmFOZWFyID0gMTtcbiAgc3BvdC5zaGFkb3dDYW1lcmFGYXIgPSAxMDI0O1xuICBzcG90LmNhc3RTaGFkb3cgPSB0cnVlO1xuICBzcG90LnNoYWRvd0RhcmtuZXNzID0gMC4zO1xuICBzcG90LnNoYWRvd0JpYXMgPSAwLjAwMDE7XG4gIHNwb3Quc2hhZG93TWFwV2lkdGggPSAyMDQ4O1xuICBzcG90LnNoYWRvd01hcEhlaWdodCA9IDIwNDg7XG4gIHNjZW5lLmFkZChzcG90KTtcblxuICBjb25zdCB3b3JsZCA9IG5ldyBUSFJFRS5NZXNoKFxuICAgIG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDEwMDAsIDEwMDAsIDEwLCAxMCksXG4gICAgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4MDAwMDAwLCB3aXJlZnJhbWU6IHRydWUgfSlcbiAgKTtcbiAgLy8gY29uc3Qgd29ybGQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgd29ybGQucm90YXRpb24ueCAtPSBNYXRoLlBJIC8gMjtcbiAgLy8gd29ybGQucm90YXRpb24ueCArPSBNYXRoLlBJIC8gMjtcbiAgLy8gd29ybGQucm90YXRpb24ueCArPSBNYXRoLlBJO1xuXG4gIHdvcmxkLm1hdGVyaWFsLnNpZGUgPSBUSFJFRS5Eb3VibGVTaWRlO1xuICB3b3JsZC5wb3NpdGlvbi55ID0gNTA7XG4gIHdvcmxkLnBvc2l0aW9uLnogPSA1MDtcbiAgd29ybGQucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gIHNjZW5lLmFkZCh3b3JsZCk7XG5cbiAgY29uc3QgbGlnaHQgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KDB4ZmZmZmZmLCAweDAwMDAwMCwgMC42KTtcbiAgc2NlbmUuYWRkKGxpZ2h0KTtcblxuICBjb25zdCBjb250cm9scyA9IG5ldyBUSFJFRS5PcmJpdENvbnRyb2xzKGNhbWVyYSwgcmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gIC8vIGNvbnRyb2xzLmtleXMgPSB7fTtcbiAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKGNhbWVyYS5wb3NpdGlvbiwgY2FtZXJhLmZvdik7XG4gICAgcmVuZGVyKCk7XG4gIH0pO1xuXG5cbiAgZnVuY3Rpb24gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBjb25zb2xlLmxvZyh3aWR0aCxoZWlnaHQpO1xuICAgIC8vIGNvbnN0IGRpc3RhbmNlO1xuICAgIC8vIGNvbnN0IGhlaWdodCA9IDIgKiBNYXRoLnRhbiggKCB2Rk9WIC8gMiApICkgKiBkaXN0YW5jZTtcbiAgICAvLyBjb25zdCB2Rk9WID0gMiAqIE1hdGguYXRhbihoZWlnaHQgLyAoMiAqIGRpc3RhbmNlKSk7XG4gICAgLy8gY29uc3QgZCA9IDQ7XG4gICAgLy8gY29uc3QgZiA9IDNcbiAgICAvLyBjb25zdCBoID0gMiAqIGYgKiBkOyAvLyAyNFxuICAgIC8vIGNvbnNvbGUubG9nKDI0IC8gMyAvIDIpO1xuXG4gICAgLy8gY29uc3QgaCA9IGhlaWdodDtcbiAgICAvLyBjb25zdCB2Rk9WID0gY2FtZXJhLmZvdjtcbiAgICAvLyBjb25zdCBhID0gTWF0aC50YW4odkZPViAvIDIpO1xuICAgIC8vIGNvbnN0IGRpc3RhbmNlID0gaCAvIGEgLyAyO1xuICAgIC8vIGNvbnNvbGUubG9nKGgsIHZGT1YsIGRpc3RhbmNlKTtcbiAgICAvLyBjb25zdCBmb2NhbExlbmd0aCA9IDI1LjczNDsgLy8gZXF1aXZhbGVudCB0byBGT1Y9NTBcbiAgICAvLyBjb25zdCBkaXN0YW5jZSA9IDEwMDAgLyBNYXRoLnRhbihjYW1lcmEuZm92IC8gZm9jYWxMZW5ndGgpO1xuXG4gICAgLy8gY29uc29sZS5sb2coZGlzdGFuY2UpO1xuXG4gICAgLypcbiAgICB0YW4gPSBvcHAgLyBhZGpcbiAgICB0YW4gPSB5IC8gelxuICAgIHogPSB5IC8gdGFuXG4gICAgeSA9IHogKiB0YW5cblxuXG4gICAgKi9cblxuICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIC8vIGNvbnN0IHZGT1YgPSBUSFJFRS5NYXRoLnJhZFRvRGVnKDIgKiBNYXRoLmF0YW4oTWF0aC50YW4oVEhSRUUuTWF0aC5kZWdUb1JhZChjYW1lcmEuZm92KSAqIDAuNSkgLyBjYW1lcmEuem9vbSkpO1xuICAgIC8vIGNvbnNvbGUubG9nKHZGT1YsIGNhbWVyYS5mb3YpO1xuICAgIGNvbnN0IHZGT1YgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKGNhbWVyYS5mb3YpO1xuICAgIGNvbnN0IGhGT1YgPSAyICogTWF0aC5hdGFuKE1hdGgudGFuKHZGT1YgLyAyKSAqIGFzcGVjdCk7XG5cblxuICAgIC8vIGNvbnN0IHZXaWR0aCA9IHdpZHRoO1xuICAgIC8vIGNvbnN0IHZIZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICBjb25zdCBkaXN0MSA9IGhlaWdodCAvIDIgLyAoTWF0aC50YW4odkZPViAvIDIpKTtcbiAgICBjb25zdCBkaXN0MiA9IGhlaWdodCAvIDIgLyAoTWF0aC50YW4oaEZPViAvIDIpKTtcbiAgICBjb25zdCBkaXN0ID0gd2lkdGggPiBoZWlnaHQgPyBkaXN0MiA6IGRpc3QxO1xuXG4gICAgLy8gZm92ID0gMiAqIE1hdGguYXRhbiggKCB3aWR0aCAvIGFzcGVjdCApIC8gKCAyICogZGlzdCApICkgKiAoIDE4MCAvIE1hdGguUEkgKTtcblxuICAgIC8vIGNhbWVyYS5mb3YgLyAyID0gKE1hdGguYXRhbihoZWlnaHQgLyAoMiAqIGRpc3QpKSk7IC8vICogKCAxODAgLyBNYXRoLlBJICk7XG5cbiAgICAvLyBUSFJFRS5NYXRoLnJhZFRvRGVnKChNYXRoLmF0YW4oaGVpZ2h0IC8gKDIgKiBkaXN0KSkpKSA9IDI1XG5cbiAgICAvLyBjb25zdCB2SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIC8vIGNvbnN0IHZIZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICAvLyBjb25zdCBkaXN0ID0gdkhlaWdodCAvIDIgLyAoTWF0aC50YW4odkZPViAvIDIpKTtcblxuXG4gICAgLy8gY29uc3QgZGlzdCA9IE1hdGguYWJzKHdpZHRoICogTWF0aC5zaW4oVEhSRUUuTWF0aC5kZWdUb1JhZChjYW1lcmEuZm92IC8gMikpKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKHZIZWlnaHQsIHZXaWR0aCwgZGlzdCk7XG4gICAgY29uc29sZS5sb2coZGlzdCwgY2FtZXJhLnBvc2l0aW9uKTtcbiAgICBjYW1lcmEucG9zaXRpb24ueiA9IGRpc3QgKyA1MDA7XG4gICAgY2FtZXJhLnBvc2l0aW9uLnkgPSBjYW1lcmEucG9zaXRpb24ueiAqIGluaXRpYWxSYXRpbztcblxuXG4gICAgLy8gY2FtZXJhLnBvc2l0aW9uLnogPSBkaXN0YW5jZTtcbiAgICBjYW1lcmEuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJlbmRlcigpO1xuICB9XG5cblxuICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgY29uc3QgdkZPViA9IGNhbWVyYS5mb3YgKiAoTWF0aC5QSSAvIDE4MCk7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICBjb25zdCB2SGVpZ2h0ID0gMiAqIE1hdGgudGFuKHZGT1YgLyAyKSAqIChjYW1lcmEucG9zaXRpb24ueiAtIDUwMCk7IC8vIHZpc2libGUgaGVpZ2h0XG4gICAgY29uc3QgdldpZHRoID0gdkhlaWdodCAqIGNhbWVyYS5hc3BlY3Q7IC8vIHZpc2libGUgd2lkdGhcblxuICAgIC8vIGNvbnNvbGUubG9nKCdXJywgdldpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgLy8gY29uc29sZS5sb2coJ0gnLCB2SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuXG4gICAgY29uc3Qgb3Bwb3NpdGUgPSBjYW1lcmEucG9zaXRpb24ueTtcbiAgICBjb25zdCBhZGphY2VudCA9IGNhbWVyYS5wb3NpdGlvbi56O1xuICAgIGNvbnN0IHJhdGlvID0gb3Bwb3NpdGUgLyBhZGphY2VudDtcbiAgICAvLyBjb25zb2xlLmxvZyhvcHBvc2l0ZSwgYWRqYWNlbnQpO1xuICAgIC8vIGNvbnNvbGUubG9nKHJhdGlvLCBNYXRoLnRhbihUSFJFRS5NYXRoLmRlZ1RvUmFkKDUwKSkpO1xuICAgIC8vIGNvbnNvbGUubG9nKHJhdGlvLCBpbml0aWFsUmF0aW8pO1xuXG4gICAgLy8gY29uc29sZS5sb2coJy0tJyk7XG5cbiAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gIH1cblxuXG4gIHJldHVybiB7XG4gICAgcmVuZGVyLFxuICAgIHJlc2l6ZSxcbiAgICBkb21FbGVtZW50OiByZW5kZXJlci5kb21FbGVtZW50LFxuICB9O1xufVxuIiwidmFyIHNlbGYgPSBzZWxmIHx8IHt9Oy8vIEZpbGU6c3JjL1RocmVlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG52YXIgVEhSRUUgPSB7IFJFVklTSU9OOiAnNzMnIH07XHJcblxyXG4vL1xyXG5cclxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblxyXG5cdFx0ZGVmaW5lKCAndGhyZWUnLCBUSFJFRSApO1xyXG5cclxufSBlbHNlIGlmICggJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBleHBvcnRzICYmICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlICkge1xyXG5cclxuXHRcdG1vZHVsZS5leHBvcnRzID0gVEhSRUU7XHJcblxyXG59XHJcblxyXG5cclxuLy8gcG9seWZpbGxzXHJcblxyXG5pZiAoIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgfHwgc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBNaXNzaW5nIGluIEFuZHJvaWQgc3RvY2sgYnJvd3Nlci5cclxuXHJcblx0KCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGxhc3RUaW1lID0gMDtcclxuXHRcdHZhciB2ZW5kb3JzID0gWyAnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJyBdO1xyXG5cclxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICEgc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsrIHggKSB7XHJcblxyXG5cdFx0XHRzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHNlbGZbIHZlbmRvcnNbIHggXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XHJcblx0XHRcdHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnIF0gfHwgc2VsZlsgdmVuZG9yc1sgeCBdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuc2V0VGltZW91dCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY3VyclRpbWUgPSBEYXRlLm5vdygpLCB0aW1lVG9DYWxsID0gTWF0aC5tYXgoIDAsIDE2IC0gKCBjdXJyVGltZSAtIGxhc3RUaW1lICkgKTtcclxuXHRcdFx0XHR2YXIgaWQgPSBzZWxmLnNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XHJcblxyXG5cdFx0XHRcdH0sIHRpbWVUb0NhbGwgKTtcclxuXHRcdFx0XHRsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcclxuXHRcdFx0XHRyZXR1cm4gaWQ7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCAmJiBzZWxmLmNsZWFyVGltZW91dCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICggaWQgKSB7XHJcblxyXG5cdFx0XHRcdHNlbGYuY2xlYXJUaW1lb3V0KCBpZCApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKSgpO1xyXG5cclxufVxyXG5cclxuLy9cclxuXHJcbmlmICggc2VsZi5wZXJmb3JtYW5jZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRzZWxmLnBlcmZvcm1hbmNlID0ge307XHJcblxyXG59XHJcblxyXG5pZiAoIHNlbGYucGVyZm9ybWFuY2Uubm93ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdCggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcblxyXG5cdFx0c2VsZi5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gRGF0ZS5ub3coKSAtIHN0YXJ0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApKCk7XHJcblxyXG59XHJcblxyXG4vL1xyXG5cclxuaWYgKCBOdW1iZXIuRVBTSUxPTiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHROdW1iZXIuRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtNTIgKTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5pZiAoIE1hdGguc2lnbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cclxuXHJcblx0TWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHggPCAwICkgPyAtIDEgOiAoIHggPiAwICkgPyAxIDogKyB4O1xyXG5cclxuXHR9O1xyXG5cclxufVxyXG5cclxuaWYgKCBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBNaXNzaW5nIGluIElFOS0xMS5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCkubWF0Y2goIC9eXFxzKmZ1bmN0aW9uXFxzKihcXFMqKVxccypcXCgvIClbIDEgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcbn1cclxuXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50LmJ1dHRvblxyXG5cclxuVEhSRUUuTU9VU0UgPSB7IExFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDIgfTtcclxuXHJcbi8vIEdMIFNUQVRFIENPTlNUQU5UU1xyXG5cclxuVEhSRUUuQ3VsbEZhY2VOb25lID0gMDtcclxuVEhSRUUuQ3VsbEZhY2VCYWNrID0gMTtcclxuVEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XHJcblRIUkVFLkN1bGxGYWNlRnJvbnRCYWNrID0gMztcclxuXHJcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcclxuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gMTtcclxuXHJcbi8vIFNIQURPV0lORyBUWVBFU1xyXG5cclxuVEhSRUUuQmFzaWNTaGFkb3dNYXAgPSAwO1xyXG5USFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xyXG5USFJFRS5QQ0ZTb2Z0U2hhZG93TWFwID0gMjtcclxuXHJcbi8vIE1BVEVSSUFMIENPTlNUQU5UU1xyXG5cclxuLy8gc2lkZVxyXG5cclxuVEhSRUUuRnJvbnRTaWRlID0gMDtcclxuVEhSRUUuQmFja1NpZGUgPSAxO1xyXG5USFJFRS5Eb3VibGVTaWRlID0gMjtcclxuXHJcbi8vIHNoYWRpbmdcclxuXHJcblRIUkVFLkZsYXRTaGFkaW5nID0gMTtcclxuVEhSRUUuU21vb3RoU2hhZGluZyA9IDI7XHJcblxyXG4vLyBjb2xvcnNcclxuXHJcblRIUkVFLk5vQ29sb3JzID0gMDtcclxuVEhSRUUuRmFjZUNvbG9ycyA9IDE7XHJcblRIUkVFLlZlcnRleENvbG9ycyA9IDI7XHJcblxyXG4vLyBibGVuZGluZyBtb2Rlc1xyXG5cclxuVEhSRUUuTm9CbGVuZGluZyA9IDA7XHJcblRIUkVFLk5vcm1hbEJsZW5kaW5nID0gMTtcclxuVEhSRUUuQWRkaXRpdmVCbGVuZGluZyA9IDI7XHJcblRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xyXG5USFJFRS5NdWx0aXBseUJsZW5kaW5nID0gNDtcclxuVEhSRUUuQ3VzdG9tQmxlbmRpbmcgPSA1O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIGVxdWF0aW9uc1xyXG4vLyAobnVtYmVycyBzdGFydCBmcm9tIDEwMCBub3QgdG8gY2xhc2ggd2l0aCBvdGhlclxyXG4vLyBtYXBwaW5ncyB0byBPcGVuR0wgY29uc3RhbnRzIGRlZmluZWQgaW4gVGV4dHVyZS5qcylcclxuXHJcblRIUkVFLkFkZEVxdWF0aW9uID0gMTAwO1xyXG5USFJFRS5TdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xyXG5USFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcclxuVEhSRUUuTWluRXF1YXRpb24gPSAxMDM7XHJcblRIUkVFLk1heEVxdWF0aW9uID0gMTA0O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIGRlc3RpbmF0aW9uIGZhY3RvcnNcclxuXHJcblRIUkVFLlplcm9GYWN0b3IgPSAyMDA7XHJcblRIUkVFLk9uZUZhY3RvciA9IDIwMTtcclxuVEhSRUUuU3JjQ29sb3JGYWN0b3IgPSAyMDI7XHJcblRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XHJcblRIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xyXG5USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xyXG5USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcclxuVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcclxuXHJcbi8vIGN1c3RvbSBibGVuZGluZyBzb3VyY2UgZmFjdG9yc1xyXG5cclxuLy9USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xyXG4vL1RIUkVFLk9uZUZhY3RvciA9IDIwMTtcclxuLy9USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcclxuLy9USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xyXG4vL1RIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xyXG4vL1RIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XHJcblRIUkVFLkRzdENvbG9yRmFjdG9yID0gMjA4O1xyXG5USFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xyXG5USFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xyXG5cclxuLy8gZGVwdGggbW9kZXNcclxuXHJcblRIUkVFLk5ldmVyRGVwdGggPSAwO1xyXG5USFJFRS5BbHdheXNEZXB0aCA9IDE7XHJcblRIUkVFLkxlc3NEZXB0aCA9IDI7XHJcblRIUkVFLkxlc3NFcXVhbERlcHRoID0gMztcclxuVEhSRUUuRXF1YWxEZXB0aCA9IDQ7XHJcblRIUkVFLkdyZWF0ZXJFcXVhbERlcHRoID0gNTtcclxuVEhSRUUuR3JlYXRlckRlcHRoID0gNjtcclxuVEhSRUUuTm90RXF1YWxEZXB0aCA9IDc7XHJcblxyXG5cclxuLy8gVEVYVFVSRSBDT05TVEFOVFNcclxuXHJcblRIUkVFLk11bHRpcGx5T3BlcmF0aW9uID0gMDtcclxuVEhSRUUuTWl4T3BlcmF0aW9uID0gMTtcclxuVEhSRUUuQWRkT3BlcmF0aW9uID0gMjtcclxuXHJcbi8vIE1hcHBpbmcgbW9kZXNcclxuXHJcblRIUkVFLlVWTWFwcGluZyA9IDMwMDtcclxuXHJcblRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcclxuVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xyXG5cclxuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XHJcblRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xyXG5cclxuVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDU7XHJcblxyXG4vLyBXcmFwcGluZyBtb2Rlc1xyXG5cclxuVEhSRUUuUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xyXG5USFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcclxuVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XHJcblxyXG4vLyBGaWx0ZXJzXHJcblxyXG5USFJFRS5OZWFyZXN0RmlsdGVyID0gMTAwMztcclxuVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xyXG5USFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcclxuVEhSRUUuTGluZWFyRmlsdGVyID0gMTAwNjtcclxuVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XHJcblRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XHJcblxyXG4vLyBEYXRhIHR5cGVzXHJcblxyXG5USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcclxuVEhSRUUuQnl0ZVR5cGUgPSAxMDEwO1xyXG5USFJFRS5TaG9ydFR5cGUgPSAxMDExO1xyXG5USFJFRS5VbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XHJcblRIUkVFLkludFR5cGUgPSAxMDEzO1xyXG5USFJFRS5VbnNpZ25lZEludFR5cGUgPSAxMDE0O1xyXG5USFJFRS5GbG9hdFR5cGUgPSAxMDE1O1xyXG5USFJFRS5IYWxmRmxvYXRUeXBlID0gMTAyNTtcclxuXHJcbi8vIFBpeGVsIHR5cGVzXHJcblxyXG4vL1RIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xyXG5USFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE2O1xyXG5USFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE3O1xyXG5USFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSA9IDEwMTg7XHJcblxyXG4vLyBQaXhlbCBmb3JtYXRzXHJcblxyXG5USFJFRS5BbHBoYUZvcm1hdCA9IDEwMTk7XHJcblRIUkVFLlJHQkZvcm1hdCA9IDEwMjA7XHJcblRIUkVFLlJHQkFGb3JtYXQgPSAxMDIxO1xyXG5USFJFRS5MdW1pbmFuY2VGb3JtYXQgPSAxMDIyO1xyXG5USFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjM7XHJcbi8vIFRIUkVFLlJHQkVGb3JtYXQgaGFuZGxlZCBhcyBUSFJFRS5SR0JBRm9ybWF0IGluIHNoYWRlcnNcclxuVEhSRUUuUkdCRUZvcm1hdCA9IFRIUkVFLlJHQkFGb3JtYXQ7IC8vMTAyNDtcclxuXHJcbi8vIEREUyAvIFNUM0MgQ29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcclxuXHJcblRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMTtcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMjtcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMjAwMztcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMjAwNDtcclxuXHJcblxyXG4vLyBQVlJUQyBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xyXG5cclxuVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAwO1xyXG5USFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDE7XHJcblRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XHJcblRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDM7XHJcblxyXG4vLyBMb29wIHN0eWxlcyBmb3IgQW5pbWF0aW9uQWN0aW9uXHJcblxyXG5USFJFRS5Mb29wT25jZSA9IDIyMDA7XHJcblRIUkVFLkxvb3BSZXBlYXQgPSAyMjAxO1xyXG5USFJFRS5Mb29wUGluZ1BvbmcgPSAyMjAyO1xyXG5cclxuLy8gREVQUkVDQVRFRFxyXG5cclxuVEhSRUUuUHJvamVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvUHJvamVjdG9yLmpzLicgKTtcclxuXHJcblx0dGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci5wcm9qZWN0KCkuJyApO1xyXG5cdFx0dmVjdG9yLnByb2plY3QoIGNhbWVyYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XHJcblx0XHR2ZWN0b3IudW5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5waWNraW5nUmF5ID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yOiAucGlja2luZ1JheSgpIGlzIG5vdyByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSgpLicgKTtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9Db2xvci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBhcmd1bWVudHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcy5zZXQoIGNvbG9yICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29sb3IucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQ29sb3IsXHJcblxyXG5cdHI6IDEsIGc6IDEsIGI6IDEsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvcHkoIHZhbHVlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldFN0eWxlKCB2YWx1ZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcclxuXHJcblx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcclxuXHJcblx0XHR0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xyXG5cdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xyXG5cdFx0dGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gcjtcclxuXHRcdHRoaXMuZyA9IGc7XHJcblx0XHR0aGlzLmIgPSBiO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcclxuXHRcdFx0aWYgKCB0ID4gMSApIHQgLT0gMTtcclxuXHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xyXG5cdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xyXG5cdFx0XHRpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XHJcblx0XHRcdHJldHVybiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuXHRcdFx0aCA9IFRIUkVFLk1hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XHJcblx0XHRcdHMgPSBUSFJFRS5NYXRoLmNsYW1wKCBzLCAwLCAxICk7XHJcblx0XHRcdGwgPSBUSFJFRS5NYXRoLmNsYW1wKCBsLCAwLCAxICk7XHJcblxyXG5cdFx0XHRpZiAoIHMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xyXG5cdFx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcclxuXHJcblx0XHRcdFx0dGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XHJcblx0XHRcdFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xyXG5cdFx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVBbHBoYSggc3RyaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHZhciBtO1xyXG5cclxuXHRcdGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIHJnYiAvIGhzbFxyXG5cclxuXHRcdFx0dmFyIGNvbG9yO1xyXG5cdFx0XHR2YXIgbmFtZSA9IG1bIDEgXTtcclxuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdyZ2InOlxyXG5cdFx0XHRcdGNhc2UgJ3JnYmEnOlxyXG5cclxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcclxuXHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcclxuXHJcblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJnYigxMDAlLDAlLDAlKSByZ2JhKDEwMCUsMCUsMCUsMC41KVxyXG5cdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMTAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaHNsJzpcclxuXHRcdFx0XHRjYXNlICdoc2xhJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcclxuXHRcdFx0XHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XHJcblx0XHRcdFx0XHRcdHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XHJcblx0XHRcdFx0XHRcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XHJcblxyXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIGhleCBjb2xvclxyXG5cclxuXHRcdFx0dmFyIGhleCA9IG1bIDEgXTtcclxuXHRcdFx0dmFyIHNpemUgPSBoZXgubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBzaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHQvLyAjZmYwXHJcblx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xyXG5cdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAyICksIDE2ICkgLyAyNTU7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0Ly8gI2ZmMDAwMFxyXG5cdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XHJcblx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDMgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggNCApICsgaGV4LmNoYXJBdCggNSApLCAxNiApIC8gMjU1O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcclxuXHRcdFx0dmFyIGhleCA9IFRIUkVFLkNvbG9yS2V5d29yZHNbIHN0eWxlIF07XHJcblxyXG5cdFx0XHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyByZWRcclxuXHRcdFx0XHR0aGlzLnNldEhleCggaGV4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyB1bmtub3duIGNvbG9yXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iID0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xyXG5cclxuXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuXHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XHJcblx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xyXG5cclxuXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuXHRcdHZhciBzYWZlSW52ZXJzZSA9ICggZ2FtbWFGYWN0b3IgPiAwICkgPyAoIDEuMCAvIGdhbW1hRmFjdG9yICkgOiAxLjA7XHJcblxyXG5cdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XHJcblx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuXHRcdHRoaXMuciA9IHIgKiByO1xyXG5cdFx0dGhpcy5nID0gZyAqIGc7XHJcblx0XHR0aGlzLmIgPSBiICogYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhleDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cclxuXHRcdHZhciBoc2wgPSBvcHRpb25hbFRhcmdldCB8fCB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcclxuXHJcblx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcclxuXHJcblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcclxuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xyXG5cclxuXHRcdHZhciBodWUsIHNhdHVyYXRpb247XHJcblx0XHR2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcclxuXHJcblx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xyXG5cclxuXHRcdFx0aHVlID0gMDtcclxuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcclxuXHJcblx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG1heCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aHVlIC89IDY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGhzbC5oID0gaHVlO1xyXG5cdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xyXG5cdFx0aHNsLmwgPSBsaWdodG5lc3M7XHJcblxyXG5cdFx0cmV0dXJuIGhzbDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvZmZzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcclxuXHJcblx0XHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcclxuXHJcblx0XHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xyXG5cclxuXHRcdHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gY29sb3IucjtcclxuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iICs9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xyXG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciArPSBzO1xyXG5cdFx0dGhpcy5nICs9IHM7XHJcblx0XHR0aGlzLmIgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgKj0gY29sb3IuZztcclxuXHRcdHRoaXMuYiAqPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciAqPSBzO1xyXG5cdFx0dGhpcy5nICo9IHM7XHJcblx0XHR0aGlzLmIgKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XHJcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcclxuXHRcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcclxuJ2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxyXG4nYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXHJcbidjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxyXG4nZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcclxuJ2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcclxuJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcclxuJ2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXHJcbidmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxyXG4nZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXHJcbidpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXHJcbidsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXHJcbidsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxyXG4nbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxyXG4nbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXHJcbidtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcclxuJ21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXHJcbiduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXHJcbidwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxyXG4ncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxyXG4ncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcclxuJ3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXHJcbidzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXHJcbid2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1F1YXRlcm5pb24uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0dGhpcy5feSA9IHkgfHwgMDtcclxuXHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5RdWF0ZXJuaW9uLFxyXG5cclxuXHRnZXQgeCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHogKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl96O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgdyAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB3ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5fdyA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0dGhpcy5feSA9IHk7XHJcblx0XHR0aGlzLl96ID0gejtcclxuXHRcdHRoaXMuX3cgPSB3O1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcclxuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XHJcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xyXG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0aWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xyXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcclxuXHRcdHZhciBjMiA9IE1hdGguY29zKCBldWxlci5feSAvIDIgKTtcclxuXHRcdHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcclxuXHRcdHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcclxuXHRcdHZhciBzMiA9IE1hdGguc2luKCBldWxlci5feSAvIDIgKTtcclxuXHRcdHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcclxuXHJcblx0XHR2YXIgb3JkZXIgPSBldWxlci5vcmRlcjtcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xyXG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XHJcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcclxuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXHJcblxyXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcclxuXHRcdFx0cztcclxuXHJcblx0XHRpZiAoIHRyYWNlID4gMCApIHtcclxuXHJcblx0XHRcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcclxuXHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcclxuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcclxuXHJcblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgdjEsIHI7XHJcblxyXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZGcm9tLCB2VG8gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XHJcblxyXG5cdFx0XHRpZiAoIHIgPCBFUFMgKSB7XHJcblxyXG5cdFx0XHRcdHIgPSAwO1xyXG5cclxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xyXG5cclxuXHRcdFx0XHRcdHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gdjEueDtcclxuXHRcdFx0dGhpcy5feSA9IHYxLnk7XHJcblx0XHRcdHRoaXMuX3ogPSB2MS56O1xyXG5cdFx0XHR0aGlzLl93ID0gcjtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW52ZXJzZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29uanVnYXRlKCkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbmp1Z2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX3ggKj0gLSAxO1xyXG5cdFx0dGhpcy5feSAqPSAtIDE7XHJcblx0XHR0aGlzLl96ICo9IC0gMTtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdGlmICggbCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSAwO1xyXG5cdFx0XHR0aGlzLl95ID0gMDtcclxuXHRcdFx0dGhpcy5feiA9IDA7XHJcblx0XHRcdHRoaXMuX3cgPSAxO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRsID0gMSAvIGw7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XHJcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcclxuXHRcdFx0dGhpcy5feiA9IHRoaXMuX3ogKiBsO1xyXG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBxLCBwICkge1xyXG5cclxuXHRcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCBwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxyXG5cclxuXHRcdHZhciBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xyXG5cdFx0dmFyIHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XHJcblxyXG5cdFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcclxuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XHJcblx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xyXG5cdFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcclxuXHJcblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcclxuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXHJcblxyXG5cdFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcclxuXHJcblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcclxuXHRcdFx0dGhpcy5feCA9IC0gcWIuX3g7XHJcblx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xyXG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcclxuXHJcblx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSB3O1xyXG5cdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0dGhpcy5feSA9IHk7XHJcblx0XHRcdHRoaXMuX3ogPSB6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoIGNvc0hhbGZUaGV0YSApO1xyXG5cdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XHJcblx0XHRcdHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XHJcblx0XHRcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcclxuXHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XHJcblxyXG5cdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcclxuXHRcdHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xyXG5cdFx0dGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHRcdHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uLnNsZXJwID0gZnVuY3Rpb24gKCBxYSwgcWIsIHFtLCB0ICkge1xyXG5cclxuXHRyZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yMiA9IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0dGhpcy54ID0geCB8fCAwO1xyXG5cdHRoaXMueSA9IHkgfHwgMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3IyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjIsXHJcblxyXG5cdGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMueCB9LFxyXG5cdHNldCB3aWR0aCggdmFsdWUgKSB7IHRoaXMueCA9IHZhbHVlIH0sXHJcblxyXG5cdGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLnkgfSxcclxuXHRzZXQgaGVpZ2h0KCB2YWx1ZSApIHsgdGhpcy55ID0gdmFsdWUgfSxcclxuXHJcblx0Ly9cclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2Lng7XHJcblx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XHJcblx0XHR0aGlzLnkgKz0gdi55ICogcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gcztcclxuXHRcdHRoaXMueSAtPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSB2Lng7XHJcblx0XHR0aGlzLnkgKj0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0aWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XHJcblx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggLz0gdi54O1xyXG5cdFx0dGhpcy55IC89IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApIC8gbGVuZ3RoICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XHJcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcclxuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCAtIGNlbnRlci54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcclxuXHJcblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XHJcblx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yICpraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHR0aGlzLnggPSB4IHx8IDA7XHJcblx0dGhpcy55ID0geSB8fCAwO1xyXG5cdHRoaXMueiA9IHogfHwgMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3IzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XHJcblxyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHRcdHRoaXMueiA9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHR0aGlzLnkgKz0gdi55O1xyXG5cdFx0dGhpcy56ICs9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHRcdHRoaXMueiArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gdi54ICogcztcclxuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xyXG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHRcdHRoaXMueiAtPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAtPSBzO1xyXG5cdFx0dGhpcy55IC09IHM7XHJcblx0XHR0aGlzLnogLT0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICo9IHYueDtcclxuXHRcdHRoaXMueSAqPSB2Lnk7XHJcblx0XHR0aGlzLnogKj0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0aWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XHJcblx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMueiAqPSBzY2FsYXI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLnogPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKiBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5RXVsZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcXVhdGVybmlvbjtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueDtcclxuXHRcdHZhciB5ID0gdGhpcy55O1xyXG5cdFx0dmFyIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcclxuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHogKyBlWyAxMyBdO1xyXG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IHByb2plY3Rpb24gbWF0cml4XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcclxuXHJcblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHogKyBlWyAxMiBdICkgKiBkO1xyXG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXSApICogZDtcclxuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIGQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnk7XHJcblx0XHR2YXIgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgcXggPSBxLng7XHJcblx0XHR2YXIgcXkgPSBxLnk7XHJcblx0XHR2YXIgcXogPSBxLno7XHJcblx0XHR2YXIgcXcgPSBxLnc7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcclxuXHJcblx0XHR2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xyXG5cdFx0dmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcclxuXHRcdHZhciBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XHJcblx0XHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcclxuXHJcblx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XHJcblxyXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcclxuXHRcdHRoaXMueSA9IGl5ICogcXcgKyBpdyAqIC0gcXkgKyBpeiAqIC0gcXggLSBpeCAqIC0gcXo7XHJcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdCggY2FtZXJhICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XHJcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xyXG5cclxuXHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0dGhpcy56IC89IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSAvIGxlbmd0aCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcclxuXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xyXG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xyXG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XHJcblxyXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XHJcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcclxuXHRcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEsIGRvdDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uVmVjdG9yKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGRvdCA9IHRoaXMuZG90KCB2MSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0djEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxyXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xyXG5cclxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgZHggPSB0aGlzLnggLSB2Lng7XHJcblx0XHR2YXIgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcblx0XHR2YXIgZHogPSB0aGlzLnogLSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxLCBvcmRlciApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29sdW1uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBpbmRleCwgbWF0cml4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHRoaXMueCA9IG0uZWxlbWVudHNbIDEyIF07XHJcblx0XHR0aGlzLnkgPSBtLmVsZW1lbnRzWyAxMyBdO1xyXG5cdFx0dGhpcy56ID0gbS5lbGVtZW50c1sgMTQgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU1hdHJpeFNjYWxlOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHN4ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDAgXSwgbS5lbGVtZW50c1sgMSBdLCBtLmVsZW1lbnRzWyAyIF0gKS5sZW5ndGgoKTtcclxuXHRcdHZhciBzeSA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA0IF0sIG0uZWxlbWVudHNbIDUgXSwgbS5lbGVtZW50c1sgNiBdICkubGVuZ3RoKCk7XHJcblx0XHR2YXIgc3ogPSB0aGlzLnNldCggbS5lbGVtZW50c1sgOCBdLCBtLmVsZW1lbnRzWyA5IF0sIG0uZWxlbWVudHNbIDEwIF0gKS5sZW5ndGgoKTtcclxuXHJcblx0XHR0aGlzLnggPSBzeDtcclxuXHRcdHRoaXMueSA9IHN5O1xyXG5cdFx0dGhpcy56ID0gc3o7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xyXG5cclxuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBtZVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBtZVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gbWVbIG9mZnNldCArIDIgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xyXG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcclxuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XHJcblx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3I0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yNCA9IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0dGhpcy54ID0geCB8fCAwO1xyXG5cdHRoaXMueSA9IHkgfHwgMDtcclxuXHR0aGlzLnogPSB6IHx8IDA7XHJcblx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcjQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yNCxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblx0XHR0aGlzLnogPSB6O1xyXG5cdFx0dGhpcy53ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XHJcblxyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VzogZnVuY3Rpb24gKCB3ICkge1xyXG5cclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHRcdHRoaXMueiA9IHYuejtcclxuXHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHRcdHRoaXMueiArPSB2Lno7XHJcblx0XHR0aGlzLncgKz0gdi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gcztcclxuXHRcdHRoaXMueSArPSBzO1xyXG5cdFx0dGhpcy56ICs9IHM7XHJcblx0XHR0aGlzLncgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiArIGIuejtcclxuXHRcdHRoaXMudyA9IGEudyArIGIudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XHJcblx0XHR0aGlzLnkgKz0gdi55ICogcztcclxuXHRcdHRoaXMueiArPSB2LnogKiBzO1xyXG5cdFx0dGhpcy53ICs9IHYudyAqIHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHRcdHRoaXMueiAtPSB2Lno7XHJcblx0XHR0aGlzLncgLT0gdi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gcztcclxuXHRcdHRoaXMueSAtPSBzO1xyXG5cdFx0dGhpcy56IC09IHM7XHJcblx0XHR0aGlzLncgLT0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcclxuXHRcdHRoaXMudyA9IGEudyAtIGIudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xyXG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLncgKj0gc2NhbGFyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy56ID0gMDtcclxuXHRcdFx0dGhpcy53ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLng7XHJcblx0XHR2YXIgeSA9IHRoaXMueTtcclxuXHRcdHZhciB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIHcgPSB0aGlzLnc7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xyXG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XHJcblx0XHR0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcclxuXHJcblx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xyXG5cclxuXHRcdGlmICggcyA8IDAuMDAwMSApIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSAxO1xyXG5cdFx0XHQgdGhpcy55ID0gMDtcclxuXHRcdFx0IHRoaXMueiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSBxLnggLyBzO1xyXG5cdFx0XHQgdGhpcy55ID0gcS55IC8gcztcclxuXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciBhbmdsZSwgeCwgeSwgeixcdFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcclxuXHRcdFx0ZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXHJcblx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xyXG5cclxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XHJcblxyXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKVxyXG5cdFx0ICAgJiYgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uIClcclxuXHRcdCAgICYmICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xyXG5cclxuXHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcclxuXHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xyXG5cdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXHJcblxyXG5cdFx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKVxyXG5cdFx0XHQgICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAgJiYgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApXHJcblx0XHRcdCAgICYmICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxyXG5cclxuXHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXHJcblxyXG5cdFx0XHRhbmdsZSA9IE1hdGguUEk7XHJcblxyXG5cdFx0XHR2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XHJcblx0XHRcdHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcclxuXHRcdFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xyXG5cdFx0XHR2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcclxuXHRcdFx0dmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XHJcblx0XHRcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xyXG5cclxuXHRcdFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0aWYgKCB4eCA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDA7XHJcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcclxuXHRcdFx0XHRcdHkgPSB4eSAvIHg7XHJcblx0XHRcdFx0XHR6ID0geHogLyB4O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB5eSA+IHp6ICkge1xyXG5cclxuXHRcdFx0XHQvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxyXG5cclxuXHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR5ID0gMDtcclxuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xyXG5cdFx0XHRcdFx0eCA9IHh5IC8geTtcclxuXHRcdFx0XHRcdHogPSB5eiAvIHk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcclxuXHJcblx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eiA9IDA7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eiA9IE1hdGguc3FydCggenogKTtcclxuXHRcdFx0XHRcdHggPSB4eiAvIHo7XHJcblx0XHRcdFx0XHR5ID0geXogLyB6O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XHJcblxyXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApXHJcblx0XHRcdFx0XHRcdCAgKyAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKVxyXG5cdFx0XHRcdFx0XHQgICsgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xyXG5cclxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcclxuXHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxyXG5cclxuXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG5cdFx0dGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcblx0XHR0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHRcdHRoaXMudyA9IC0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHRcdHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcclxuXHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAzIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0V1bGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5FdWxlciA9IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0dGhpcy5feSA9IHkgfHwgMDtcclxuXHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XHJcblxyXG5USFJFRS5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcclxuXHJcblRIUkVFLkV1bGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkV1bGVyLFxyXG5cclxuXHRnZXQgeCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHogKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl96O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgb3JkZXIgKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9vcmRlcjtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG9yZGVyICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHg7XHJcblx0XHR0aGlzLl95ID0geTtcclxuXHRcdHRoaXMuX3ogPSB6O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XHJcblx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XHJcblx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XHJcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0dmFyIGNsYW1wID0gVEhSRUUuTWF0aC5jbGFtcDtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHM7XHJcblx0XHR2YXIgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXTtcclxuXHRcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xyXG5cdFx0dmFyIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xyXG5cclxuXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XHJcblxyXG5cdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gMDtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyIClcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcclxuXHJcblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWF0cml4O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHEsIG9yZGVyLCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHRcdFx0bWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcblx0XHRcdHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZW9yZGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxyXG5cclxuXHRcdHZhciBxID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBuZXdPcmRlciApIHtcclxuXHJcblx0XHRcdHEuc2V0RnJvbUV1bGVyKCB0aGlzICk7XHJcblx0XHRcdHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIHEsIG5ld09yZGVyICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggZXVsZXIuX3ggPT09IHRoaXMuX3ggKSAmJiAoIGV1bGVyLl95ID09PSB0aGlzLl95ICkgJiYgKCBldWxlci5feiA9PT0gdGhpcy5feiApICYmICggZXVsZXIuX29yZGVyID09PSB0aGlzLl9vcmRlciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IGFycmF5WyAwIF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xyXG5cdFx0aWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XHJcblxyXG5cdFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcclxuXHJcblx0XHRcdHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0xpbmUzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLkxpbmUzID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xyXG5cclxuXHR0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5lbmQgPSAoIGVuZCAhPT0gdW5kZWZpbmVkICkgPyBlbmQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmUzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkxpbmUzLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0LmNvcHkoIHN0YXJ0ICk7XHJcblx0XHR0aGlzLmVuZC5jb3B5KCBlbmQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggbGluZSApIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuXHRcdHRoaXMuZW5kLmNvcHkoIGxpbmUuZW5kICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgc3RhcnRQID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBzdGFydEVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lICkge1xyXG5cclxuXHRcdFx0c3RhcnRQLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLnN0YXJ0ICk7XHJcblx0XHRcdHN0YXJ0RW5kLnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdFx0XHR2YXIgc3RhcnRFbmQyID0gc3RhcnRFbmQuZG90KCBzdGFydEVuZCApO1xyXG5cdFx0XHR2YXIgc3RhcnRFbmRfc3RhcnRQID0gc3RhcnRFbmQuZG90KCBzdGFydFAgKTtcclxuXHJcblx0XHRcdHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xyXG5cclxuXHRcdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcclxuXHJcblx0XHRcdFx0dCA9IFRIUkVFLk1hdGguY2xhbXAoIHQsIDAsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblx0XHR0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggbGluZSApIHtcclxuXHJcblx0XHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0JveDIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuQm94MiA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xyXG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3gyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkJveDIsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XHJcblx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHRcclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IEluZmluaXR5O1xyXG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtIEluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0ICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcclxuXHRcdCAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcclxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoXHJcblx0XHRcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcclxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXHJcblx0XHQpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXHJcblxyXG5cdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdCAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcclxuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5Cb3gzID0gZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMyggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xyXG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3gzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkJveDMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xyXG5cclxuXHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcclxuXHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzWyAncG9zaXRpb24nIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyAncG9zaXRpb24nIF0uYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxLnNldCggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSBJbmZpbml0eTtcclxuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0ICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0ICAgICBwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxyXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcclxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXHJcblx0XHQpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXHJcblxyXG5cdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdCAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XHJcblx0XHQgICAgIGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRcdFx0cmVzdWx0LmNlbnRlciA9IHRoaXMuY2VudGVyKCk7XHJcblx0XHRcdHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKVxyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xyXG5cdFx0XHRwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcclxuXHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXHJcblx0XHRcdHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxyXG5cdFx0XHRwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcclxuXHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXHJcblx0XHRcdHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxyXG5cdFx0XHRwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcclxuXHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgIC8vIDExMVxyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcblxyXG5cdFx0MSwgMCwgMCxcclxuXHRcdDAsIDEsIDAsXHJcblx0XHQwLCAwLCAxXHJcblxyXG5cdF0gKTtcclxuXHJcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDMgXSA9IG4xMjsgdGVbIDYgXSA9IG4xMztcclxuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA0IF0gPSBuMjI7IHRlWyA3IF0gPSBuMjM7XHJcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNSBdID0gbjMyOyB0ZVsgOCBdID0gbjMzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcclxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSxcclxuXHRcdFx0bWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xyXG5cclxuXHRcdFx0XHR2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XHJcblx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcblx0XHRcdFx0djEudG9BcnJheSggYXJyYXksIGogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArKywgaiArKyApIHtcclxuXHJcblx0XHRcdFx0djEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XHJcblx0XHRcdFx0djEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XHJcblx0XHRcdFx0djEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XHJcblxyXG5cdFx0XHRcdHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xyXG5cclxuXHRcdFx0XHRidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVmZmVyO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XHJcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xyXG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA4IF0gKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxyXG5cdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxyXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbWF0cml4LCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxyXG5cdFx0Ly8gKCBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2ViZ2wtbWpzLyApXHJcblxyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdID0gICBtZVsgMTAgXSAqIG1lWyA1IF0gLSBtZVsgNiBdICogbWVbIDkgXTtcclxuXHRcdHRlWyAxIF0gPSAtIG1lWyAxMCBdICogbWVbIDEgXSArIG1lWyAyIF0gKiBtZVsgOSBdO1xyXG5cdFx0dGVbIDIgXSA9ICAgbWVbIDYgXSAqIG1lWyAxIF0gLSBtZVsgMiBdICogbWVbIDUgXTtcclxuXHRcdHRlWyAzIF0gPSAtIG1lWyAxMCBdICogbWVbIDQgXSArIG1lWyA2IF0gKiBtZVsgOCBdO1xyXG5cdFx0dGVbIDQgXSA9ICAgbWVbIDEwIF0gKiBtZVsgMCBdIC0gbWVbIDIgXSAqIG1lWyA4IF07XHJcblx0XHR0ZVsgNSBdID0gLSBtZVsgNiBdICogbWVbIDAgXSArIG1lWyAyIF0gKiBtZVsgNCBdO1xyXG5cdFx0dGVbIDYgXSA9ICAgbWVbIDkgXSAqIG1lWyA0IF0gLSBtZVsgNSBdICogbWVbIDggXTtcclxuXHRcdHRlWyA3IF0gPSAtIG1lWyA5IF0gKiBtZVsgMCBdICsgbWVbIDEgXSAqIG1lWyA4IF07XHJcblx0XHR0ZVsgOCBdID0gICBtZVsgNSBdICogbWVbIDAgXSAtIG1lWyAxIF0gKiBtZVsgNCBdO1xyXG5cclxuXHRcdHZhciBkZXQgPSBtZVsgMCBdICogdGVbIDAgXSArIG1lWyAxIF0gKiB0ZVsgMyBdICsgbWVbIDIgXSAqIHRlWyA2IF07XHJcblxyXG5cdFx0Ly8gbm8gaW52ZXJzZVxyXG5cclxuXHRcdGlmICggZGV0ID09PSAwICkge1xyXG5cclxuXHRcdFx0dmFyIG1zZyA9IFwiTWF0cml4My5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcclxuXHJcblx0XHRcdGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5pZGVudGl0eSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIDEuMCAvIGRldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xyXG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcclxuXHRcdHRtcCA9IG1bIDUgXTsgbVsgNSBdID0gbVsgNyBdOyBtWyA3IF0gPSB0bXA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gID0gdGVbIDggXTtcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE5vcm1hbE1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XHJcblxyXG5cdFx0dGhpcy5nZXRJbnZlcnNlKCBtICkudHJhbnNwb3NlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24gKCByICkge1xyXG5cclxuXHRcdHZhciBtID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRyWyAwIF0gPSBtWyAwIF07XHJcblx0XHRyWyAxIF0gPSBtWyAzIF07XHJcblx0XHRyWyAyIF0gPSBtWyA2IF07XHJcblx0XHRyWyAzIF0gPSBtWyAxIF07XHJcblx0XHRyWyA0IF0gPSBtWyA0IF07XHJcblx0XHRyWyA1IF0gPSBtWyA3IF07XHJcblx0XHRyWyA2IF0gPSBtWyAyIF07XHJcblx0XHRyWyA3IF0gPSBtWyA1IF07XHJcblx0XHRyWyA4IF0gPSBtWyA4IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0dGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSxcclxuXHRcdFx0dGVbIDMgXSwgdGVbIDQgXSwgdGVbIDUgXSxcclxuXHRcdFx0dGVbIDYgXSwgdGVbIDcgXSwgdGVbIDggXVxyXG5cdFx0XTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4NC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cclxuICogQGF1dGhvciBEMXBsbzFkIC8gaHR0cDovL2dpdGh1Yi5jb20vRDFwbG8xZFxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHRpbWtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuTWF0cml4NCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHJcblx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0MCwgMSwgMCwgMCxcclxuXHRcdDAsIDAsIDEsIDAsXHJcblx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdF0gKTtcclxuXHJcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDQsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcclxuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xyXG5cdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xyXG5cdFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5NYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR0aGlzLmVsZW1lbnRzLnNldCggbS5lbGVtZW50cyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHRyYWN0UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuY29weVBvc2l0aW9uKCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XHJcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xyXG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR4QXhpcy5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKTtcclxuXHRcdHlBeGlzLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xyXG5cdFx0ekF4aXMuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcclxuXHRcdFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcclxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcclxuXHRcdFx0MCwgICAgICAgMCwgICAgICAgMCwgICAgICAgMVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWyAwIF0sIG1lWyAxIF0sIG1lWyAyIF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXQoIG1lWyA0IF0sIG1lWyA1IF0sIG1lWyA2IF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcclxuXHRcdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XHJcblx0XHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xyXG5cclxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XHJcblx0XHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xyXG5cdFx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcclxuXHJcblx0XHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xyXG5cdFx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcclxuXHRcdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcclxuXHRcdHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xyXG5cdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcclxuXHJcblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBjICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGQ7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XHJcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XHJcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcclxuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcclxuXHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xyXG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYSAqIGY7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYjtcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcclxuXHRcdFx0dGVbIDYgXSA9IGRmICsgY2UgKiBiO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBhICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcclxuXHJcblx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xyXG5cdFx0XHR0ZVsgNiBdID0gYjtcclxuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xyXG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYyAqIGY7XHJcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcclxuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcclxuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XHJcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBmO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XHJcblx0XHRcdHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcclxuXHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0dGVbIDQgXSA9IC0gZjtcclxuXHRcdFx0dGVbIDggXSA9IGQgKiBlO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcclxuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBsYXN0IGNvbHVtblxyXG5cdFx0dGVbIDMgXSA9IDA7XHJcblx0XHR0ZVsgNyBdID0gMDtcclxuXHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHQvLyBib3R0b20gcm93XHJcblx0XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMTQgXSA9IDA7XHJcblx0XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcclxuXHRcdHZhciB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xyXG5cdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XHJcblx0XHR2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MjtcclxuXHRcdHZhciB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xyXG5cclxuXHRcdHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XHJcblx0XHR0ZVsgNCBdID0geHkgLSB3ejtcclxuXHRcdHRlWyA4IF0gPSB4eiArIHd5O1xyXG5cclxuXHRcdHRlWyAxIF0gPSB4eSArIHd6O1xyXG5cdFx0dGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcclxuXHRcdHRlWyA5IF0gPSB5eiAtIHd4O1xyXG5cclxuXHRcdHRlWyAyIF0gPSB4eiAtIHd5O1xyXG5cdFx0dGVbIDYgXSA9IHl6ICsgd3g7XHJcblx0XHR0ZVsgMTAgXSA9IDEgLSAoIHh4ICsgeXkgKTtcclxuXHJcblx0XHQvLyBsYXN0IGNvbHVtblxyXG5cdFx0dGVbIDMgXSA9IDA7XHJcblx0XHR0ZVsgNyBdID0gMDtcclxuXHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHQvLyBib3R0b20gcm93XHJcblx0XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMTQgXSA9IDA7XHJcblx0XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB4LCB5LCB6O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcclxuXHJcblx0XHRcdGlmICggeCA9PT0gdW5kZWZpbmVkICkgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggeSA9PT0gdW5kZWZpbmVkICkgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0ei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0aWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHoueiA9IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGlmICggeC5sZW5ndGhTcSgpID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR6LnggKz0gMC4wMDAxO1xyXG5cdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcclxuXHJcblxyXG5cdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xyXG5cdFx0XHR0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xyXG5cdFx0XHR0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xyXG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xyXG5cdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcclxuXHRcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XHJcblxyXG5cdFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xyXG5cdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xyXG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcclxuXHRcdHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XHJcblxyXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XHJcblx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xyXG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcclxuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG5cdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcclxuXHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcclxuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xyXG5cclxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xyXG5cdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XHJcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcclxuXHJcblx0XHRyWyAwIF0gPSB0ZVsgMCBdOyByWyAxIF0gPSB0ZVsgMSBdOyByWyAyIF0gPSB0ZVsgMiBdOyByWyAzIF0gPSB0ZVsgMyBdO1xyXG5cdFx0clsgNCBdID0gdGVbIDQgXTsgclsgNSBdID0gdGVbIDUgXTsgclsgNiBdID0gdGVbIDYgXTsgclsgNyBdID0gdGVbIDcgXTtcclxuXHRcdHJbIDggXSAgPSB0ZVsgOCBdOyByWyA5IF0gID0gdGVbIDkgXTsgclsgMTAgXSA9IHRlWyAxMCBdOyByWyAxMSBdID0gdGVbIDExIF07XHJcblx0XHRyWyAxMiBdID0gdGVbIDEyIF07IHJbIDEzIF0gPSB0ZVsgMTMgXTsgclsgMTQgXSA9IHRlWyAxNCBdOyByWyAxNSBdID0gdGVbIDE1IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xyXG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcclxuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xyXG5cdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBvciB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xyXG5cclxuXHRcdFx0XHR2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XHJcblx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcblx0XHRcdFx0djEudG9BcnJheSggYXJyYXksIGogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArKywgaiArKyApIHtcclxuXHJcblx0XHRcdFx0djEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XHJcblx0XHRcdFx0djEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XHJcblx0XHRcdFx0djEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XHJcblxyXG5cdFx0XHRcdHYxLmFwcGx5TWF0cml4NCggdGhpcyApO1xyXG5cclxuXHRcdFx0XHRidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVmZmVyO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcclxuXHRcdHZhciBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcclxuXHRcdHZhciBuMzEgPSB0ZVsgMiBdLCBuMzIgPSB0ZVsgNiBdLCBuMzMgPSB0ZVsgMTAgXSwgbjM0ID0gdGVbIDE0IF07XHJcblx0XHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xyXG5cclxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XHJcblx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcclxuXHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHRuNDEgKiAoXHJcblx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcclxuXHRcdFx0XHQgLSBuMTMgKiBuMjQgKiBuMzJcclxuXHRcdFx0XHQgLSBuMTQgKiBuMjIgKiBuMzNcclxuXHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcclxuXHRcdFx0XHQgKyBuMTMgKiBuMjIgKiBuMzRcclxuXHRcdFx0XHQgLSBuMTIgKiBuMjMgKiBuMzRcclxuXHRcdFx0KSArXHJcblx0XHRcdG40MiAqIChcclxuXHRcdFx0XHQrIG4xMSAqIG4yMyAqIG4zNFxyXG5cdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xyXG5cdFx0XHRcdCArIG4xNCAqIG4yMSAqIG4zM1xyXG5cdFx0XHRcdCAtIG4xMyAqIG4yMSAqIG4zNFxyXG5cdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMyAqIG4zMVxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQzICogKFxyXG5cdFx0XHRcdCsgbjExICogbjI0ICogbjMyXHJcblx0XHRcdFx0IC0gbjExICogbjIyICogbjM0XHJcblx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXHJcblx0XHRcdFx0ICsgbjEyICogbjIxICogbjM0XHJcblx0XHRcdFx0ICsgbjE0ICogbjIyICogbjMxXHJcblx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXHJcblx0XHRcdCkgK1xyXG5cdFx0XHRuNDQgKiAoXHJcblx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcclxuXHRcdFx0XHQgLSBuMTEgKiBuMjMgKiBuMzJcclxuXHRcdFx0XHQgKyBuMTEgKiBuMjIgKiBuMzNcclxuXHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcclxuXHRcdFx0XHQgLSBuMTIgKiBuMjEgKiBuMzNcclxuXHRcdFx0XHQgKyBuMTIgKiBuMjMgKiBuMzFcclxuXHRcdFx0KVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdG1wO1xyXG5cclxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbIDIgXTsgdGVbIDIgXSA9IHRlWyA4IF07IHRlWyA4IF0gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcclxuXHJcblx0XHR0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDkgXSAgPSB0ZVsgOSBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEwIF0gPSB0ZVsgMTAgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEyIF0gPSB0ZVsgMTIgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDE1IF0gPSB0ZVsgMTUgXTtcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHRyZXR1cm4gdjEuc2V0KCB0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDEyIF0gPSB2Lng7XHJcblx0XHR0ZVsgMTMgXSA9IHYueTtcclxuXHRcdHRlWyAxNCBdID0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG0sIHRocm93T25JbnZlcnRpYmxlICkge1xyXG5cclxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIG4xMSA9IG1lWyAwIF0sIG4xMiA9IG1lWyA0IF0sIG4xMyA9IG1lWyA4IF0sIG4xNCA9IG1lWyAxMiBdO1xyXG5cdFx0dmFyIG4yMSA9IG1lWyAxIF0sIG4yMiA9IG1lWyA1IF0sIG4yMyA9IG1lWyA5IF0sIG4yNCA9IG1lWyAxMyBdO1xyXG5cdFx0dmFyIG4zMSA9IG1lWyAyIF0sIG4zMiA9IG1lWyA2IF0sIG4zMyA9IG1lWyAxMCBdLCBuMzQgPSBtZVsgMTQgXTtcclxuXHRcdHZhciBuNDEgPSBtZVsgMyBdLCBuNDIgPSBtZVsgNyBdLCBuNDMgPSBtZVsgMTEgXSwgbjQ0ID0gbWVbIDE1IF07XHJcblxyXG5cdFx0dGVbIDAgXSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NDtcclxuXHRcdHRlWyA0IF0gPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQ7XHJcblx0XHR0ZVsgOCBdID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0O1xyXG5cdFx0dGVbIDEyIF0gPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XHJcblx0XHR0ZVsgMSBdID0gbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0O1xyXG5cdFx0dGVbIDUgXSA9IG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NDtcclxuXHRcdHRlWyA5IF0gPSBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQ7XHJcblx0XHR0ZVsgMTMgXSA9IG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNDtcclxuXHRcdHRlWyAyIF0gPSBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQ7XHJcblx0XHR0ZVsgNiBdID0gbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0O1xyXG5cdFx0dGVbIDEwIF0gPSBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQ7XHJcblx0XHR0ZVsgMTQgXSA9IG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNDtcclxuXHRcdHRlWyAzIF0gPSBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDM7XHJcblx0XHR0ZVsgNyBdID0gbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzO1xyXG5cdFx0dGVbIDExIF0gPSBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDM7XHJcblx0XHR0ZVsgMTUgXSA9IG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMztcclxuXHJcblx0XHR2YXIgZGV0ID0gbjExICogdGVbIDAgXSArIG4yMSAqIHRlWyA0IF0gKyBuMzEgKiB0ZVsgOCBdICsgbjQxICogdGVbIDEyIF07XHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXg0LmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuXHRcdFx0aWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlkZW50aXR5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMSAvIGRldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVYOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVZOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVCeUF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XHJcblxyXG5cdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcclxuXHRcdHRlWyAxIF0gKj0geDsgdGVbIDUgXSAqPSB5OyB0ZVsgOSBdICo9IHo7XHJcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcclxuXHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRNYXhTY2FsZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xyXG5cdFx0dmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xyXG5cdFx0dmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsIDAsIHgsXHJcblx0XHRcdDAsIDEsIDAsIHksXHJcblx0XHRcdDAsIDAsIDEsIHosXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsICAwLCAwLFxyXG5cdFx0XHQwLCBjLCAtIHMsIDAsXHJcblx0XHRcdDAsIHMsICBjLCAwLFxyXG5cdFx0XHQwLCAwLCAgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0IGMsIDAsIHMsIDAsXHJcblx0XHRcdCAwLCAxLCAwLCAwLFxyXG5cdFx0XHQtIHMsIDAsIGMsIDAsXHJcblx0XHRcdCAwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRjLCAtIHMsIDAsIDAsXHJcblx0XHRcdHMsICBjLCAwLCAwLFxyXG5cdFx0XHQwLCAgMCwgMSwgMCxcclxuXHRcdFx0MCwgIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xyXG5cdFx0dmFyIHQgPSAxIC0gYztcclxuXHRcdHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xyXG5cdFx0dmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHR0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXHJcblx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcclxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHQgcmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0eCwgMCwgMCwgMCxcclxuXHRcdFx0MCwgeSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgeiwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xyXG5cclxuXHRcdHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHRcdHRoaXMuc2NhbGUoIHNjYWxlICk7XHJcblx0XHR0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVjdG9yLCBtYXRyaXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xyXG5cclxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRcdHZhciBzeCA9IHZlY3Rvci5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHN5ID0gdmVjdG9yLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xyXG5cdFx0XHR2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xyXG5cclxuXHRcdFx0Ly8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcclxuXHRcdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcclxuXHRcdFx0aWYgKCBkZXQgPCAwICkge1xyXG5cclxuXHRcdFx0XHRzeCA9IC0gc3g7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XHJcblx0XHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcclxuXHRcdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xyXG5cclxuXHRcdFx0Ly8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50cy5zZXQoIHRoaXMuZWxlbWVudHMgKTsgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxyXG5cclxuXHRcdFx0dmFyIGludlNYID0gMSAvIHN4O1xyXG5cdFx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XHJcblx0XHRcdHZhciBpbnZTWiA9IDEgLyBzejtcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDEgXSAqPSBpbnZTWDtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNiBdICo9IGludlNZO1xyXG5cclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XHJcblxyXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHRzY2FsZS54ID0gc3g7XHJcblx0XHRcdHNjYWxlLnkgPSBzeTtcclxuXHRcdFx0c2NhbGUueiA9IHN6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcclxuXHJcblx0XHR2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xyXG5cdFx0dmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcclxuXHRcdHZhciBjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xyXG5cdFx0dmFyIGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XHJcblxyXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhO1x0dGVbIDEyIF0gPSAwO1xyXG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiO1x0dGVbIDEzIF0gPSAwO1xyXG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gYztcdHRlWyAxNCBdID0gZDtcclxuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dmFyIHltYXggPSBuZWFyICogTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICk7XHJcblx0XHR2YXIgeW1pbiA9IC0geW1heDtcclxuXHRcdHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcclxuXHRcdHZhciB4bWF4ID0geW1heCAqIGFzcGVjdDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tYWtlRnJ1c3R1bSggeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VPcnRob2dyYXBoaWM6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB3ID0gcmlnaHQgLSBsZWZ0O1xyXG5cdFx0dmFyIGggPSB0b3AgLSBib3R0b207XHJcblx0XHR2YXIgcCA9IGZhciAtIG5lYXI7XHJcblxyXG5cdFx0dmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApIC8gdztcclxuXHRcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAvIGg7XHJcblx0XHR2YXIgeiA9ICggZmFyICsgbmVhciApIC8gcDtcclxuXHJcblx0XHR0ZVsgMCBdID0gMiAvIHc7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSAwO1x0dGVbIDEyIF0gPSAtIHg7XHJcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSAyIC8gaDtcdHRlWyA5IF0gPSAwO1x0dGVbIDEzIF0gPSAtIHk7XHJcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSAtIDIgLyBwO1x0dGVbIDE0IF0gPSAtIHo7XHJcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAwO1x0dGVbIDE1IF0gPSAxO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0sIHRlWyAzIF0sXHJcblx0XHRcdHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0sIHRlWyA3IF0sXHJcblx0XHRcdHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdLCB0ZVsgMTEgXSxcclxuXHRcdFx0dGVbIDEyIF0sIHRlWyAxMyBdLCB0ZVsgMTQgXSwgdGVbIDE1IF1cclxuXHRcdF07XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1JheS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5SYXkgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuXHR0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlJheS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5SYXksXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCByYXkgKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggcmF5Lm9yaWdpbiApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlY2FzdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHRcdHRoaXMub3JpZ2luLmNvcHkoIHRoaXMuYXQoIHQsIHYxICkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XHJcblx0XHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSByZXN1bHQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVNxVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB2MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxyXG5cclxuXHRcdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHYxLmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHYxLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0ZGlzdGFuY2VTcVRvU2VnbWVudDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBzZWdDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHNlZ0RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XHJcblxyXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0Rpc3RhbmNlL1dtNURpc3RSYXkzU2VnbWVudDMuY3BwXHJcblx0XHRcdC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XHJcblx0XHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXHJcblx0XHRcdC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XHJcblx0XHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxyXG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XHJcblxyXG5cdFx0XHRzZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0XHRzZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XHJcblx0XHRcdGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xyXG5cclxuXHRcdFx0dmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XHJcblx0XHRcdHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XHJcblx0XHRcdHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cdFx0XHR2YXIgYjEgPSAtIGRpZmYuZG90KCBzZWdEaXIgKTtcclxuXHRcdFx0dmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XHJcblx0XHRcdHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xyXG5cdFx0XHR2YXIgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XHJcblxyXG5cdFx0XHRpZiAoIGRldCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cclxuXHJcblx0XHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xyXG5cdFx0XHRcdHMxID0gYTAxICogYjAgLSBiMTtcclxuXHRcdFx0XHRleHREZXQgPSBzZWdFeHRlbnQgKiBkZXQ7XHJcblxyXG5cdFx0XHRcdGlmICggczAgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHMxID49IC0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBzMSA8PSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAwXHJcblx0XHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgaW52RGV0ID0gMSAvIGRldDtcclxuXHRcdFx0XHRcdFx0XHRzMCAqPSBpbnZEZXQ7XHJcblx0XHRcdFx0XHRcdFx0czEgKj0gaW52RGV0O1xyXG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMVxyXG5cclxuXHRcdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcclxuXHRcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDVcclxuXHJcblx0XHRcdFx0XHRcdHMxID0gLSBzZWdFeHRlbnQ7XHJcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzMSA8PSAtIGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA0XHJcblxyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggLSBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XHJcblx0XHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IC0gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gM1xyXG5cclxuXHRcdFx0XHRcdFx0czAgPSAwO1xyXG5cdFx0XHRcdFx0XHRzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAyXHJcblxyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cclxuXHJcblx0XHRcdFx0czEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xyXG5cdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcclxuXHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XHJcblxyXG5cdFx0XHRcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcclxuXHJcblx0XHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBzZWdEaXIgKS5tdWx0aXBseVNjYWxhciggczEgKS5hZGQoIHNlZ0NlbnRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHNxckRpc3Q7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHJcblx0aXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9IHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5zY3JhdGNoYXBpeGVsLmNvbS9sZXNzb25zLzNkLWJhc2ljLWxlc3NvbnMvbGVzc29uLTctaW50ZXJzZWN0aW5nLXNpbXBsZS1zaGFwZXMvcmF5LXNwaGVyZS1pbnRlcnNlY3Rpb24vXHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0djEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRcdHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0XHR2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XHJcblxyXG5cdFx0XHR2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xyXG5cclxuXHRcdFx0Ly8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcclxuXHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xyXG5cclxuXHRcdFx0Ly8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxyXG5cdFx0XHR2YXIgdDEgPSB0Y2EgKyB0aGM7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcclxuXHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcclxuXHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxyXG5cdFx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXHJcblx0XHRcdGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIHQwLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSgpLFxyXG5cclxuXHRpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcclxuXHJcblx0XHR2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdGlmICggZGVub21pbmF0b3IgKiBkaXN0VG9Qb2ludCA8IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG5cdFx0XHRpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcclxuXHJcblx0XHQvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxyXG5cclxuXHRcdHJldHVybiB0ID49IDAgPyB0IDogIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xyXG5cclxuXHRcdGlmICggdCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdEJveDogZnVuY3Rpb24gKCBib3gsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuc2NyYXRjaGFwaXhlbC5jb20vbGVzc29ucy8zZC1iYXNpYy1sZXNzb25zL2xlc3Nvbi03LWludGVyc2VjdGluZy1zaW1wbGUtc2hhcGVzL3JheS1ib3gtaW50ZXJzZWN0aW9uL1xyXG5cclxuXHRcdHZhciB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcclxuXHJcblx0XHR2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxyXG5cdFx0XHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXHJcblx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcclxuXHJcblx0XHR2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XHJcblxyXG5cdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XHJcblxyXG5cdFx0XHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRtaW4gPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cdFx0XHR0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XHJcblxyXG5cdFx0XHR0eW1pbiA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cdFx0XHR0eW1heCA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0Ly8gVGhlc2UgbGluZXMgYWxzbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdG1pbiBvciB0bWF4IGlzIE5hTlxyXG5cdFx0Ly8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxyXG5cclxuXHRcdGlmICggdHltaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHltaW47XHJcblxyXG5cdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcclxuXHJcblx0XHRpZiAoIGludmRpcnogPj0gMCApIHtcclxuXHJcblx0XHRcdHR6bWluID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHRcdFx0dHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblx0XHRcdHR6bWF4ID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRpZiAoIHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR6bWluO1xyXG5cclxuXHRcdGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XHJcblxyXG5cdFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxyXG5cclxuXHRcdGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZSB0aGUgb2Zmc2V0IG9yaWdpbiwgZWRnZXMsIGFuZCBub3JtYWwuXHJcblx0XHR2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgZWRnZTEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIGVkZ2UyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIGJhY2tmYWNlQ3VsbGluZywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0ludGVyc2VjdGlvbi9XbTVJbnRyUmF5M1RyaWFuZ2xlMy5jcHBcclxuXHJcblx0XHRcdGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcclxuXHRcdFx0ZWRnZTIuc3ViVmVjdG9ycyggYywgYSApO1xyXG5cdFx0XHRub3JtYWwuY3Jvc3NWZWN0b3JzKCBlZGdlMSwgZWRnZTIgKTtcclxuXHJcblx0XHRcdC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxyXG5cdFx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XHJcblx0XHRcdC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxyXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcclxuXHRcdFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcclxuXHRcdFx0dmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XHJcblx0XHRcdHZhciBzaWduO1xyXG5cclxuXHRcdFx0aWYgKCBEZE4gPiAwICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGJhY2tmYWNlQ3VsbGluZyApIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdHNpZ24gPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggRGROIDwgMCApIHtcclxuXHJcblx0XHRcdFx0c2lnbiA9IC0gMTtcclxuXHRcdFx0XHREZE4gPSAtIERkTjtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGlmZi5zdWJWZWN0b3JzKCB0aGlzLm9yaWdpbiwgYSApO1xyXG5cdFx0XHR2YXIgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTIuY3Jvc3NWZWN0b3JzKCBkaWZmLCBlZGdlMiApICk7XHJcblxyXG5cdFx0XHQvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxyXG5cdFx0XHRpZiAoIERkUXhFMiA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcclxuXHJcblx0XHRcdC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRFMXhRIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxyXG5cdFx0XHRpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxyXG5cdFx0XHR2YXIgUWROID0gLSBzaWduICogZGlmZi5kb3QoIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxyXG5cdFx0XHRpZiAoIFFkTiA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXHJcblx0XHRcdHJldHVybiB0aGlzLmF0KCBRZE4gLyBEZE4sIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcclxuXHJcblx0XHR0aGlzLmRpcmVjdGlvbi5hZGQoIHRoaXMub3JpZ2luICkuYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XHJcblx0XHR0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcmF5ICkge1xyXG5cclxuXHRcdHJldHVybiByYXkub3JpZ2luLmVxdWFscyggdGhpcy5vcmlnaW4gKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvU3BoZXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwaGVyZSA9IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG5cdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BoZXJlLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlNwaGVyZSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xyXG5cclxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludHMsIG9wdGlvbmFsQ2VudGVyICkge1xyXG5cclxuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xyXG5cclxuXHRcdFx0aWYgKCBvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGJveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5jZW50ZXIoIGNlbnRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJlc3VsdC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xyXG5cclxuXHRcdFx0cmVzdWx0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGJveCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XHJcblx0XHRib3guZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XHJcblxyXG5cdFx0cmV0dXJuIGJveDtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvRnJ1c3R1bS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5GcnVzdHVtID0gZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xyXG5cclxuXHR0aGlzLnBsYW5lcyA9IFtcclxuXHJcblx0XHQoIHAwICE9PSB1bmRlZmluZWQgKSA/IHAwIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHAzICE9PSB1bmRlZmluZWQgKSA/IHAzIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFRIUkVFLlBsYW5lKClcclxuXHJcblx0XTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GcnVzdHVtLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkZydXN0dW0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcblx0XHRwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xyXG5cdFx0cGxhbmVzWyAxIF0uY29weSggcDEgKTtcclxuXHRcdHBsYW5lc1sgMiBdLmNvcHkoIHAyICk7XHJcblx0XHRwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xyXG5cdFx0cGxhbmVzWyA0IF0uY29weSggcDQgKTtcclxuXHRcdHBsYW5lc1sgNSBdLmNvcHkoIHA1ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHRcdHZhciBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xyXG5cdFx0dmFyIG1lNCA9IG1lWyA0IF0sIG1lNSA9IG1lWyA1IF0sIG1lNiA9IG1lWyA2IF0sIG1lNyA9IG1lWyA3IF07XHJcblx0XHR2YXIgbWU4ID0gbWVbIDggXSwgbWU5ID0gbWVbIDkgXSwgbWUxMCA9IG1lWyAxMCBdLCBtZTExID0gbWVbIDExIF07XHJcblx0XHR2YXIgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xyXG5cclxuXHRcdHBsYW5lc1sgMCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgMyBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMyApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHRcdHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xyXG5cdFx0dmFyIG5lZ1JhZGl1cyA9IC0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNiA7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwbGFuZSA9IHBsYW5lc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRwMS54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1pbi54IDogYm94Lm1heC54O1xyXG5cdFx0XHRcdHAyLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWF4LnggOiBib3gubWluLng7XHJcblx0XHRcdFx0cDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcclxuXHRcdFx0XHRwMi55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xyXG5cdFx0XHRcdHAxLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWluLnogOiBib3gubWF4Lno7XHJcblx0XHRcdFx0cDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcclxuXHJcblx0XHRcdFx0dmFyIGQxID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMSApO1xyXG5cdFx0XHRcdHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcclxuXHJcblx0XHRcdFx0Ly8gaWYgYm90aCBvdXRzaWRlIHBsYW5lLCBubyBpbnRlcnNlY3Rpb25cclxuXHJcblx0XHRcdFx0aWYgKCBkMSA8IDAgJiYgZDIgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvUGxhbmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuUGxhbmUgPSBmdW5jdGlvbiAoIG5vcm1hbCwgY29uc3RhbnQgKSB7XHJcblxyXG5cdHRoaXMubm9ybWFsID0gKCBub3JtYWwgIT09IHVuZGVmaW5lZCApID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcclxuXHR0aGlzLmNvbnN0YW50ID0gKCBjb25zdGFudCAhPT0gdW5kZWZpbmVkICkgPyBjb25zdGFudCA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGxhbmUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUGxhbmUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggbm9ybWFsLCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTtcdC8vIG11c3QgYmUgdGhpcy5ub3JtYWwsIG5vdCBub3JtYWwsIGFzIHRoaXMubm9ybWFsIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUNvcGxhbmFyUG9pbnRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdHZhciBub3JtYWwgPSB2MS5zdWJWZWN0b3JzKCBjLCBiICkuY3Jvc3MoIHYyLnN1YlZlY3RvcnMoIGEsIGIgKSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Ly8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cclxuXHJcblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXHJcblxyXG5cdFx0dmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcclxuXHRcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29uc3RhbnQgKj0gLSAxO1xyXG5cdFx0dGhpcy5ub3JtYWwubmVnYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub3JtYWwuZG90KCBwb2ludCApICsgdGhpcy5jb25zdGFudDtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgLSBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm9ydGhvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApLnN1YiggcG9pbnQgKS5uZWdhdGUoKTtcclxuXHJcblx0fSxcclxuXHJcblx0b3J0aG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggcGVycGVuZGljdWxhck1hZ25pdHVkZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0ludGVyc2VjdGlvbkxpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcclxuXHJcblx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cclxuXHJcblx0XHR2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcclxuXHRcdHZhciBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XHJcblxyXG5cdFx0cmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIHYxICk7XHJcblxyXG5cdFx0XHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG5cdFx0XHRcdGlmICggdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cclxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHQgPSAtICggbGluZS5zdGFydC5kb3QoIHRoaXMubm9ybWFsICkgKyB0aGlzLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcclxuXHJcblx0XHRcdGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHJcblx0Y29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4ICkge1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSBuZXcgbm9ybWFsIGJhc2VkIG9uIHRoZW9yeSBoZXJlOlxyXG5cdFx0XHQvLyBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfbm9ybWFsdHJhbnNmb3JtLmh0bWxcclxuXHRcdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IG0xLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblx0XHRcdHZhciBuZXdOb3JtYWwgPSB2MS5jb3B5KCB0aGlzLm5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICk7XHJcblxyXG5cdFx0XHR2YXIgbmV3Q29wbGFuYXJQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjIgKTtcclxuXHRcdFx0bmV3Q29wbGFuYXJQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbmV3Tm9ybWFsLCBuZXdDb3BsYW5hclBvaW50ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5jb25zdGFudCA9IHRoaXMuY29uc3RhbnQgLSBvZmZzZXQuZG90KCB0aGlzLm5vcm1hbCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9NYXRoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRoID0ge1xyXG5cclxuXHRnZW5lcmF0ZVVVSUQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmJyb29mYS5jb20vVG9vbHMvTWF0aC51dWlkLmh0bVxyXG5cclxuXHRcdHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoICcnICk7XHJcblx0XHR2YXIgdXVpZCA9IG5ldyBBcnJheSggMzYgKTtcclxuXHRcdHZhciBybmQgPSAwLCByO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpID09PSA4IHx8IGkgPT09IDEzIHx8IGkgPT09IDE4IHx8IGkgPT09IDIzICkge1xyXG5cclxuXHRcdFx0XHRcdHV1aWRbIGkgXSA9ICctJztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggaSA9PT0gMTQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gJzQnO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XHJcblx0XHRcdFx0XHRyID0gcm5kICYgMHhmO1xyXG5cdFx0XHRcdFx0cm5kID0gcm5kID4+IDQ7XHJcblx0XHRcdFx0XHR1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1dWlkLmpvaW4oICcnICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbHVlICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXHJcblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxyXG5cclxuXHRldWNsaWRlYW5Nb2R1bG86IGZ1bmN0aW9uICggbiwgbSApIHtcclxuXHJcblx0XHRyZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XHJcblxyXG5cdG1hcExpbmVhcjogZnVuY3Rpb24gKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcclxuXHJcblx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXHJcblxyXG5cdHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xyXG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xyXG5cclxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcclxuXHJcblx0fSxcclxuXHJcblx0c21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcclxuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcclxuXHJcblx0XHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xyXG5cclxuXHRcdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwwLCAxPiB3aXRoIDE2IGJpdHMgb2YgcmFuZG9tbmVzc1xyXG5cdC8vIChzdGFuZGFyZCBNYXRoLnJhbmRvbSgpIGNyZWF0ZXMgcmVwZXRpdGl2ZSBwYXR0ZXJucyB3aGVuIGFwcGxpZWQgb3ZlciBsYXJnZXIgc3BhY2UpXHJcblxyXG5cdHJhbmRvbTE2OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggNjUyODAgKiBNYXRoLnJhbmRvbSgpICsgMjU1ICogTWF0aC5yYW5kb20oKSApIC8gNjU1MzU7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEZsb2F0OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcblx0XHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXHJcblxyXG5cdHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGVnVG9SYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGVncmVlVG9SYWRpYW5zRmFjdG9yID0gTWF0aC5QSSAvIDE4MDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkZWdyZWVzICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGRlZ3JlZXMgKiBkZWdyZWVUb1JhZGlhbnNGYWN0b3I7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciByYWRpYW5Ub0RlZ3JlZXNGYWN0b3IgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHJhZGlhbnMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmFkaWFucyAqIHJhZGlhblRvRGVncmVlc0ZhY3RvcjtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcclxuXHJcblx0fSxcclxuXHJcblx0bmVhcmVzdFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLnJvdW5kKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dmFsdWUgLS07XHJcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAxO1xyXG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gMjtcclxuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDQ7XHJcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiA4O1xyXG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gMTY7XHJcblx0XHR2YWx1ZSArKztcclxuXHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1NwbGluZS5qc1xyXG5cclxuLyoqXHJcbiAqIFNwbGluZSBmcm9tIFR3ZWVuLmpzLCBzbGlnaHRseSBvcHRpbWl6ZWQgKGFuZCB0cmFzaGVkKVxyXG4gKiBodHRwOi8vc29sZS5naXRodWIuY29tL3R3ZWVuLmpzL2V4YW1wbGVzLzA1X3NwbGluZS5odG1sXHJcbiAqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BsaW5lID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdHRoaXMucG9pbnRzID0gcG9pbnRzO1xyXG5cclxuXHR2YXIgYyA9IFtdLCB2MyA9IHsgeDogMCwgeTogMCwgejogMCB9LFxyXG5cdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCB3MiwgdzMsXHJcblx0cGEsIHBiLCBwYywgcGQ7XHJcblxyXG5cdHRoaXMuaW5pdEZyb21BcnJheSA9IGZ1bmN0aW9uICggYSApIHtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uICggayApIHtcclxuXHJcblx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaztcclxuXHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0Y1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcclxuXHRcdGNbIDEgXSA9IGludFBvaW50O1xyXG5cdFx0Y1sgMiBdID0gaW50UG9pbnQgID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMiA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDE7XHJcblx0XHRjWyAzIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAzID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcclxuXHJcblx0XHRwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcclxuXHRcdHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xyXG5cdFx0cGMgPSB0aGlzLnBvaW50c1sgY1sgMiBdIF07XHJcblx0XHRwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcclxuXHJcblx0XHR3MiA9IHdlaWdodCAqIHdlaWdodDtcclxuXHRcdHczID0gd2VpZ2h0ICogdzI7XHJcblxyXG5cdFx0djMueCA9IGludGVycG9sYXRlKCBwYS54LCBwYi54LCBwYy54LCBwZC54LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cdFx0djMueSA9IGludGVycG9sYXRlKCBwYS55LCBwYi55LCBwYy55LCBwZC55LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cdFx0djMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cclxuXHRcdHJldHVybiB2MztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXHJcblx0XHRcdGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHAgPSB0aGlzLnBvaW50c1sgaSBdO1xyXG5cdFx0XHRjb29yZHNbIGkgXSA9IFsgcC54LCBwLnksIHAueiBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29vcmRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBhcHByb3hpbWF0ZSBsZW5ndGggYnkgc3VtbWluZyBsaW5lYXIgc2VnbWVudHNcclxuXHJcblx0dGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoIG5TdWJEaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0dmFyIGksIGluZGV4LCBuU2FtcGxlcywgcG9zaXRpb24sXHJcblx0XHRcdHBvaW50ID0gMCwgaW50UG9pbnQgPSAwLCBvbGRJbnRQb2ludCA9IDAsXHJcblx0XHRcdG9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0dG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0Y2h1bmtMZW5ndGhzID0gW10sXHJcblx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcclxuXHJcblx0XHQvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcclxuXHJcblx0XHRjaHVua0xlbmd0aHNbIDAgXSA9IDA7XHJcblxyXG5cdFx0aWYgKCAhIG5TdWJEaXZpc2lvbnMgKSBuU3ViRGl2aXNpb25zID0gMTAwO1xyXG5cclxuXHRcdG5TYW1wbGVzID0gdGhpcy5wb2ludHMubGVuZ3RoICogblN1YkRpdmlzaW9ucztcclxuXHJcblx0XHRvbGRQb3NpdGlvbi5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICk7XHJcblxyXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBuU2FtcGxlczsgaSArKyApIHtcclxuXHJcblx0XHRcdGluZGV4ID0gaSAvIG5TYW1wbGVzO1xyXG5cclxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xyXG5cdFx0XHR0bXBWZWMuY29weSggcG9zaXRpb24gKTtcclxuXHJcblx0XHRcdHRvdGFsTGVuZ3RoICs9IHRtcFZlYy5kaXN0YW5jZVRvKCBvbGRQb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0b2xkUG9zaXRpb24uY29weSggcG9zaXRpb24gKTtcclxuXHJcblx0XHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBpbmRleDtcclxuXHRcdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cclxuXHRcdFx0aWYgKCBpbnRQb2ludCAhPT0gb2xkSW50UG9pbnQgKSB7XHJcblxyXG5cdFx0XHRcdGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xyXG5cdFx0XHRcdG9sZEludFBvaW50ID0gaW50UG9pbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGxhc3QgcG9pbnQgZW5kcyB3aXRoIHRvdGFsIGxlbmd0aFxyXG5cclxuXHRcdGNodW5rTGVuZ3Roc1sgY2h1bmtMZW5ndGhzLmxlbmd0aCBdID0gdG90YWxMZW5ndGg7XHJcblxyXG5cdFx0cmV0dXJuIHsgY2h1bmtzOiBjaHVua0xlbmd0aHMsIHRvdGFsOiB0b3RhbExlbmd0aCB9O1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCA9IGZ1bmN0aW9uICggc2FtcGxpbmdDb2VmICkge1xyXG5cclxuXHRcdHZhciBpLCBqLFxyXG5cdFx0XHRpbmRleCwgaW5kZXhDdXJyZW50LCBpbmRleE5leHQsXHJcblx0XHRcdHJlYWxEaXN0YW5jZSxcclxuXHRcdFx0c2FtcGxpbmcsIHBvc2l0aW9uLFxyXG5cdFx0XHRuZXdwb2ludHMgPSBbXSxcclxuXHRcdFx0dG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0c2wgPSB0aGlzLmdldExlbmd0aCgpO1xyXG5cclxuXHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIDAgXSApLmNsb25lKCkgKTtcclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdC8vdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIC0gMSBdICk7XHJcblx0XHRcdC8vbGluZWFyRGlzdGFuY2UgPSB0bXBWZWMuZGlzdGFuY2VUbyggdGhpcy5wb2ludHNbIGkgXSApO1xyXG5cclxuXHRcdFx0cmVhbERpc3RhbmNlID0gc2wuY2h1bmtzWyBpIF0gLSBzbC5jaHVua3NbIGkgLSAxIF07XHJcblxyXG5cdFx0XHRzYW1wbGluZyA9IE1hdGguY2VpbCggc2FtcGxpbmdDb2VmICogcmVhbERpc3RhbmNlIC8gc2wudG90YWwgKTtcclxuXHJcblx0XHRcdGluZGV4Q3VycmVudCA9ICggaSAtIDEgKSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xyXG5cdFx0XHRpbmRleE5leHQgPSBpIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0aW5kZXggPSBpbmRleEN1cnJlbnQgKyBqICogKCAxIC8gc2FtcGxpbmcgKSAqICggaW5kZXhOZXh0IC0gaW5kZXhDdXJyZW50ICk7XHJcblxyXG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcclxuXHRcdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHBvc2l0aW9uICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSBdICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQ2F0bXVsbC1Sb21cclxuXHJcblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XHJcblxyXG5cdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXHJcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblxyXG5cdFx0cmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1RyaWFuZ2xlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlRyaWFuZ2xlID0gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuXHR0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5iID0gKCBiICE9PSB1bmRlZmluZWQgKSA/IGIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuYyA9ICggYyAhPT0gdW5kZWZpbmVkICkgPyBjIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UcmlhbmdsZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBjLCBiICk7XHJcblx0XHR2MC5zdWJWZWN0b3JzKCBhLCBiICk7XHJcblx0XHRyZXN1bHQuY3Jvc3MoIHYwICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XHJcblx0XHRpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHJlc3VsdExlbmd0aFNxICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcbi8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXHJcbi8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXHJcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2MC5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHR2MS5zdWJWZWN0b3JzKCBiLCBhICk7XHJcblx0XHR2Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xyXG5cclxuXHRcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcclxuXHRcdHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcclxuXHRcdHZhciBkb3QwMiA9IHYwLmRvdCggdjIgKTtcclxuXHRcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcclxuXHRcdHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcclxuXHJcblx0XHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXHJcblx0XHRpZiAoIGRlbm9tID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XHJcblx0XHRcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIC0gMiwgLSAxLCAtIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xyXG5cdFx0dmFyIHUgPSAoIGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyICkgKiBpbnZEZW5vbTtcclxuXHRcdHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XHJcblxyXG5cdFx0Ly8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcclxuXHRcdHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xyXG5cclxuXHRcdHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlRyaWFuZ2xlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggYSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIGIgKTtcclxuXHRcdHRoaXMuYy5jb3B5KCBjICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiAoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XHJcblx0XHR0aGlzLmIuY29weSggcG9pbnRzWyBpMSBdICk7XHJcblx0XHR0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XHJcblx0XHR0aGlzLmIuY29weSggdHJpYW5nbGUuYiApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXJlYTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xyXG5cdFx0XHR2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWlkcG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICkuYWRkKCB0aGlzLmMgKS5tdWx0aXBseVNjYWxhciggMSAvIDMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBsYW5lOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuUGxhbmUoKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9DaGFubmVscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMubWFzayA9IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2hhbm5lbHMucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQ2hhbm5lbHMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayAmPSB+ICggMSA8PCBjaGFubmVsICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0Nsb2NrLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DbG9jayA9IGZ1bmN0aW9uICggYXV0b1N0YXJ0ICkge1xyXG5cclxuXHR0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XHJcblxyXG5cdHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHR0aGlzLm9sZFRpbWUgPSAwO1xyXG5cdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xyXG5cclxuXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DbG9jay5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DbG9jayxcclxuXHJcblx0c3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG5cdFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XHJcblx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xyXG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5nZXREZWx0YSgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldERlbHRhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRpZmYgPSAwO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnN0YXJ0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xyXG5cclxuXHRcdFx0dmFyIG5ld1RpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuXHRcdFx0ZGlmZiA9IDAuMDAxICogKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICk7XHJcblx0XHRcdHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XHJcblxyXG5cdFx0XHR0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkaWZmO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9FdmVudERpc3BhdGNoZXIuanNcclxuXHJcbi8qKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cclxuICovXHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5FdmVudERpc3BhdGNoZXIsXHJcblxyXG5cdGFwcGx5OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHRcdG9iamVjdC5oYXNFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO1xyXG5cdFx0b2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcblx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcclxuXHJcblx0fSxcclxuXHJcblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0XHRsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSBbXTtcclxuXHRcdFx0dmFyIGxlbmd0aCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRhcnJheVsgaSBdID0gbGlzdGVuZXJBcnJheVsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9SYXljYXN0ZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uICggVEhSRUUgKSB7XHJcblxyXG5cdFRIUkVFLlJheWNhc3RlciA9IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIsIGZhciApIHtcclxuXHJcblx0XHR0aGlzLnJheSA9IG5ldyBUSFJFRS5SYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XHJcblx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxyXG5cclxuXHRcdHRoaXMubmVhciA9IG5lYXIgfHwgMDtcclxuXHRcdHRoaXMuZmFyID0gZmFyIHx8IEluZmluaXR5O1xyXG5cclxuXHRcdHRoaXMucGFyYW1zID0ge1xyXG5cdFx0XHRNZXNoOiB7fSxcclxuXHRcdFx0TGluZToge30sXHJcblx0XHRcdExPRDoge30sXHJcblx0XHRcdFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcclxuXHRcdFx0U3ByaXRlOiB7fVxyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5wYXJhbXMsIHtcclxuXHRcdFx0UG9pbnRDbG91ZDoge1xyXG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyOiBwYXJhbXMuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIHBhcmFtcy5Qb2ludHMuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuUG9pbnRzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBkZXNjU29ydCggYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdFRIUkVFLlJheWNhc3Rlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcclxuXHJcblx0XHRsaW5lUHJlY2lzaW9uOiAxLFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG5cdFx0XHR0aGlzLnJheS5zZXQoIG9yaWdpbiwgZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xyXG5cclxuXHRcdFx0aWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAwLjUgKS51bnByb2plY3QoIGNhbWVyYSApLnN1YiggdGhpcy5yYXkub3JpZ2luICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgLSAxICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCAwLCAwLCAtIDEgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcclxuXHJcblx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRcdGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcclxuXHJcblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3RzICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xyXG5cdFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoIGRlc2NTb3J0ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCBUSFJFRSApICk7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL09iamVjdDNELmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgZWxlcGhhbnRhdHdvcmsgLyB3d3cuZWxlcGhhbnRhdHdvcmsuY2hcclxuICovXHJcblxyXG5USFJFRS5PYmplY3QzRCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5PYmplY3QzRElkQ291bnQgKysgfSApO1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xyXG5cclxuXHR0aGlzLnBhcmVudCA9IG51bGw7XHJcblx0dGhpcy5jaGFubmVscyA9IG5ldyBUSFJFRS5DaGFubmVscygpO1xyXG5cdHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcblx0dGhpcy51cCA9IFRIUkVFLk9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xyXG5cclxuXHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xyXG5cdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHR2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xyXG5cclxuXHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xyXG5cclxuXHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XHJcblxyXG5cdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyb3RhdGlvbi5vbkNoYW5nZSggb25Sb3RhdGlvbkNoYW5nZSApO1xyXG5cdHF1YXRlcm5pb24ub25DaGFuZ2UoIG9uUXVhdGVybmlvbkNoYW5nZSApO1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cdFx0cG9zaXRpb246IHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0dmFsdWU6IHBvc2l0aW9uXHJcblx0XHR9LFxyXG5cdFx0cm90YXRpb246IHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0dmFsdWU6IHJvdGF0aW9uXHJcblx0XHR9LFxyXG5cdFx0cXVhdGVybmlvbjoge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHR2YWx1ZTogcXVhdGVybmlvblxyXG5cdFx0fSxcclxuXHRcdHNjYWxlOiB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiBzY2FsZVxyXG5cdFx0fSxcclxuXHRcdG1vZGVsVmlld01hdHJpeDoge1xyXG5cdFx0XHR2YWx1ZTogbmV3IFRIUkVFLk1hdHJpeDQoKVxyXG5cdFx0fSxcclxuXHRcdG5vcm1hbE1hdHJpeDoge1xyXG5cdFx0XHR2YWx1ZTogbmV3IFRIUkVFLk1hdHJpeDMoKVxyXG5cdFx0fVxyXG5cdH0gKTtcclxuXHJcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IFRIUkVFLk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlO1xyXG5cdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcclxuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcclxuXHR0aGlzLnJlbmRlck9yZGVyID0gMDtcclxuXHJcblx0dGhpcy51c2VyRGF0YSA9IHt9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9iamVjdDNELkRlZmF1bHRVcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblRIUkVFLk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcblRIUkVFLk9iamVjdDNELnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk9iamVjdDNELFxyXG5cclxuXHRnZXQgZXVsZXJPcmRlciAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgZXVsZXJPcmRlciAoIHZhbHVlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLicgKTtcclxuXHJcblx0XHR0aGlzLnJvdGF0aW9uLm9yZGVyID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB1c2VRdWF0ZXJuaW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB1c2VRdWF0ZXJuaW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgcmVuZGVyRGVwdGggKCB2YWx1ZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnJlbmRlckRlcHRoIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAucmVuZGVyT3JkZXIsIGluc3RlYWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvL1xyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cm90YXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxyXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxyXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0djEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XHJcblxyXG5cdFx0XHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0d29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcclxuXHJcblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdG0xLmxvb2tBdCggdmVjdG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwICk7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlwiLCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmdldENoaWxkQnlOYW1lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0T2JqZWN0QnlOYW1lKCkuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xyXG5cdFx0XHR2YXIgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFdvcmxkUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHJlc3VsdCwgc2NhbGUgKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5FdWxlcigpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMucm90YXRpb24ub3JkZXIsIGZhbHNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRXb3JsZFNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCByZXN1bHQgKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRXb3JsZERpcmVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRyYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcblx0dHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcclxuXHJcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRjYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG5cclxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y2FsbGJhY2soIHBhcmVudCApO1xyXG5cclxuXHRcdFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID09PSB0cnVlIHx8IGZvcmNlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0XHR2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgKTtcclxuXHJcblx0XHR2YXIgb3V0cHV0ID0ge307XHJcblxyXG5cdFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cclxuXHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XHJcblx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxyXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXHJcblx0XHRcdG1ldGEgPSB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoge30sXHJcblx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcclxuXHRcdFx0XHR0ZXh0dXJlczoge30sXHJcblx0XHRcdFx0aW1hZ2VzOiB7fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0b3V0cHV0Lm1ldGFkYXRhID0ge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNCxcclxuXHRcdFx0XHR0eXBlOiAnT2JqZWN0JyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cclxuXHJcblx0XHR2YXIgb2JqZWN0ID0ge307XHJcblxyXG5cdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XHJcblx0XHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcclxuXHRcdGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XHJcblx0XHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcclxuXHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xyXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgb2JqZWN0LnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCB0aGlzLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKCBtZXRhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvYmplY3QuZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LnV1aWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdG9iamVjdC5jaGlsZHJlbiA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJpZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmdlb21ldHJpZXMgKTtcclxuXHRcdFx0dmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XHJcblx0XHRcdHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcclxuXHRcdFx0dmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcclxuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XHJcblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG5cdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0b3V0cHV0Lm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHRcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXHJcblx0XHQvLyByZW1vdmUgbWV0YWRhdGEgb24gZWFjaCBpdGVtXHJcblx0XHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XHJcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlICggY2FjaGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmFsdWVzID0gW107XHJcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xyXG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XHJcblx0XHR0aGlzLnNjYWxlLmNvcHkoIHNvdXJjZS5zY2FsZSApO1xyXG5cclxuXHRcdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gc291cmNlLnJvdGF0aW9uQXV0b1VwZGF0ZTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XHJcblxyXG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XHJcblxyXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XHJcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcclxuXHJcblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcclxuXHRcdHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XHJcblxyXG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xyXG5cclxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XHJcblx0XHRcdFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk9iamVjdDNESWRDb3VudCA9IDA7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2UzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5GYWNlMyA9IGZ1bmN0aW9uICggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0dGhpcy5hID0gYTtcclxuXHR0aGlzLmIgPSBiO1xyXG5cdHRoaXMuYyA9IGM7XHJcblxyXG5cdHRoaXMubm9ybWFsID0gbm9ybWFsIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzID0gQXJyYXkuaXNBcnJheSggbm9ybWFsICkgPyBub3JtYWwgOiBbXTtcclxuXHJcblx0dGhpcy5jb2xvciA9IGNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgPyBjb2xvciA6IG5ldyBUSFJFRS5Db2xvcigpO1xyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XHJcblxyXG5cdHRoaXMubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZhY2UzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkZhY2UzLFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5hID0gc291cmNlLmE7XHJcblx0XHR0aGlzLmIgPSBzb3VyY2UuYjtcclxuXHRcdHRoaXMuYyA9IHNvdXJjZS5jO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHNvdXJjZS5ub3JtYWwgKTtcclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gc291cmNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSBzb3VyY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZhY2U0ID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKTtcclxuXHRyZXR1cm4gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cclxuXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcclxuXHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcclxuXHJcblx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyQXR0cmlidXRlLFxyXG5cclxuXHRnZXQgbGVuZ3RoKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5jb3VudC4nICk7XHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCBjb3VudCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggLyB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5keW5hbWljID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcclxuXHRcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XHJcblxyXG5cdFx0dGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xyXG5cclxuXHRcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xyXG5cdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5Q29sb3JzQXJyYXk6IGZ1bmN0aW9uICggY29sb3JzICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSBjb2xvcnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSgpOiBjb2xvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0Y29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLnI7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmc7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5SW5kaWNlc0FycmF5OiBmdW5jdGlvbiAoIGluZGljZXMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSBpbmRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5hO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5jO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcclxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcclxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IuejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlWZWN0b3I0c0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3I0c0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0dmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcclxuXHJcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vXHJcblxyXG5USFJFRS5JbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVpbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVWludDE2QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmxvYXQ2NEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5cclxuLy8gRGVwcmVjYXRlZFxyXG5cclxuVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCkuc2V0RHluYW1pYyggdHJ1ZSApIGluc3RlYWQuJyApO1xyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKS5zZXREeW5hbWljKCB0cnVlICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICovXHJcblxyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xyXG5cclxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiAoIGFycmF5LCBzdHJpZGUgKSB7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMuYXJyYXkgPSBhcnJheTtcclxuXHR0aGlzLnN0cmlkZSA9IHN0cmlkZTtcclxuXHJcblx0dGhpcy5keW5hbWljID0gZmFsc2U7XHJcblx0dGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XHJcblxyXG5cdHRoaXMudmVyc2lvbiA9IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIsXHJcblxyXG5cdGdldCBsZW5ndGggKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IGNvdW50ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggLyB0aGlzLnN0cmlkZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuZHluYW1pYyA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XHJcblx0XHR0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XHJcblx0XHR0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XHJcblxyXG5cdFx0aW5kZXgxICo9IHRoaXMuc3RyaWRlO1xyXG5cdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5zdHJpZGU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5zdHJpZGU7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICovXHJcblxyXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IGZ1bmN0aW9uICggYXJyYXksIHN0cmlkZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0VEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIuY2FsbCggdGhpcywgYXJyYXksIHN0cmlkZSApO1xyXG5cclxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlICk7XHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0ICkge1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcclxuXHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XHJcblx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLFxyXG5cclxuXHRnZXQgbGVuZ3RoKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5jb3VudC4nICk7XHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCBjb3VudCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5Lmxlbmd0aCAvIHRoaXMuZGF0YS5zdHJpZGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcclxuXHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcclxuXHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcclxuXHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9HZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy50eXBlID0gJ0dlb21ldHJ5JztcclxuXHJcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG5cdHRoaXMuY29sb3JzID0gW107XHJcblx0dGhpcy5mYWNlcyA9IFtdO1xyXG5cdHRoaXMuZmFjZVZlcnRleFV2cyA9IFsgW10gXTtcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xyXG5cclxuXHR0aGlzLnNraW5XZWlnaHRzID0gW107XHJcblx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdC8vIHVwZGF0ZSBmbGFnc1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5HZW9tZXRyeSxcclxuXHJcblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG5cdFx0XHR2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvYmo7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4ICE9PSBudWxsID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHR2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcclxuXHJcblx0XHR2YXIgdGVtcE5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciB0ZW1wVVZzID0gW107XHJcblx0XHR2YXIgdGVtcFVWczIgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBrID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzLCBqICs9IDIsIGsgKz0gNCApIHtcclxuXHJcblx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xyXG5cclxuXHRcdFx0aWYgKCBub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRlbXBOb3JtYWxzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBub3JtYWxzWyBpIF0sIG5vcm1hbHNbIGkgKyAxIF0sIG5vcm1hbHNbIGkgKyAyIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBjb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggY29sb3JzWyBpIF0sIGNvbG9yc1sgaSArIDEgXSwgY29sb3JzWyBpICsgMiBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRlbXBVVnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2c1sgaiBdLCB1dnNbIGogKyAxIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRlbXBVVnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnMyWyBqIF0sIHV2czJbIGogKyAxIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRGYWNlKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBub3JtYWxzICE9PSB1bmRlZmluZWQgPyBbIHRlbXBOb3JtYWxzWyBhIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGIgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xyXG5cdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gY29sb3JzICE9PSB1bmRlZmluZWQgPyBbIHNjb3BlLmNvbG9yc1sgYSBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYiBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIHZlcnRleE5vcm1hbHMsIHZlcnRleENvbG9ycyApO1xyXG5cclxuXHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdGVtcFVWc1sgYSBdLmNsb25lKCksIHRlbXBVVnNbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzWyBjIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMSBdLnB1c2goIFsgdGVtcFVWczJbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYiBdLmNsb25lKCksIHRlbXBVVnMyWyBjIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGogXSwgaW5kaWNlc1sgaiArIDEgXSwgaW5kaWNlc1sgaiArIDIgXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBpIF0sIGluZGljZXNbIGkgKyAxIF0sIGluZGljZXNbIGkgKyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5jZW50ZXIoKS5uZWdhdGUoKTtcclxuXHJcblx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xyXG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdHZhciBzID0gcmFkaXVzID09PSAwID8gMSA6IDEuMCAvIHJhZGl1cztcclxuXHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHRcdG1hdHJpeC5zZXQoXHJcblx0XHRcdHMsIDAsIDAsIC0gcyAqIGNlbnRlci54LFxyXG5cdFx0XHQwLCBzLCAwLCAtIHMgKiBjZW50ZXIueSxcclxuXHRcdFx0MCwgMCwgcywgLSBzICogY2VudGVyLnosXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHRcdCk7XHJcblxyXG5cdFx0dGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0dmFyIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xyXG5cdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcclxuXHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRjYi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XHJcblxyXG5cdFx0dmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XHJcblxyXG5cdFx0dmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGFyZWFXZWlnaHRlZCApIHtcclxuXHJcblx0XHRcdC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXHJcblx0XHRcdC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cclxuXHJcblx0XHRcdHZhciB2QSwgdkIsIHZDO1xyXG5cdFx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0dkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XHJcblx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XHJcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXSA9IHZlcnRpY2VzWyBmYWNlLmIgXS5jbG9uZSgpO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXSA9IHZlcnRpY2VzWyBmYWNlLmMgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZU1vcnBoTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XHJcblxyXG5cdFx0Ly8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXHJcblx0XHQvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3NcclxuXHRcdC8vICAgb3RoZXJ3aXNlIGp1c3QgY29weSAoZm9yIGZhc3RlciByZXBlYXRlZCBjYWxscylcclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxyXG5cclxuXHRcdHZhciB0bXBHZW8gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRcdHRtcEdlby5mYWNlcyA9IHRoaXMuZmFjZXM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHQvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXHJcblxyXG5cdFx0XHRpZiAoICEgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXSA9IHt9O1xyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgPSBbXTtcclxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcclxuXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBiOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBjOiBuZXcgVEhSRUUuVmVjdG9yMygpIH07XHJcblxyXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xyXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0Ly8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxyXG5cclxuXHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xyXG5cclxuXHRcdFx0dG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdFx0XHR0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHRcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcclxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVMaW5lRGlzdGFuY2VzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGQgPSAwO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGkgPiAwICkge1xyXG5cclxuXHRcdFx0XHRkICs9IHZlcnRpY2VzWyBpIF0uZGlzdGFuY2VUbyggdmVydGljZXNbIGkgLSAxIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbm9ybWFsTWF0cml4LFxyXG5cdFx0dmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXHJcblx0XHR2ZXJ0aWNlczEgPSB0aGlzLnZlcnRpY2VzLFxyXG5cdFx0dmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHRmYWNlczEgPSB0aGlzLmZhY2VzLFxyXG5cdFx0ZmFjZXMyID0gZ2VvbWV0cnkuZmFjZXMsXHJcblx0XHR1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXHJcblx0XHR1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XHJcblxyXG5cdFx0aWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcclxuXHJcblx0XHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmYWNlc1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gZmFjZXMyWyBpIF0sIGZhY2VDb3B5LCBub3JtYWwsIGNvbG9yLFxyXG5cdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcclxuXHRcdFx0ZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0ZmFjZUNvcHkgPSBuZXcgVEhSRUUuRmFjZTMoIGZhY2UuYSArIHZlcnRleE9mZnNldCwgZmFjZS5iICsgdmVydGV4T2Zmc2V0LCBmYWNlLmMgKyB2ZXJ0ZXhPZmZzZXQgKTtcclxuXHRcdFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Y29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XHJcblx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2VDb3B5Lm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXggKyBtYXRlcmlhbEluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHV2c1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xyXG5cclxuXHRcdFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dXZDb3B5LnB1c2goIHV2WyBqIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dXZzMS5wdXNoKCB1dkNvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdG1lcmdlTWVzaDogZnVuY3Rpb24gKCBtZXNoICkge1xyXG5cclxuXHRcdGlmICggbWVzaCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRtZXNoLm1hdHJpeEF1dG9VcGRhdGUgJiYgbWVzaC51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLm1lcmdlKCBtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdHJpeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvKlxyXG5cdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cclxuXHQgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXHJcblx0ICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cclxuXHQgKi9cclxuXHJcblx0bWVyZ2VWZXJ0aWNlczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxyXG5cdFx0dmFyIHVuaXF1ZSA9IFtdLCBjaGFuZ2VzID0gW107XHJcblxyXG5cdFx0dmFyIHYsIGtleTtcclxuXHRcdHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcclxuXHRcdHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xyXG5cdFx0dmFyIGksIGlsLCBmYWNlO1xyXG5cdFx0dmFyIGluZGljZXMsIGosIGpsO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG5cdFx0XHRrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc01hcFsga2V5IF0gPSBpO1xyXG5cdFx0XHRcdHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcclxuXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XHJcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXHJcblx0XHQvLyBoYXZlIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdlb21ldHJ5LlxyXG5cdFx0dmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0ZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XHJcblxyXG5cdFx0XHR2YXIgZHVwSW5kZXggPSAtIDE7XHJcblxyXG5cdFx0XHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXHJcblx0XHRcdC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXHJcblx0XHRcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0ZHVwSW5kZXggPSBuO1xyXG5cdFx0XHRcdFx0ZmFjZUluZGljZXNUb1JlbW92ZS5wdXNoKCBpICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XHJcblxyXG5cdFx0XHR2YXIgaWR4ID0gZmFjZUluZGljZXNUb1JlbW92ZVsgaSBdO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGlkeCwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2UgdW5pcXVlIHNldCBvZiB2ZXJ0aWNlc1xyXG5cclxuXHRcdHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xyXG5cdFx0dGhpcy52ZXJ0aWNlcyA9IHVuaXF1ZTtcclxuXHRcdHJldHVybiBkaWZmO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzb3J0RmFjZXNCeU1hdGVyaWFsSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cdFx0dmFyIGxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHQvLyB0YWcgZmFjZXNcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlc1sgaSBdLl9pZCA9IGk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNvcnQgZmFjZXNcclxuXHJcblx0XHRmdW5jdGlvbiBtYXRlcmlhbEluZGV4U29ydCggYSwgYiApIHtcclxuXHJcblx0XHRcdHJldHVybiBhLm1hdGVyaWFsSW5kZXggLSBiLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZhY2VzLnNvcnQoIG1hdGVyaWFsSW5kZXhTb3J0ICk7XHJcblxyXG5cdFx0Ly8gc29ydCB1dnNcclxuXHJcblx0XHR2YXIgdXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cdFx0dmFyIHV2czIgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXTtcclxuXHJcblx0XHR2YXIgbmV3VXZzMSwgbmV3VXZzMjtcclxuXHJcblx0XHRpZiAoIHV2czEgJiYgdXZzMS5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czEgPSBbXTtcclxuXHRcdGlmICggdXZzMiAmJiB1dnMyLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMiA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBpZCA9IGZhY2VzWyBpIF0uX2lkO1xyXG5cclxuXHRcdFx0aWYgKCBuZXdVdnMxICkgbmV3VXZzMS5wdXNoKCB1dnMxWyBpZCBdICk7XHJcblx0XHRcdGlmICggbmV3VXZzMiApIG5ld1V2czIucHVzaCggdXZzMlsgaWQgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG5ld1V2czEgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSA9IG5ld1V2czE7XHJcblx0XHRpZiAoIG5ld1V2czIgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IG5ld1V2czI7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNCxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnknLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0dlb21ldHJ5LnRvSlNPTidcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzdGFuZGFyZCBHZW9tZXRyeSBzZXJpYWxpemF0aW9uXHJcblxyXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gW107XHJcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xyXG5cdFx0dmFyIG5vcm1hbHNIYXNoID0ge307XHJcblx0XHR2YXIgY29sb3JzID0gW107XHJcblx0XHR2YXIgY29sb3JzSGFzaCA9IHt9O1xyXG5cdFx0dmFyIHV2cyA9IFtdO1xyXG5cdFx0dmFyIHV2c0hhc2ggPSB7fTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmZhY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIGhhc01hdGVyaWFsID0gZmFsc2U7IC8vIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0XHR2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcclxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF0gIT09IHVuZGVmaW5lZDtcclxuXHRcdFx0dmFyIGhhc0ZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5sZW5ndGgoKSA+IDA7XHJcblx0XHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XHJcblx0XHRcdHZhciBoYXNGYWNlQ29sb3IgPSBmYWNlLmNvbG9yLnIgIT09IDEgfHwgZmFjZS5jb2xvci5nICE9PSAxIHx8IGZhY2UuY29sb3IuYiAhPT0gMTtcclxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0XHR2YXIgZmFjZVR5cGUgPSAwO1xyXG5cclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAwLCAwICk7XHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAyLCBoYXNGYWNlVXYgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNSwgaGFzRmFjZVZlcnRleE5vcm1hbCApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaChcclxuXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDAgXSApLFxyXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMSBdICksXHJcblx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goIGdldE5vcm1hbEluZGV4KCBmYWNlLm5vcm1hbCApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKFxyXG5cdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDAgXSApLFxyXG5cdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDEgXSApLFxyXG5cdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDIgXSApXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCBnZXRDb2xvckluZGV4KCBmYWNlLmNvbG9yICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goXHJcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDAgXSApLFxyXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcclxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMiBdIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXRCaXQoIHZhbHVlLCBwb3NpdGlvbiwgZW5hYmxlZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBlbmFibGVkID8gdmFsdWUgfCAoIDEgPDwgcG9zaXRpb24gKSA6IHZhbHVlICYgKCB+ICggMSA8PCBwb3NpdGlvbiApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldE5vcm1hbEluZGV4KCBub3JtYWwgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdGlmICggbm9ybWFsc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vcm1hbHNIYXNoWyBoYXNoIF0gPSBub3JtYWxzLmxlbmd0aCAvIDM7XHJcblx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoIGNvbG9yICkge1xyXG5cclxuXHRcdFx0dmFyIGhhc2ggPSBjb2xvci5yLnRvU3RyaW5nKCkgKyBjb2xvci5nLnRvU3RyaW5nKCkgKyBjb2xvci5iLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9yc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29sb3JzSGFzaFsgaGFzaCBdID0gY29sb3JzLmxlbmd0aDtcclxuXHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLmdldEhleCgpICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRVdkluZGV4KCB1diApIHtcclxuXHJcblx0XHRcdHZhciBoYXNoID0gdXYueC50b1N0cmluZygpICsgdXYueS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0aWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHV2c0hhc2hbIGhhc2ggXSA9IHV2cy5sZW5ndGggLyAyO1xyXG5cdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGF0YS5kYXRhID0ge307XHJcblxyXG5cdFx0ZGF0YS5kYXRhLnZlcnRpY2VzID0gdmVydGljZXM7XHJcblx0XHRkYXRhLmRhdGEubm9ybWFscyA9IG5vcm1hbHM7XHJcblx0XHRpZiAoIGNvbG9ycy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLmNvbG9ycyA9IGNvbG9ycztcclxuXHRcdGlmICggdXZzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEudXZzID0gWyB1dnMgXTsgLy8gdGVtcG9yYWwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5cdFx0ZGF0YS5kYXRhLmZhY2VzID0gZmFjZXM7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0XHR0aGlzLmZhY2VzID0gW107XHJcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gc291cmNlLnZlcnRpY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmYWNlcyA9IHNvdXJjZS5mYWNlcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHNvdXJjZS5mYWNlVmVydGV4VXZzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHV2cyA9IGZhY2VWZXJ0ZXhVdnNbIGogXSwgdXZzQ29weSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgayA9IDAsIGtsID0gdXZzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB1diA9IHV2c1sgayBdO1xyXG5cclxuXHRcdFx0XHRcdHV2c0NvcHkucHVzaCggdXYuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdLnB1c2goIHV2c0NvcHkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuR2VvbWV0cnlJZENvdW50ID0gMDtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvRGlyZWN0R2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdEdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdEaXJlY3RHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMuaW5kaWNlcyA9IFtdO1xyXG5cdHRoaXMudmVydGljZXMgPSBbXTtcclxuXHR0aGlzLm5vcm1hbHMgPSBbXTtcclxuXHR0aGlzLmNvbG9ycyA9IFtdO1xyXG5cdHRoaXMudXZzID0gW107XHJcblx0dGhpcy51dnMyID0gW107XHJcblxyXG5cdHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0ge307XHJcblxyXG5cdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcclxuXHR0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblxyXG5cdC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0Ly8gdXBkYXRlIGZsYWdzXHJcblxyXG5cdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkRpcmVjdEdlb21ldHJ5LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3g6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdCb3gsXHJcblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nU3BoZXJlLFxyXG5cclxuXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZUZhY2VOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnk6IGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVHcm91cHM6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIGdyb3VwO1xyXG5cdFx0dmFyIGdyb3VwcyA9IFtdO1xyXG5cdFx0dmFyIG1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0Ly8gbWF0ZXJpYWxzXHJcblxyXG5cdFx0XHRpZiAoIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XHJcblx0XHRcdFx0XHRncm91cHMucHVzaCggZ3JvdXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRncm91cCA9IHtcclxuXHRcdFx0XHRcdHN0YXJ0OiBpICogMyxcclxuXHRcdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRncm91cHMucHVzaCggZ3JvdXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ncm91cHMgPSBncm91cHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xyXG5cclxuXHRcdHZhciBoYXNGYWNlVmVydGV4VXYgPSBmYWNlVmVydGV4VXZzWyAwIF0gJiYgZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCA+IDA7XHJcblx0XHR2YXIgaGFzRmFjZVZlcnRleFV2MiA9IGZhY2VWZXJ0ZXhVdnNbIDEgXSAmJiBmYWNlVmVydGV4VXZzWyAxIF0ubGVuZ3RoID4gMDtcclxuXHJcblx0XHQvLyBtb3JwaHNcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG5cdFx0dmFyIG1vcnBoVGFyZ2V0c0xlbmd0aCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLnBvc2l0aW9uID0gbW9ycGhUYXJnZXRzUG9zaXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XHJcblx0XHR2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoIG1vcnBoTm9ybWFsc0xlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhUYXJnZXRzTm9ybWFsID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaSBdID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5ub3JtYWwgPSBtb3JwaFRhcmdldHNOb3JtYWw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNraW5zXHJcblxyXG5cdFx0dmFyIHNraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXM7XHJcblx0XHR2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcclxuXHJcblx0XHR2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcclxuXHRcdHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgZmFjZS5hIF0sIHZlcnRpY2VzWyBmYWNlLmIgXSwgdmVydGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9ybWFscy5wdXNoKCB2ZXJ0ZXhOb3JtYWxzWyAwIF0sIHZlcnRleE5vcm1hbHNbIDEgXSwgdmVydGV4Tm9ybWFsc1sgMiBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9ybWFscy5wdXNoKCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhciBjb2xvciA9IGZhY2UuY29sb3I7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMyLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbW9ycGhzXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaiBdLnB1c2goIG1vcnBoVGFyZ2V0WyBmYWNlLmEgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYiBdLCBtb3JwaFRhcmdldFsgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBqIF0udmVydGV4Tm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBza2luc1xyXG5cclxuXHRcdFx0aWYgKCBoYXNTa2luSW5kaWNlcyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc1NraW5XZWlnaHRzICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XHJcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5EaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMuaW5kZXggPSBudWxsO1xyXG5cdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSxcclxuXHJcblx0YWRkSW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRJbmRleCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEluZGV4KCkuJyApO1xyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kZXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSAmJiBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xyXG5cclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbmFtZSA9PT0gJ2luZGV4JyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgZHJhd2NhbGxzKCkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgb2Zmc2V0cygpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcclxuXHRcdHJldHVybiB0aGlzLmdyb3VwcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkRHJhd0NhbGw6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIGluZGV4T2Zmc2V0LicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS4nICk7XHJcblx0XHR0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xlYXJEcmF3Q2FsbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcclxuXHRcdHRoaXMuY2xlYXJHcm91cHMoKTtcclxuXHJcblx0fSxcclxuXHJcblx0YWRkR3JvdXA6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzLnB1c2goIHtcclxuXHJcblx0XHRcdHN0YXJ0OiBzdGFydCxcclxuXHRcdFx0Y291bnQ6IGNvdW50LFxyXG5cdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMFxyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xlYXJHcm91cHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXREcmF3UmFuZ2U6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50ICkge1xyXG5cclxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XHJcblx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBwb3NpdGlvbi5hcnJheSApO1xyXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBub3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0bm9ybWFsTWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIG5vcm1hbC5hcnJheSApO1xyXG5cdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gc2NhbGUgZ2VvbWV0cnlcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgb2JqO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0XHRcdG9iai5sb29rQXQoIHZlY3RvciApO1xyXG5cclxuXHRcdFx0b2JqLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5jZW50ZXIoKS5uZWdhdGUoKTtcclxuXHJcblx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuc2V0RnJvbU9iamVjdCgpLiBDb252ZXJ0aW5nJywgb2JqZWN0LCB0aGlzICk7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcclxuXHRcdFx0dmFyIGNvbG9ycyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMywgMyApO1xyXG5cclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucy5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JzLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlcyAmJiBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbGluZURpc3RhbmNlcyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCwgMSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScsIGxpbmVEaXN0YW5jZXMuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdCA9IGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnk7XHJcblxyXG5cdFx0XHRpZiAoIGRpcmVjdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkaXJlY3QudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xyXG5cdFx0XHRkaXJlY3Qubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcclxuXHRcdFx0ZGlyZWN0LmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xyXG5cdFx0XHRkaXJlY3QudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XHJcblx0XHRcdGRpcmVjdC5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcclxuXHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkgPSBkaXJlY3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApO1xyXG5cdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnV2O1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKTtcclxuXHRcdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZTtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUdyb3Vwcyggb2JqZWN0Lmdlb21ldHJ5ICk7XHJcblx0XHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgVEhSRUUuRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoICogMyApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudXZzMi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIHV2czIgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMyLmxlbmd0aCAqIDIgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1djInLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMyLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2czIgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBUeXBlQXJyYXkgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XHJcblx0XHRcdHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XHJcblx0XHRcdHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKS5jb3B5SW5kaWNlc0FycmF5KCBnZW9tZXRyeS5pbmRpY2VzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ3JvdXBzXHJcblxyXG5cdFx0dGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0Ly8gbW9ycGhzXHJcblxyXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gW107XHJcblx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcclxuXHJcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5sZW5ndGggKiAzLCAzICk7XHJcblxyXG5cdFx0XHRcdGFycmF5LnB1c2goIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggbW9ycGhUYXJnZXQgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBza2lubmluZ1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBza2luSW5kaWNlcyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKiA0LCA0ICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbkluZGV4Jywgc2tpbkluZGljZXMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5JbmRpY2VzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIHNraW5XZWlnaHRzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAqIDQsIDQgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luV2VpZ2h0Jywgc2tpbldlaWdodHMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5XZWlnaHRzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHJcblx0XHRcdGlmICggcG9zaXRpb25zICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94O1xyXG5cdFx0XHRcdGJiLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XHJcblx0XHRcdFx0XHRiYi5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwb3NpdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdFx0Ym94Lm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdGJveC5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRib3guY2VudGVyKCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcclxuXHRcdFx0XHQvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXHJcblxyXG5cdFx0XHRcdHZhciBtYXhSYWRpdXNTcSA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcblxyXG5cdFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuXHRcdFx0dmFyIHZBLCB2QiwgdkMsXHJcblxyXG5cdFx0XHRwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0cEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRcdFx0Y2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XHJcblx0XHRcdFx0XHRcdHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XHJcblx0XHRcdFx0XHRcdHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcclxuXHRcdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XHJcblx0XHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG5cdFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XHJcblxyXG5cdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xyXG5cdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgXSA9IGNiLng7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZU9mZnNldHM6IGZ1bmN0aW9uICggc2l6ZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVPZmZzZXRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKVxyXG5cclxuXHR9LFxyXG5cclxuXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHR2YXIgYXR0cmlidXRlQXJyYXkxID0gYXR0cmlidXRlMS5hcnJheTtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUyID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF07XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVBcnJheTIgPSBhdHRyaWJ1dGUyLmFycmF5O1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZVNpemUgPSBhdHRyaWJ1dGUyLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gYXR0cmlidXRlU2l6ZSAqIG9mZnNldDsgaSA8IGF0dHJpYnV0ZUFycmF5Mi5sZW5ndGg7IGkgKyssIGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZUFycmF5MVsgaiBdID0gYXR0cmlidXRlQXJyYXkyWyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuXHRcdHZhciB4LCB5LCB6LCBuO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHR4ID0gbm9ybWFsc1sgaSBdO1xyXG5cdFx0XHR5ID0gbm9ybWFsc1sgaSArIDEgXTtcclxuXHRcdFx0eiA9IG5vcm1hbHNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRuID0gMS4wIC8gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcclxuXHJcblx0XHRcdG5vcm1hbHNbIGkgXSAqPSBuO1xyXG5cdFx0XHRub3JtYWxzWyBpICsgMSBdICo9IG47XHJcblx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gKj0gbjtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNCxcclxuXHRcdFx0XHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXHJcblxyXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XHJcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuXHRcdFx0XHRhcnJheTogYXJyYXlcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xyXG5cdFx0XHRcdGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXHJcblx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcblx0XHRcdFx0YXJyYXk6IGFycmF5XHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcclxuXHJcblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XHJcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxyXG5cdFx0XHRcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cdFx0XHR0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA2NTUzNTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICovXHJcblxyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknO1xyXG5cdHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB1bmRlZmluZWQ7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluc3RhbmNlcyApIHtcclxuXHJcblx0dGhpcy5ncm91cHMucHVzaCgge1xyXG5cclxuXHRcdHN0YXJ0OiBzdGFydCxcclxuXHRcdGNvdW50OiBjb3VudCxcclxuXHRcdGluc3RhbmNlczogaW5zdGFuY2VzXHJcblxyXG5cdH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHR2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XHJcblxyXG5cdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XHJcblxyXG5cdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAuaW5zdGFuY2VzICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uQWN0aW9uLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBjbGlwIHRoYXQgaGFzIGJlZW4gZXhwbGljaXRseSBzY2hlZHVsZWQuXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLkFuaW1hdGlvbkFjdGlvbiA9IGZ1bmN0aW9uICggY2xpcCwgc3RhcnRUaW1lLCB0aW1lU2NhbGUsIHdlaWdodCwgbG9vcCApIHtcclxuXHJcblx0aWYgKCBjbGlwID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoICdjbGlwIGlzIG51bGwnICk7XHJcblx0dGhpcy5jbGlwID0gY2xpcDtcclxuXHR0aGlzLmxvY2FsUm9vdCA9IG51bGw7XHJcblx0dGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWUgfHwgMDtcclxuXHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZSB8fCAxO1xyXG5cdHRoaXMud2VpZ2h0ID0gd2VpZ2h0IHx8IDE7XHJcblx0dGhpcy5sb29wID0gbG9vcCB8fCBUSFJFRS5Mb29wUmVwZWF0O1xyXG5cdHRoaXMubG9vcENvdW50ID0gMDtcclxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1x0Ly8gYWxsb3cgZm9yIGVhc3kgZGlzYWJsaW5nIG9mIHRoZSBhY3Rpb24uXHJcblxyXG5cdHRoaXMuYWN0aW9uVGltZSA9IC0gdGhpcy5zdGFydFRpbWU7XHJcblx0dGhpcy5jbGlwVGltZSA9IDA7XHJcblxyXG5cdHRoaXMucHJvcGVydHlCaW5kaW5ncyA9IFtdO1xyXG59O1xyXG5cclxuLypcclxuVEhSRUUuTG9vcE9uY2UgPSAyMjAwO1xyXG5USFJFRS5Mb29wUmVwZWF0ID0gMjIwMTtcclxuVEhSRUUuTG9vcFBpbmdQaW5nID0gMjIwMjtcclxuKi9cclxuXHJcblRIUkVFLkFuaW1hdGlvbkFjdGlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25BY3Rpb24sXHJcblxyXG5cdHNldExvY2FsUm9vdDogZnVuY3Rpb24oIGxvY2FsUm9vdCApIHtcclxuXHJcblx0XHR0aGlzLmxvY2FsUm9vdCA9IGxvY2FsUm9vdDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGltZTogZnVuY3Rpb24oIGNsaXBEZWx0YVRpbWUgKSB7XHJcblxyXG5cdFx0dmFyIHByZXZpb3VzQ2xpcFRpbWUgPSB0aGlzLmNsaXBUaW1lO1xyXG4gICBcdFx0dmFyIHByZXZpb3VzTG9vcENvdW50ID0gdGhpcy5sb29wQ291bnQ7XHJcbiAgIFx0XHR2YXIgcHJldmlvdXNBY3Rpb25UaW1lID0gdGhpcy5hY3Rpb25UaW1lO1xyXG5cclxuXHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuY2xpcC5kdXJhdGlvbjtcclxuXHJcblx0XHR0aGlzLmFjdGlvblRpbWUgPSB0aGlzLmFjdGlvblRpbWUgKyBjbGlwRGVsdGFUaW1lO1xyXG5cclxuXHRcdGlmICggdGhpcy5sb29wID09PSBUSFJFRS5Mb29wT25jZSApIHtcclxuXHJcblx0XHRcdHRoaXMubG9vcENvdW50ID0gMDtcclxuXHRcdFx0dGhpcy5jbGlwVGltZSA9IE1hdGgubWluKCBNYXRoLm1heCggdGhpcy5hY3Rpb25UaW1lLCAwICksIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0XHQvLyBpZiB0aW1lIGlzIGNoYW5nZWQgc2luY2UgbGFzdCB0aW1lLCBzZWUgaWYgd2UgaGF2ZSBoaXQgYSBzdGFydC9lbmQgbGltaXRcclxuXHRcdFx0aWYgKCB0aGlzLmNsaXBUaW1lICE9PSBwcmV2aW91c0NsaXBUaW1lICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRoaXMuY2xpcFRpbWUgPT09IGR1cmF0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWl4ZXIuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsIGRpcmVjdGlvbjogMSB9ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuY2xpcFRpbWUgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taXhlci5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcywgZGlyZWN0aW9uOiAtMSB9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGlwVGltZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5sb29wQ291bnQgPSBNYXRoLmZsb29yKCB0aGlzLmFjdGlvblRpbWUgLyBkdXJhdGlvbiApO1xyXG5cclxuXHRcdHZhciBuZXdDbGlwVGltZSA9IHRoaXMuYWN0aW9uVGltZSAtIHRoaXMubG9vcENvdW50ICogZHVyYXRpb247XHJcblx0XHRuZXdDbGlwVGltZSA9IG5ld0NsaXBUaW1lICUgZHVyYXRpb247XHJcblxyXG5cdFx0Ly8gaWYgd2UgYXJlIHBpbmcgcG9uZyBsb29waW5nLCBlbnN1cmUgdGhhdCB3ZSBnbyBiYWNrd2FyZHMgd2hlbiBhcHByb3ByaWF0ZVxyXG5cdFx0aWYgKCB0aGlzLmxvb3AgPT0gVEhSRUUuTG9vcFBpbmdQb25nICkge1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggdGhpcy5sb29wQ291bnQgJSAyICkgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdG5ld0NsaXBUaW1lID0gZHVyYXRpb24gLSBuZXdDbGlwVGltZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jbGlwVGltZSA9IG5ld0NsaXBUaW1lO1xyXG5cclxuXHRcdGlmICggdGhpcy5sb29wQ291bnQgIT09IHByZXZpb3VzTG9vcENvdW50ICkge1xyXG5cclxuICAgXHRcdFx0dGhpcy5taXhlci5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdsb29wJywgYWN0aW9uOiB0aGlzLCBsb29wRGVsdGE6ICggdGhpcy5sb29wQ291bnQgLSB0aGlzLmxvb3BDb3VudCApIH0gKTtcclxuXHJcbiAgIFx0XHR9XHJcblxyXG5cdCAgIFx0cmV0dXJuIHRoaXMuY2xpcFRpbWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN5bmNXaXRoOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdHRoaXMuYWN0aW9uVGltZSA9IGFjdGlvbi5hY3Rpb25UaW1lO1xyXG5cdFx0dGhpcy50aW1lU2NhbGUgPSBhY3Rpb24udGltZVNjYWxlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHdhcnBUb0R1cmF0aW9uOiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aGlzLmNsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRpbml0OiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcblx0XHR0aGlzLmNsaXBUaW1lID0gdGltZSAtIHRoaXMuc3RhcnRUaW1lO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKCBjbGlwRGVsdGFUaW1lICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlVGltZSggY2xpcERlbHRhVGltZSApO1xyXG5cclxuXHRcdHZhciBjbGlwUmVzdWx0cyA9IHRoaXMuY2xpcC5nZXRBdCggdGhpcy5jbGlwVGltZSApO1xyXG5cclxuXHRcdHJldHVybiBjbGlwUmVzdWx0cztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VGltZVNjYWxlQXQ6IGZ1bmN0aW9uKCB0aW1lICkge1xyXG5cclxuXHRcdGlmICggdGhpcy50aW1lU2NhbGUuZ2V0QXQgKSB7XHJcblx0XHRcdC8vIHBhc3MgaW4gdGltZSwgbm90IGNsaXAgdGltZSwgYWxsb3dzIGZvciBmYWRlaW4vZmFkZW91dCBhY3Jvc3MgbXVsdGlwbGUgbG9vcHMgb2YgdGhlIGNsaXBcclxuXHRcdFx0cmV0dXJuIHRoaXMudGltZVNjYWxlLmdldEF0KCB0aW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnRpbWVTY2FsZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0V2VpZ2h0QXQ6IGZ1bmN0aW9uKCB0aW1lICkge1xyXG5cclxuXHRcdGlmICggdGhpcy53ZWlnaHQuZ2V0QXQgKSB7XHJcblx0XHRcdC8vIHBhc3MgaW4gdGltZSwgbm90IGNsaXAgdGltZSwgYWxsb3dzIGZvciBmYWRlaW4vZmFkZW91dCBhY3Jvc3MgbXVsdGlwbGUgbG9vcHMgb2YgdGhlIGNsaXBcclxuXHRcdFx0cmV0dXJuIHRoaXMud2VpZ2h0LmdldEF0KCB0aW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLndlaWdodDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9BbmltYXRpb25DbGlwLmpzXHJcblxyXG4vKipcclxuICpcclxuICogUmV1c2FibGUgc2V0IG9mIFRyYWNrcyB0aGF0IHJlcHJlc2VudCBhbiBhbmltYXRpb24uXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLkFuaW1hdGlvbkNsaXAgPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKSB7XHJcblxyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcblx0dGhpcy50cmFja3MgPSB0cmFja3M7XHJcblx0dGhpcy5kdXJhdGlvbiA9ICggZHVyYXRpb24gIT09IHVuZGVmaW5lZCApID8gZHVyYXRpb24gOiAtMTtcclxuXHJcblx0Ly8gdGhpcyBtZWFucyBpdCBzaG91bGQgZmlndXJlIG91dCBpdHMgZHVyYXRpb24gYnkgc2Nhbm5pbmcgdGhlIHRyYWNrc1xyXG5cdGlmICggdGhpcy5kdXJhdGlvbiA8IDAgKSB7XHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblx0XHRcdHZhciB0cmFjayA9IHRoaXMudHJhY2tzW2ldO1xyXG5cdFx0XHR0aGlzLmR1cmF0aW9uID0gTWF0aC5tYXgoIHRyYWNrLmtleXNbIHRyYWNrLmtleXMubGVuZ3RoIC0gMSBdLnRpbWUgKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1heWJlIG9ubHkgZG8gdGhlc2Ugb24gZGVtYW5kLCBhcyBkb2luZyB0aGVtIGhlcmUgY291bGQgcG90ZW50aWFsbHkgc2xvdyBkb3duIGxvYWRpbmdcclxuXHQvLyBidXQgbGVhdmluZyB0aGVzZSBoZXJlIGR1cmluZyBkZXZlbG9wbWVudCBhcyB0aGlzIGVuc3VyZXMgYSBsb3Qgb2YgdGVzdGluZyBvZiB0aGVzZSBmdW5jdGlvbnNcclxuXHR0aGlzLnRyaW0oKTtcclxuXHR0aGlzLm9wdGltaXplKCk7XHJcblxyXG5cdHRoaXMucmVzdWx0cyA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFuaW1hdGlvbkNsaXAucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQW5pbWF0aW9uQ2xpcCxcclxuXHJcblx0Z2V0QXQ6IGZ1bmN0aW9uKCBjbGlwVGltZSApIHtcclxuXHJcblx0XHRjbGlwVGltZSA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggY2xpcFRpbWUsIHRoaXMuZHVyYXRpb24gKSApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB0cmFjayA9IHRoaXMudHJhY2tzWyBpIF07XHJcblxyXG5cdFx0XHR0aGlzLnJlc3VsdHNbIGkgXSA9IHRyYWNrLmdldEF0KCBjbGlwVGltZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZXN1bHRzO1xyXG5cdH0sXHJcblxyXG5cdHRyaW06IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudHJhY2tzWyBpIF0udHJpbSggMCwgdGhpcy5kdXJhdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudHJhY2tzWyBpIF0ub3B0aW1pemUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcC5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSA9IGZ1bmN0aW9uKCBuYW1lLCBtb3JwaFRhcmdldFNlcXVlbmNlLCBmcHMgKSB7XHJcblxyXG5cclxuXHR2YXIgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XHJcblx0dmFyIHRyYWNrcyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGtleXMgPSBbXTtcclxuXHJcblx0XHRrZXlzLnB1c2goIHsgdGltZTogKCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLCB2YWx1ZTogMCB9ICk7XHJcblx0XHRrZXlzLnB1c2goIHsgdGltZTogaSwgdmFsdWU6IDEgfSApO1xyXG5cdFx0a2V5cy5wdXNoKCB7IHRpbWU6ICggaSArIDEgKSAlIG51bU1vcnBoVGFyZ2V0cywgdmFsdWU6IDAgfSApO1xyXG5cclxuXHRcdGtleXMuc29ydCggVEhSRUUuS2V5ZnJhbWVUcmFjay5rZXlDb21wYXJlciApO1xyXG5cclxuXHRcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZSBsYXN0IGZyYW1lIGFzIHdlbGwgZm9yIHBlcmZlY3QgbG9vcC5cclxuXHRcdGlmICgga2V5c1swXS50aW1lID09PSAwICkge1xyXG5cdFx0XHRrZXlzLnB1c2goIHtcclxuXHRcdFx0XHR0aW1lOiBudW1Nb3JwaFRhcmdldHMsXHJcblx0XHRcdFx0dmFsdWU6IGtleXNbMF0udmFsdWVcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJhY2tzLnB1c2goIG5ldyBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrKCAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhUYXJnZXRTZXF1ZW5jZVtpXS5uYW1lICsgJ10nLCBrZXlzICkuc2NhbGUoIDEuMCAvIGZwcyApICk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIG5hbWUsIC0xLCB0cmFja3MgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb25DbGlwLmZpbmRCeU5hbWUgPSBmdW5jdGlvbiggY2xpcEFycmF5LCBuYW1lICkge1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdGlmICggY2xpcEFycmF5W2ldLm5hbWUgPT09IG5hbWUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2xpcEFycmF5W2ldO1xyXG5cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFuaW1hdGlvbkNsaXAuQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMgPSBmdW5jdGlvbiggbW9ycGhUYXJnZXRzLCBmcHMgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xyXG5cclxuXHQvLyB0ZXN0ZWQgd2l0aCBodHRwczovL3JlZ2V4MTAxLmNvbS8gb24gdHJpY2sgc2VxdWVuY2VzIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxyXG5cdHZhciBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLztcclxuXHJcblx0Ly8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkIHBhdHRlcm5zIGxpa2UgV2Fsa18wMDEsIFdhbGtfMDAyLCBSdW5fMDAxLCBSdW5fMDAyXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcclxuXHRcdHZhciBwYXJ0cyA9IG1vcnBoVGFyZ2V0Lm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcclxuXHJcblx0XHRpZiAoIHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG5cdFx0XHR2YXIgbmFtZSA9IHBhcnRzWyAxIF07XHJcblxyXG5cdFx0XHR2YXIgYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXTtcclxuXHRcdFx0aWYgKCAhIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyApIHtcclxuXHRcdFx0XHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR2YXIgY2xpcHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIG5hbWUgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0Y2xpcHMucHVzaCggVEhSRUUuQW5pbWF0aW9uQ2xpcC5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSwgZnBzICkgKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjbGlwcztcclxuXHJcbn07XHJcblxyXG4vLyBwYXJzZSB0aGUgc3RhbmRhcmQgSlNPTiBmb3JtYXQgZm9yIGNsaXBzXHJcblRIUkVFLkFuaW1hdGlvbkNsaXAucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcblx0dmFyIHRyYWNrcyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dHJhY2tzLnB1c2goIFRIUkVFLktleWZyYW1lVHJhY2sucGFyc2UoIGpzb24udHJhY2tzW2ldICkuc2NhbGUoIDEuMCAvIGpzb24uZnBzICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIGpzb24ubmFtZSwganNvbi5kdXJhdGlvbiwgdHJhY2tzICk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIHBhcnNlIHRoZSBhbmltYXRpb24uaGllcmFyY2h5IGZvcm1hdFxyXG5USFJFRS5BbmltYXRpb25DbGlwLnBhcnNlQW5pbWF0aW9uID0gZnVuY3Rpb24oIGFuaW1hdGlvbiwgYm9uZXMsIG5vZGVOYW1lICkge1xyXG5cclxuXHRpZiAoICEgYW5pbWF0aW9uICkge1xyXG5cdFx0Y29uc29sZS5lcnJvciggXCIgIG5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGFcIiApO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHR2YXIgY29udmVydFRyYWNrID0gZnVuY3Rpb24oIHRyYWNrTmFtZSwgYW5pbWF0aW9uS2V5cywgcHJvcGVydHlOYW1lLCB0cmFja1R5cGUsIGFuaW1hdGlvbktleVRvVmFsdWVGdW5jICkge1xyXG5cclxuXHRcdHZhciBrZXlzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYW5pbWF0aW9uS2V5ID0gYW5pbWF0aW9uS2V5c1trXTtcclxuXHJcblx0XHRcdGlmICggYW5pbWF0aW9uS2V5W3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0a2V5cy5wdXNoKCB7IHRpbWU6IGFuaW1hdGlvbktleS50aW1lLCB2YWx1ZTogYW5pbWF0aW9uS2V5VG9WYWx1ZUZ1bmMoIGFuaW1hdGlvbktleSApIH0gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBvbmx5IHJldHVybiB0cmFjayBpZiB0aGVyZSBhcmUgYWN0dWFsbHkga2V5cy5cclxuXHRcdGlmICgga2V5cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0cmFja1R5cGUoIHRyYWNrTmFtZSwga2V5cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHRyYWNrcyA9IFtdO1xyXG5cclxuXHR2YXIgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XHJcblx0dmFyIGR1cmF0aW9uID0gYW5pbWF0aW9uLmxlbmd0aCB8fCAtMTsgLy8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXHJcblx0dmFyIGZwcyA9IGFuaW1hdGlvbi5mcHMgfHwgMzA7XHJcblxyXG5cdHZhciBoaWVyYXJjaHlUcmFja3MgPSBhbmltYXRpb24uaGllcmFyY2h5IHx8IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xyXG5cclxuXHRcdHZhciBhbmltYXRpb25LZXlzID0gaGllcmFyY2h5VHJhY2tzWyBoIF0ua2V5cztcclxuXHJcblx0XHQvLyBza2lwIGVtcHR5IHRyYWNrc1xyXG5cdFx0aWYgKCAhIGFuaW1hdGlvbktleXMgfHwgYW5pbWF0aW9uS2V5cy5sZW5ndGggPT0gMCApIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzIGluIGEgd2F5IGV4YWN0bHkgY29tcGF0aWJsZSB3aXRoIEFuaW1hdGlvbkhhbmRsZXIuaW5pdCggYW5pbWF0aW9uIClcclxuXHRcdGlmICggYW5pbWF0aW9uS2V5c1swXS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHQvLyBmaWd1cmUgb3V0IGFsbCBtb3JwaCB0YXJnZXRzIHVzZWQgaW4gdGhpcyB0cmFja1xyXG5cdFx0XHR2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xyXG5cdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cyApIHtcclxuXHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0TmFtZXNbIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzW21dIF0gPSAtMTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVybyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaCB0aGUgbW9ycGhUYXJnZXQgaXMgbmFtZWQuXHJcblx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGtleXMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtIDwgYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzW2tdO1xyXG5cclxuXHRcdFx0XHRcdGtleXMucHVzaCgge1xyXG5cdFx0XHRcdFx0XHRcdHRpbWU6IGFuaW1hdGlvbktleS50aW1lLFxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiAoKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0cmFja3MucHVzaCggbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIG5vZGVOYW1lICsgJy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCBrZXlzICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGR1cmF0aW9uID0gbW9ycGhUYXJnZXROYW1lcy5sZW5ndGggKiAoIGZwcyB8fCAxLjAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIGJvbmVOYW1lID0gbm9kZU5hbWUgKyAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XHJcblxyXG5cdFx0XHQvLyB0cmFjayBjb250YWlucyBwb3NpdGlvbnMuLi5cclxuXHRcdFx0dmFyIHBvc2l0aW9uVHJhY2sgPSBjb252ZXJ0VHJhY2soIGJvbmVOYW1lICsgJy5wb3NpdGlvbicsIGFuaW1hdGlvbktleXMsICdwb3MnLCBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLCBmdW5jdGlvbiggYW5pbWF0aW9uS2V5ICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCkuZnJvbUFycmF5KCBhbmltYXRpb25LZXkucG9zIClcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2l0aW9uVHJhY2sgKSB0cmFja3MucHVzaCggcG9zaXRpb25UcmFjayApO1xyXG5cclxuXHRcdFx0Ly8gdHJhY2sgY29udGFpbnMgcXVhdGVybmlvbnMuLi5cclxuXHRcdFx0dmFyIHF1YXRlcm5pb25UcmFjayA9IGNvbnZlcnRUcmFjayggYm9uZU5hbWUgKyAnLnF1YXRlcm5pb24nLCBhbmltYXRpb25LZXlzLCAncm90JywgVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGZ1bmN0aW9uKCBhbmltYXRpb25LZXkgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbktleS5yb3Quc2xlcnAgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBhbmltYXRpb25LZXkucm90LmNsb25lKCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5mcm9tQXJyYXkoIGFuaW1hdGlvbktleS5yb3QgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRpZiAoIHF1YXRlcm5pb25UcmFjayApIHRyYWNrcy5wdXNoKCBxdWF0ZXJuaW9uVHJhY2sgKTtcclxuXHJcblx0XHRcdC8vIHRyYWNrIGNvbnRhaW5zIHF1YXRlcm5pb25zLi4uXHJcblx0XHRcdHZhciBzY2FsZVRyYWNrID0gY29udmVydFRyYWNrKCBib25lTmFtZSArICcuc2NhbGUnLCBhbmltYXRpb25LZXlzLCAnc2NsJywgVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaywgZnVuY3Rpb24oIGFuaW1hdGlvbktleSApIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMygpLmZyb21BcnJheSggYW5pbWF0aW9uS2V5LnNjbCApXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0aWYgKCBzY2FsZVRyYWNrICkgdHJhY2tzLnB1c2goIHNjYWxlVHJhY2sgKTtcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoIHRyYWNrcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGNsaXAgPSBuZXcgVEhSRUUuQW5pbWF0aW9uQ2xpcCggY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKTtcclxuXHJcblx0cmV0dXJuIGNsaXA7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvbk1peGVyLmpzXHJcblxyXG4vKipcclxuICpcclxuICogTWl4ZXMgdG9nZXRoZXIgdGhlIEFuaW1hdGlvbkNsaXBzIHNjaGVkdWxlZCBieSBBbmltYXRpb25BY3Rpb25zIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIHJvb3QgYW5kIHN1YnRyZWVcclxuICpcclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIgPSBmdW5jdGlvbiggcm9vdCApIHtcclxuXHJcblx0dGhpcy5yb290ID0gcm9vdDtcclxuXHR0aGlzLnRpbWUgPSAwO1xyXG5cdHRoaXMudGltZVNjYWxlID0gMS4wO1xyXG5cdHRoaXMuYWN0aW9ucyA9IFtdO1xyXG5cdHRoaXMucHJvcGVydHlCaW5kaW5nTWFwID0ge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQW5pbWF0aW9uTWl4ZXIsXHJcblxyXG5cdGFkZEFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcblx0XHQvLyBUT0RPOiBjaGVjayBmb3IgZHVwbGljYXRlIGFjdGlvbiBuYW1lcz8gIE9yIHByb3ZpZGUgZWFjaCBhY3Rpb24gd2l0aCBhIFVVSUQ/XHJcblxyXG5cdFx0dGhpcy5hY3Rpb25zLnB1c2goIGFjdGlvbiApO1xyXG5cdFx0YWN0aW9uLmluaXQoIHRoaXMudGltZSApO1xyXG5cdFx0YWN0aW9uLm1peGVyID0gdGhpcztcclxuXHJcblx0XHR2YXIgdHJhY2tzID0gYWN0aW9uLmNsaXAudHJhY2tzO1xyXG5cclxuXHRcdHZhciByb290ID0gYWN0aW9uLmxvY2FsUm9vdCB8fCB0aGlzLnJvb3Q7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB0cmFjayA9IHRyYWNrc1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHByb3BlcnR5QmluZGluZ0tleSA9IHJvb3QudXVpZCArICctJyArIHRyYWNrLm5hbWU7XHJcblx0XHRcdHZhciBwcm9wZXJ0eUJpbmRpbmcgPSB0aGlzLnByb3BlcnR5QmluZGluZ01hcFsgcHJvcGVydHlCaW5kaW5nS2V5IF07XHJcblxyXG5cdFx0XHRpZiAoIHByb3BlcnR5QmluZGluZyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRwcm9wZXJ0eUJpbmRpbmcgPSBuZXcgVEhSRUUuUHJvcGVydHlCaW5kaW5nKCByb290LCB0cmFjay5uYW1lICk7XHJcblx0XHRcdFx0dGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdID0gcHJvcGVydHlCaW5kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcHVzaCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdHJhY2tzLlxyXG5cdFx0XHRhY3Rpb24ucHJvcGVydHlCaW5kaW5ncy5wdXNoKCBwcm9wZXJ0eUJpbmRpbmcgKTtcclxuXHJcblx0XHRcdC8vIHRyYWNrIHVzYWdlcyBvZiBzaGFyZWQgcHJvcGVydHkgYmluZGluZ3MsIGJlY2F1c2UgaWYgd2UgbGVhdmUgdG9vIG1hbnkgYXJvdW5kLCB0aGUgbWl4ZXIgY2FuIGdldCBzbG93XHJcblx0XHRcdHByb3BlcnR5QmluZGluZy5yZWZlcmVuY2VDb3VudCArPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQWxsQWN0aW9uczogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuYWN0aW9uc1tpXS5taXhlciA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVuYmluZCBhbGwgcHJvcGVydHkgYmluZGluZ3NcclxuXHRcdGZvciAoIHZhciBwcm9wZXJ5QmluZGluZ0tleSBpbiB0aGlzLnByb3BlcnR5QmluZGluZ01hcCApIHtcclxuXHJcblx0XHRcdHRoaXMucHJvcGVydHlCaW5kaW5nTWFwWyBwcm9wZXJ5QmluZGluZ0tleSBdLnVuYmluZCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmFjdGlvbnMgPSBbXTtcclxuXHRcdHRoaXMucHJvcGVydHlCaW5kaW5nTWFwID0ge307XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmFjdGlvbnMuaW5kZXhPZiggYWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0dGhpcy5hY3Rpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHRcdFx0YWN0aW9uLm1peGVyID0gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIHJlbW92ZSB1bnVzZWQgcHJvcGVydHkgYmluZGluZ3MgYmVjYXVzZSBpZiB3ZSBsZWF2ZSB0aGVtIGFyb3VuZCB0aGUgbWl4ZXIgY2FuIGdldCBzbG93XHJcblx0XHR2YXIgcm9vdCA9IGFjdGlvbi5sb2NhbFJvb3QgfHwgdGhpcy5yb290O1xyXG5cdFx0dmFyIHRyYWNrcyA9IGFjdGlvbi5jbGlwLnRyYWNrcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHRyYWNrID0gdHJhY2tzWyBpIF07XHJcblxyXG5cdFx0XHR2YXIgcHJvcGVydHlCaW5kaW5nS2V5ID0gcm9vdC51dWlkICsgJy0nICsgdHJhY2submFtZTtcclxuXHRcdFx0dmFyIHByb3BlcnR5QmluZGluZyA9IHRoaXMucHJvcGVydHlCaW5kaW5nTWFwWyBwcm9wZXJ0eUJpbmRpbmdLZXkgXTtcclxuXHJcblx0XHRcdHByb3BlcnR5QmluZGluZy5yZWZlcmVuY2VDb3VudCAtPSAxO1xyXG5cclxuXHRcdFx0aWYgKCBwcm9wZXJ0eUJpbmRpbmcucmVmZXJlbmNlQ291bnQgPD0gMCApIHtcclxuXHJcblx0XHRcdFx0cHJvcGVydHlCaW5kaW5nLnVuYmluZCgpO1xyXG5cclxuXHRcdFx0XHRkZWxldGUgdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBjYW4gYmUgb3B0aW1pemVkIGlmIG5lZWRlZFxyXG5cdGZpbmRBY3Rpb25CeU5hbWU6IGZ1bmN0aW9uKCBuYW1lICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYWN0aW9uc1tpXS5uYW1lID09PSBuYW1lICkgcmV0dXJuIHRoaXMuYWN0aW9uc1tpXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBsYXk6IGZ1bmN0aW9uKCBhY3Rpb24sIG9wdGlvbmFsRmFkZUluRHVyYXRpb24gKSB7XHJcblxyXG5cdFx0YWN0aW9uLnN0YXJ0VGltZSA9IHRoaXMudGltZTtcclxuXHRcdHRoaXMuYWRkQWN0aW9uKCBhY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZmFkZU91dDogZnVuY3Rpb24oIGFjdGlvbiwgZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0dmFyIGtleXMgPSBbXTtcclxuXHJcblx0XHRrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lLCB2YWx1ZTogMSB9ICk7XHJcblx0XHRrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lICsgZHVyYXRpb24sIHZhbHVlOiAwIH0gKTtcclxuXHJcblx0XHRhY3Rpb24ud2VpZ2h0ID0gbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIFwid2VpZ2h0XCIsIGtleXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZmFkZUluOiBmdW5jdGlvbiggYWN0aW9uLCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHR2YXIga2V5cyA9IFtdO1xyXG5cclxuXHRcdGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUsIHZhbHVlOiAwIH0gKTtcclxuXHRcdGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUgKyBkdXJhdGlvbiwgdmFsdWU6IDEgfSApO1xyXG5cclxuXHRcdGFjdGlvbi53ZWlnaHQgPSBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggXCJ3ZWlnaHRcIiwga2V5cyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR3YXJwOiBmdW5jdGlvbiggYWN0aW9uLCBzdGFydFRpbWVTY2FsZSwgZW5kVGltZVNjYWxlLCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHR2YXIga2V5cyA9IFtdO1xyXG5cclxuXHRcdGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUsIHZhbHVlOiBzdGFydFRpbWVTY2FsZSB9ICk7XHJcblx0XHRrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lICsgZHVyYXRpb24sIHZhbHVlOiBlbmRUaW1lU2NhbGUgfSApO1xyXG5cclxuXHRcdGFjdGlvbi50aW1lU2NhbGUgPSBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggXCJ0aW1lU2NhbGVcIiwga2V5cyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zc0ZhZGU6IGZ1bmN0aW9uKCBmYWRlT3V0QWN0aW9uLCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xyXG5cclxuXHRcdHRoaXMuZmFkZU91dCggZmFkZU91dEFjdGlvbiwgZHVyYXRpb24gKTtcclxuXHRcdHRoaXMuZmFkZUluKCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0aWYgKCB3YXJwICkge1xyXG5cclxuXHRcdFx0dmFyIHN0YXJ0RW5kUmF0aW8gPSBmYWRlT3V0QWN0aW9uLmNsaXAuZHVyYXRpb24gLyBmYWRlSW5BY3Rpb24uY2xpcC5kdXJhdGlvbjtcclxuXHRcdFx0dmFyIGVuZFN0YXJ0UmF0aW8gPSAxLjAgLyBzdGFydEVuZFJhdGlvO1xyXG5cclxuXHRcdFx0dGhpcy53YXJwKCBmYWRlT3V0QWN0aW9uLCAxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uICk7XHJcblx0XHRcdHRoaXMud2FycCggZmFkZUluQWN0aW9uLCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKCBkZWx0YVRpbWUgKSB7XHJcblxyXG5cdFx0dmFyIG1peGVyRGVsdGFUaW1lID0gZGVsdGFUaW1lICogdGhpcy50aW1lU2NhbGU7XHJcblx0XHR0aGlzLnRpbWUgKz0gbWl4ZXJEZWx0YVRpbWU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbaV07XHJcblxyXG5cdFx0XHR2YXIgd2VpZ2h0ID0gYWN0aW9uLmdldFdlaWdodEF0KCB0aGlzLnRpbWUgKTtcclxuXHJcblx0XHRcdHZhciBhY3Rpb25UaW1lU2NhbGUgPSBhY3Rpb24uZ2V0VGltZVNjYWxlQXQoIHRoaXMudGltZSApO1xyXG5cdFx0XHR2YXIgYWN0aW9uRGVsdGFUaW1lID0gbWl4ZXJEZWx0YVRpbWUgKiBhY3Rpb25UaW1lU2NhbGU7XHJcblxyXG5cdFx0XHR2YXIgYWN0aW9uUmVzdWx0cyA9IGFjdGlvbi51cGRhdGUoIGFjdGlvbkRlbHRhVGltZSApO1xyXG5cclxuXHRcdFx0aWYgKCBhY3Rpb24ud2VpZ2h0IDw9IDAgfHwgISBhY3Rpb24uZW5hYmxlZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgYWN0aW9uUmVzdWx0cy5sZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBuYW1lID0gYWN0aW9uLmNsaXAudHJhY2tzW2pdLm5hbWU7XHJcblxyXG5cdFx0XHRcdGFjdGlvbi5wcm9wZXJ0eUJpbmRpbmdzWyBqIF0uYWNjdW11bGF0ZSggYWN0aW9uUmVzdWx0c1tqXSwgd2VpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFwcGx5IHRvIG5vZGVzXHJcblx0XHRmb3IgKCB2YXIgcHJvcGVydHlCaW5kaW5nS2V5IGluIHRoaXMucHJvcGVydHlCaW5kaW5nTWFwICkge1xyXG5cclxuXHRcdFx0dGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdLmFwcGx5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlICk7XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb25VdGlscyA9IHtcclxuXHJcblx0Z2V0RXF1YWxzRnVuYzogZnVuY3Rpb24oIGV4ZW1wbGFyVmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCBleGVtcGxhclZhbHVlLmVxdWFscyApIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGVxdWFsc19vYmplY3QoIGEsIGIgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGEuZXF1YWxzKCBiICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXF1YWxzX3ByaW1pdGl2ZSggYSwgYiApIHtcclxuXHRcdFx0cmV0dXJuICggYSA9PT0gYiApO1xyXG5cdFx0fTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uKCBleGVtcGxhclZhbHVlICkge1xyXG5cclxuXHRcdHZhciB0eXBlTmFtZSA9IHR5cGVvZiBleGVtcGxhclZhbHVlO1xyXG5cdFx0aWYgKCB0eXBlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcclxuXHRcdFx0aWYgKCBleGVtcGxhclZhbHVlLmNsb25lICkge1xyXG5cdFx0XHRcdHJldHVybiBleGVtcGxhclZhbHVlLmNsb25lKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJjYW4gbm90IGZpZ3VyZSBvdXQgaG93IHRvIGNvcHkgZXhlbXBsYXJWYWx1ZVwiLCBleGVtcGxhclZhbHVlICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV4ZW1wbGFyVmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSwgaW50ZXJUcmFjayApIHtcclxuXHJcblx0XHR2YXIgbGVycEZ1bmMgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRMZXJwRnVuYyggYSwgaW50ZXJUcmFjayApO1xyXG5cclxuXHRcdHJldHVybiBsZXJwRnVuYyggYSwgYiwgYWxwaGEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVycF9vYmplY3Q6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcclxuXHRcdHJldHVybiBhLmxlcnAoIGIsIGFscGhhICk7XHJcblx0fSxcclxuXHJcblx0c2xlcnBfb2JqZWN0OiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcblx0XHRyZXR1cm4gYS5zbGVycCggYiwgYWxwaGEgKTtcclxuXHR9LFxyXG5cclxuXHRsZXJwX251bWJlcjogZnVuY3Rpb24oIGEsIGIsIGFscGhhICkge1xyXG5cdFx0cmV0dXJuIGEgKiAoIDEgLSBhbHBoYSApICsgYiAqIGFscGhhO1xyXG5cdH0sXHJcblxyXG5cdGxlcnBfYm9vbGVhbjogZnVuY3Rpb24oIGEsIGIsIGFscGhhICkge1xyXG5cdFx0cmV0dXJuICggYWxwaGEgPCAwLjUgKSA/IGEgOiBiO1xyXG5cdH0sXHJcblxyXG5cdGxlcnBfYm9vbGVhbl9pbW1lZGlhdGU6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH0sXHJcblxyXG5cdGxlcnBfc3RyaW5nOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcblx0XHRyZXR1cm4gKCBhbHBoYSA8IDAuNSApID8gYSA6IGI7XHJcblx0fSxcclxuXHJcblx0bGVycF9zdHJpbmdfaW1tZWRpYXRlOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcbiBcdFx0cmV0dXJuIGE7XHJcbiBcdH0sXHJcblxyXG5cdC8vIE5PVEU6IHRoaXMgaXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gdGhhdCBtb2RpZmllcyB0aGUgZmlyc3QgYXJndW1lbnQgKGUuZy4gYSkuXHRUaGlzIGlzIHRvIG1pbmltaXplIG1lbW9yeSBhbG9jYXRpb25zLlxyXG5cdGdldExlcnBGdW5jOiBmdW5jdGlvbiggZXhlbXBsYXJWYWx1ZSwgaW50ZXJUcmFjayApIHtcclxuXHJcblx0XHRpZiAoIGV4ZW1wbGFyVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBleGVtcGxhclZhbHVlID09PSBudWxsICkgdGhyb3cgbmV3IEVycm9yKCBcImV4YW1wbGFyVmFsdWUgaXMgbnVsbFwiICk7XHJcblxyXG5cdFx0dmFyIHR5cGVOYW1lID0gdHlwZW9mIGV4ZW1wbGFyVmFsdWU7XHJcblxyXG5cdFx0c3dpdGNoKCB0eXBlTmFtZSApIHtcclxuXHJcblx0XHRcdGNhc2UgXCJvYmplY3RcIjpcclxuXHRcdFx0XHRpZiAoIGV4ZW1wbGFyVmFsdWUubGVycCApIHtcclxuXHRcdFx0XHRcdHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX29iamVjdDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZXhlbXBsYXJWYWx1ZS5zbGVycCApIHtcclxuXHRcdFx0XHRcdHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5zbGVycF9vYmplY3Q7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBcIm51bWJlclwiOlxyXG5cdFx0XHRcdHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX251bWJlcjtcclxuXHJcblx0XHRcdGNhc2UgXCJib29sZWFuXCI6XHJcblx0XHRcdFx0aWYgKCBpbnRlclRyYWNrICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLmxlcnBfYm9vbGVhbjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLmxlcnBfYm9vbGVhbl9pbW1lZGlhdGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxyXG5cdFx0XHRcdGlmICggaW50ZXJUcmFjayApIHtcclxuXHRcdFx0XHRcdHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX3N0cmluZztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLmxlcnBfc3RyaW5nX2ltbWVkaWF0ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0tleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgcmV0dXJucyBhIGtleWZyYW1lIGludGVycG9sYXRlZCB2YWx1ZSwgY3VycmVudGx5IGxpbmVhcmx5IGludGVycG9sYXRlZFxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5LZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCBrZXlzICkge1xyXG5cclxuXHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggXCJ0cmFjayBuYW1lIGlzIHVuZGVmaW5lZFwiICk7XHJcblx0aWYgKCBrZXlzID09PSB1bmRlZmluZWQgfHwga2V5cy5sZW5ndGggPT09IDAgKSB0aHJvdyBuZXcgRXJyb3IoIFwibm8ga2V5cyBpbiB0cmFjayBuYW1lZCBcIiArIG5hbWUgKTtcclxuXHJcblx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHR0aGlzLmtleXMgPSBrZXlzO1x0Ly8gdGltZSBpbiBzZWNvbmRzLCB2YWx1ZSBhcyB2YWx1ZVxyXG5cclxuXHQvLyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgcmVzdWx0LCB1c2VkIGFzIGEgc3RhcnRpbmcgcG9pbnQgZm9yIGxvY2FsIHNlYXJjaC5cclxuXHR0aGlzLmxhc3RJbmRleCA9IDA7XHJcblxyXG5cdHRoaXMudmFsaWRhdGUoKTtcclxuXHR0aGlzLm9wdGltaXplKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5LZXlmcmFtZVRyYWNrLFxyXG5cclxuXHRnZXRBdDogZnVuY3Rpb24oIHRpbWUgKSB7XHJcblxyXG5cclxuXHRcdC8vIHRoaXMgY2FuIG5vdCBnbyBoaWdoZXIgdGhhbiB0aGlzLmtleXMubGVuZ3RoLlxyXG5cdFx0d2hpbGUoICggdGhpcy5sYXN0SW5kZXggPCB0aGlzLmtleXMubGVuZ3RoICkgJiYgKCB0aW1lID49IHRoaXMua2V5c1t0aGlzLmxhc3RJbmRleF0udGltZSApICkge1xyXG5cdFx0XHR0aGlzLmxhc3RJbmRleCArKztcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gdGhpcyBjYW4gbm90IGdvIGxvd2VyIHRoYW4gMC5cclxuXHRcdHdoaWxlKCAoIHRoaXMubGFzdEluZGV4ID4gMCApICYmICggdGltZSA8IHRoaXMua2V5c1t0aGlzLmxhc3RJbmRleCAtIDFdLnRpbWUgKSApIHtcclxuXHRcdFx0dGhpcy5sYXN0SW5kZXggLS07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmxhc3RJbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRSZXN1bHQoIHRoaXMua2V5c1sgdGhpcy5rZXlzLmxlbmd0aCAtIDEgXS52YWx1ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucmVzdWx0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMubGFzdEluZGV4ID09PSAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRSZXN1bHQoIHRoaXMua2V5c1sgMCBdLnZhbHVlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZXN1bHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmV2S2V5ID0gdGhpcy5rZXlzWyB0aGlzLmxhc3RJbmRleCAtIDEgXTtcclxuXHRcdHRoaXMuc2V0UmVzdWx0KCBwcmV2S2V5LnZhbHVlICk7XHJcblxyXG5cdFx0Ly8gaWYgdHJ1ZSwgbWVhbnMgdGhhdCBwcmV2L2N1cnJlbnQga2V5cyBhcmUgaWRlbnRpY2FsLCB0aHVzIG5vIGludGVycG9sYXRpb24gcmVxdWlyZWQuXHJcblx0XHRpZiAoIHByZXZLZXkuY29uc3RhbnRUb05leHQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZXN1bHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uIHRvIHN0YXJ0IHdpdGhcclxuXHRcdHZhciBjdXJyZW50S2V5ID0gdGhpcy5rZXlzWyB0aGlzLmxhc3RJbmRleCBdO1xyXG5cdFx0dmFyIGFscGhhID0gKCB0aW1lIC0gcHJldktleS50aW1lICkgLyAoIGN1cnJlbnRLZXkudGltZSAtIHByZXZLZXkudGltZSApO1xyXG5cdFx0dGhpcy5yZXN1bHQgPSB0aGlzLmxlcnBWYWx1ZXMoIHRoaXMucmVzdWx0LCBjdXJyZW50S2V5LnZhbHVlLCBhbHBoYSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJlc3VsdDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gbW92ZSBhbGwga2V5ZnJhbWVzIGVpdGhlciBmb3J3YXJkcyBvciBiYWNrd2FyZHMgaW4gdGltZVxyXG5cdHNoaWZ0OiBmdW5jdGlvbiggdGltZU9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblx0XHRcdFx0dGhpcy5rZXlzW2ldLnRpbWUgKz0gdGltZU9mZnNldDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gc2NhbGUgYWxsIGtleWZyYW1lIHRpbWVzIGJ5IGEgZmFjdG9yICh1c2VmdWwgZm9yIGZyYW1lIDwtPiBzZWNvbmRzIGNvbnZlcnNpb25zKVxyXG5cdHNjYWxlOiBmdW5jdGlvbiggdGltZVNjYWxlICkge1xyXG5cclxuXHRcdGlmICggdGltZVNjYWxlICE9PSAxLjAgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cdFx0XHRcdHRoaXMua2V5c1tpXS50aW1lICo9IHRpbWVTY2FsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXHJcblx0Ly8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xyXG4gXHR0cmltOiBmdW5jdGlvbiggc3RhcnRUaW1lLCBlbmRUaW1lICkge1xyXG5cclxuXHRcdHZhciBmaXJzdEtleXNUb1JlbW92ZSA9IDA7XHJcblx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cdFx0XHRpZiAoIHRoaXMua2V5c1tpXSA8PSBzdGFydFRpbWUgKSB7XHJcblx0XHRcdFx0Zmlyc3RLZXlzVG9SZW1vdmUgKys7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGFzdEtleXNUb1JlbW92ZSA9IDA7XHJcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMua2V5cy5sZW5ndGggLSAyOyBpID4gMDsgaSArKyApIHtcclxuXHRcdFx0aWYgKCB0aGlzLmtleXNbaV0gPj0gZW5kVGltZSApIHtcclxuXHRcdFx0XHRsYXN0S2V5c1RvUmVtb3ZlICsrO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIGxhc3Qga2V5cyBmaXJzdCBiZWNhdXNlIGl0IGRvZXNuJ3QgYWZmZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qga2V5cyAodGhlIG90aGVyd2F5IGFyb3VuZCBkb2Vzbid0IHdvcmsgYXMgZWFzaWx5KVxyXG5cdFx0aWYgKCAoIGZpcnN0S2V5c1RvUmVtb3ZlICsgbGFzdEtleXNUb1JlbW92ZSApID4gMCApIHtcclxuXHRcdFx0dGhpcy5rZXlzID0gdGhpcy5rZXlzLnNwbGljZSggZmlyc3RLZXlzVG9SZW1vdmUsIHRoaXMua2V5cy5sZW5ndGggLSBsYXN0S2V5c1RvUmVtb3ZlIC0gZmlyc3RLZXlzVG9SZW1vdmUgKTs7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8qIE5PVEU6IFRoaXMgaXMgY29tbWVudGVkIG91dCBiZWNhdXNlIHdlIHJlYWxseSBzaG91bGRuJ3QgaGF2ZSB0byBoYW5kbGUgdW5zb3J0ZWQga2V5IGxpc3RzXHJcblx0ICAgICAgICAgVHJhY2tzIHdpdGggb3V0IG9mIG9yZGVyIGtleXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgdG8gYmUgaW52YWxpZC4gIC0gYmhvdXN0b25cclxuXHRzb3J0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR0aGlzLmtleXMuc29ydCggVEhSRUUuS2V5ZnJhbWVUcmFjay5rZXlDb21wYXJlciApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LCovXHJcblxyXG5cdC8vIGVuc3VyZSB3ZSBkbyBub3QgZ2V0IGEgR2FyYmFnZUluR2FyYmFnZU91dCBzaXR1YXRpb24sIG1ha2Ugc3VyZSB0cmFja3MgYXJlIGF0IGxlYXN0IG1pbmltYWxseSB2aWFibGVcclxuXHQvLyBPbmUgY291bGQgZXZlbnR1YWxseSBlbnN1cmUgdGhhdCBhbGwga2V5LnZhbHVlcyBpbiBhIHRyYWNrIGFyZSBhbGwgb2YgdGhlIHNhbWUgdHlwZSAob3RoZXJ3aXNlIGludGVycG9sYXRpb24gbWFrZXMgbm8gc2Vuc2UuKVxyXG5cdHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgcHJldktleSA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmtleXMubGVuZ3RoID09PSAwICkge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJhY2sgaXMgZW1wdHksIG5vIGtleXNcIiwgdGhpcyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjdXJyS2V5ID0gdGhpcy5rZXlzW2ldO1xyXG5cclxuXHRcdFx0aWYgKCAhIGN1cnJLZXkgKSB7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCIgIGtleSBpcyBudWxsIGluIHRyYWNrXCIsIHRoaXMsIGkgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggKCB0eXBlb2YgY3VycktleS50aW1lICkgIT09ICdudW1iZXInIHx8IGlzTmFOKCBjdXJyS2V5LnRpbWUgKSApIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAga2V5LnRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGksIGN1cnJLZXkgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggY3VycktleS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGN1cnJLZXkudmFsdWUgPT09IG51bGwpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAga2V5LnZhbHVlIGlzIG51bGwgaW4gdHJhY2tcIiwgdGhpcywgaSwgY3VycktleSApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwcmV2S2V5ICYmIHByZXZLZXkudGltZSA+IGN1cnJLZXkudGltZSApIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAga2V5LnRpbWUgaXMgbGVzcyB0aGFuIHByZXZpb3VzIGtleSB0aW1lLCBvdXQgb2Ygb3JkZXIga2V5c1wiLCB0aGlzLCBpLCBjdXJyS2V5LCBwcmV2S2V5ICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwcmV2S2V5ID0gY3VycktleTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGN1cnJlbnRseSBvbmx5IHJlbW92ZXMgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgKDAsMCwwLDAsMSwxLDEsMCwwLDAsMCwwLDAsMCkgLS0+ICgwLDAsMSwxLDAsMCksIHdoaWNoIGFyZSBjb21tb24gaW4gbW9ycGggdGFyZ2V0IGFuaW1hdGlvbnNcclxuXHRvcHRpbWl6ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIG5ld0tleXMgPSBbXTtcclxuXHRcdHZhciBwcmV2S2V5ID0gdGhpcy5rZXlzWzBdO1xyXG5cdFx0bmV3S2V5cy5wdXNoKCBwcmV2S2V5ICk7XHJcblxyXG5cdFx0dmFyIGVxdWFsc0Z1bmMgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRFcXVhbHNGdW5jKCBwcmV2S2V5LnZhbHVlICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAxOyBpIDwgdGhpcy5rZXlzLmxlbmd0aCAtIDE7IGkgKysgKSB7XHJcblx0XHRcdHZhciBjdXJyS2V5ID0gdGhpcy5rZXlzW2ldO1xyXG5cdFx0XHR2YXIgbmV4dEtleSA9IHRoaXMua2V5c1tpKzFdO1xyXG5cclxuXHRcdFx0Ly8gaWYgcHJldktleSAmIGN1cnJLZXkgYXJlIHRoZSBzYW1lIHRpbWUsIHJlbW92ZSBjdXJyS2V5LiAgSWYgeW91IHdhbnQgaW1tZWRpYXRlIGFkamFjZW50IGtleXMsIHVzZSBhbiBlcHNpbG9uIG9mZnNldFxyXG5cdFx0XHQvLyBpdCBpcyBub3QgcG9zc2libGUgdG8gaGF2ZSB0d28ga2V5cyBhdCB0aGUgc2FtZSB0aW1lIGFzIHdlIHNvcnQgdGhlbS4gIFRoZSBzb3J0IGlzIG5vdCBzdGFibGUgb24ga2V5cyB3aXRoIHRoZSBzYW1lIHRpbWUuXHJcblx0XHRcdGlmICggKCBwcmV2S2V5LnRpbWUgPT09IGN1cnJLZXkudGltZSApICkge1xyXG5cclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHJlbW92ZSBjb21wbGV0ZWx5IHVubmVjZXNzYXJ5IGtleWZyYW1lcyB0aGF0IGFyZSB0aGUgc2FtZSBhcyB0aGVpciBwcmV2IGFuZCBuZXh0IGtleXNcclxuXHRcdFx0aWYgKCB0aGlzLmNvbXBhcmVWYWx1ZXMoIHByZXZLZXkudmFsdWUsIGN1cnJLZXkudmFsdWUgKSAmJiB0aGlzLmNvbXBhcmVWYWx1ZXMoIGN1cnJLZXkudmFsdWUsIG5leHRLZXkudmFsdWUgKSApIHtcclxuXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBkZXRlcm1pbmUgaWYgaW50ZXJwb2xhdGlvbiBpcyByZXF1aXJlZFxyXG5cdFx0XHRwcmV2S2V5LmNvbnN0YW50VG9OZXh0ID0gdGhpcy5jb21wYXJlVmFsdWVzKCBwcmV2S2V5LnZhbHVlLCBjdXJyS2V5LnZhbHVlICk7XHJcblxyXG5cdFx0XHRuZXdLZXlzLnB1c2goIGN1cnJLZXkgKTtcclxuXHRcdFx0cHJldktleSA9IGN1cnJLZXk7XHJcblx0XHR9XHJcblx0XHRuZXdLZXlzLnB1c2goIHRoaXMua2V5c1sgdGhpcy5rZXlzLmxlbmd0aCAtIDEgXSApO1xyXG5cclxuXHRcdHRoaXMua2V5cyA9IG5ld0tleXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5LZXlmcmFtZVRyYWNrLmtleUNvbXBhcmVyID0gZnVuY3Rpb24ga2V5Q29tcGFyYXRvcihrZXkwLCBrZXkxKSB7XHJcblx0cmV0dXJuIGtleTAudGltZSAtIGtleTEudGltZTtcclxufTtcclxuXHJcblRIUkVFLktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcblx0aWYgKCBqc29uLnR5cGUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggXCJ0cmFjayB0eXBlIHVuZGVmaW5lZCwgY2FuIG5vdCBwYXJzZVwiICk7XHJcblxyXG5cdHZhciB0cmFja1R5cGUgPSBUSFJFRS5LZXlmcmFtZVRyYWNrLkdldFRyYWNrVHlwZUZvclR5cGVOYW1lKCBqc29uLnR5cGUgKTtcclxuXHJcblx0cmV0dXJuIHRyYWNrVHlwZS5wYXJzZSgganNvbiApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLktleWZyYW1lVHJhY2suR2V0VHJhY2tUeXBlRm9yVHlwZU5hbWUgPSBmdW5jdGlvbiggdHlwZU5hbWUgKSB7XHJcblx0c3dpdGNoKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xyXG5cdCBcdGNhc2UgXCJ2ZWN0b3JcIjpcclxuXHQgXHRjYXNlIFwidmVjdG9yMlwiOlxyXG5cdCBcdGNhc2UgXCJ2ZWN0b3IzXCI6XHJcblx0IFx0Y2FzZSBcInZlY3RvcjRcIjpcclxuXHRcdFx0cmV0dXJuIFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2s7XHJcblxyXG5cdCBcdGNhc2UgXCJxdWF0ZXJuaW9uXCI6XHJcblx0XHRcdHJldHVybiBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0IFx0Y2FzZSBcImludGVnZXJcIjpcclxuXHQgXHRjYXNlIFwic2NhbGFyXCI6XHJcblx0IFx0Y2FzZSBcImRvdWJsZVwiOlxyXG5cdCBcdGNhc2UgXCJmbG9hdFwiOlxyXG5cdCBcdGNhc2UgXCJudW1iZXJcIjpcclxuXHRcdFx0cmV0dXJuIFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2s7XHJcblxyXG5cdCBcdGNhc2UgXCJib29sXCI6XHJcblx0IFx0Y2FzZSBcImJvb2xlYW5cIjpcclxuXHRcdFx0cmV0dXJuIFRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrO1xyXG5cclxuXHQgXHRjYXNlIFwic3RyaW5nXCI6XHJcblx0IFx0XHRyZXR1cm4gVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjaztcclxuXHR9O1xyXG5cclxuXHR0aHJvdyBuZXcgRXJyb3IoIFwiVW5zdXBwb3J0ZWQgdHlwZU5hbWU6IFwiICsgdHlwZU5hbWUgKTtcclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9Qcm9wZXJ0eUJpbmRpbmcuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIHRyYWNrIGJvdW5kIHRvIGEgcmVhbCB2YWx1ZSBpbiB0aGUgc2NlbmUgZ3JhcGguXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLlByb3BlcnR5QmluZGluZyA9IGZ1bmN0aW9uICggcm9vdE5vZGUsIHRyYWNrTmFtZSApIHtcclxuXHJcblx0dGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xyXG5cdHRoaXMudHJhY2tOYW1lID0gdHJhY2tOYW1lO1xyXG5cdHRoaXMucmVmZXJlbmNlQ291bnQgPSAwO1xyXG5cdHRoaXMub3JpZ2luYWxWYWx1ZSA9IG51bGw7IC8vIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYmVmb3JlIGl0IHdhcyBjb250cm9sbGVkIGJ5IHRoaXMgYmluZGluZ1xyXG5cclxuXHR2YXIgcGFyc2VSZXN1bHRzID0gVEhSRUUuUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCB0cmFja05hbWUgKTtcclxuXHJcblx0dGhpcy5kaXJlY3RvcnlOYW1lID0gcGFyc2VSZXN1bHRzLmRpcmVjdG9yeU5hbWU7XHJcblx0dGhpcy5ub2RlTmFtZSA9IHBhcnNlUmVzdWx0cy5ub2RlTmFtZTtcclxuXHR0aGlzLm9iamVjdE5hbWUgPSBwYXJzZVJlc3VsdHMub2JqZWN0TmFtZTtcclxuXHR0aGlzLm9iamVjdEluZGV4ID0gcGFyc2VSZXN1bHRzLm9iamVjdEluZGV4O1xyXG5cdHRoaXMucHJvcGVydHlOYW1lID0gcGFyc2VSZXN1bHRzLnByb3BlcnR5TmFtZTtcclxuXHR0aGlzLnByb3BlcnR5SW5kZXggPSBwYXJzZVJlc3VsdHMucHJvcGVydHlJbmRleDtcclxuXHJcblx0dGhpcy5ub2RlID0gVEhSRUUuUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKCByb290Tm9kZSwgdGhpcy5ub2RlTmFtZSApIHx8IHJvb3ROb2RlO1xyXG5cclxuXHR0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IG51bGw7XHJcblx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxufTtcclxuXHJcblRIUkVFLlByb3BlcnR5QmluZGluZy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcsXHJcblxyXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IG51bGw7XHJcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhY2N1bXVsYXRlOiBmdW5jdGlvbiggdmFsdWUsIHdlaWdodCApIHtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5pc0JvdW5kICkgdGhpcy5iaW5kKCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHdlaWdodCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5jdW11bGF0aXZlVmFsdWUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHR0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmNsb25lKCB2YWx1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSB3ZWlnaHQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBsZXJwQWxwaGEgPSB3ZWlnaHQgLyAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCArIHdlaWdodCApO1xyXG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IHRoaXMubGVycFZhbHVlKCB0aGlzLmN1bXVsYXRpdmVWYWx1ZSwgdmFsdWUsIGxlcnBBbHBoYSApO1xyXG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgKz0gd2VpZ2h0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5pc0JvdW5kICkgcmV0dXJuO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWUoIHRoaXMub3JpZ2luYWxWYWx1ZSApO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWUgPSBudWxsO1xyXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IG51bGw7XHJcblx0XHR0aGlzLmxlcnBWYWx1ZSA9IG51bGw7XHJcblx0XHR0aGlzLmVxdWFsc1ZhbHVlID0gbnVsbDtcclxuXHRcdHRoaXMudHJpZ2dlckRpcnR5ID0gbnVsbDtcclxuXHRcdHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBiaW5kIHRvIHRoZSByZWFsIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaCwgcmVtZW1iZXIgb3JpZ2luYWwgdmFsdWUsIG1lbW9yaXplIHZhcmlvdXMgYWNjZXNzb3JzIGZvciBzcGVlZC9pbmVmZmljaWVuY3lcclxuXHRiaW5kOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuaXNCb3VuZCApIHJldHVybjtcclxuXHJcblx0XHR2YXIgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlO1xyXG5cclxuIFx0XHQvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXHJcblx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogXCIgKyB0aGlzLnRyYWNrTmFtZSArIFwiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5vYmplY3ROYW1lICkge1xyXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2Ugd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cclxuXHRcdFx0aWYgKCB0aGlzLm9iamVjdE5hbWUgPT09IFwibWF0ZXJpYWxzXCIgKSB7XHJcblx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbCApIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBtYXRlcmlhbCBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbCcsIHRoaXMgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMgKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheScsIHRoaXMgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscztcclxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vYmplY3ROYW1lID09PSBcImJvbmVzXCIgKSB7XHJcblx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5za2VsZXRvbiApIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbicsIHRoaXMgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlciwgYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxyXG5cclxuXHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Quc2tlbGV0b24uYm9uZXM7XHJcblxyXG5cdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBpICsrICkge1xyXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbaV0ubmFtZSA9PT0gdGhpcy5vYmplY3RJbmRleCApIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5vYmplY3RJbmRleCA9IGk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbIHRoaXMub2JqZWN0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlLCB1bmRlZmluZWQnLCB0aGlzICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgdGhpcy5vYmplY3ROYW1lIF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy5vYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyB0aGlzLm9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkOlwiLCB0aGlzLCB0YXJnZXRPYmplY3QgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgdGhpcy5vYmplY3RJbmRleCBdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuIFx0XHQvLyBzcGVjaWFsIGNhc2UgbWFwcGluZ3NcclxuIFx0XHR2YXIgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdO1xyXG5cdFx0aWYgKCAhIG5vZGVQcm9wZXJ0eSApIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvciggXCIgIHRyeWluZyB0byB1cGRhdGUgcHJvcGVydHkgZm9yIHRyYWNrOiBcIiArIHRoaXMubm9kZU5hbWUgKyAnLicgKyB0aGlzLnByb3BlcnR5TmFtZSArIFwiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIsIHRhcmdldE9iamVjdCApO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXHJcblx0XHRpZiAoIHRoaXMucHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnByb3BlcnR5TmFtZSA9PT0gXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIiApIHtcclxuXHRcdFx0XHQvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cclxuXHJcblx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxyXG5cdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkgKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2FzdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5JywgdGhpcyApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXN1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhUYXJnZXRzJywgdGhpcyApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgKysgKSB7XHJcblx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHNbaV0ubmFtZSA9PT0gdGhpcy5wcm9wZXJ0eUluZGV4ICkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnByb3BlcnR5SW5kZXggPSBpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZV9wcm9wZXJ0eUluZGV4ZWQoIHZhbHVlICkge1xyXG5cdFx0XHRcdGlmICggISB0aGlzLmVxdWFsc1ZhbHVlKCBub2RlUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdLCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0bm9kZVByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZV9wcm9wZXJ0eUluZGV4ZWQoKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5vZGVQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF07XHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cdFx0Ly8gbXVzdCB1c2UgY29weSBmb3IgT2JqZWN0M0QuRXVsZXIvUXVhdGVybmlvblxyXG5cdFx0ZWxzZSBpZiAoIG5vZGVQcm9wZXJ0eS5jb3B5ICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlX3Byb3BlcnR5T2JqZWN0KCB2YWx1ZSApIHtcclxuXHRcdFx0XHRpZiAoICEgdGhpcy5lcXVhbHNWYWx1ZSggbm9kZVByb3BlcnR5LCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0bm9kZVByb3BlcnR5LmNvcHkoIHZhbHVlICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWVfcHJvcGVydHlPYmplY3QoKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5vZGVQcm9wZXJ0eTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblx0XHQvLyBvdGhlcndpc2UganVzdCBzZXQgdGhlIHByb3BlcnR5IGRpcmVjdGx5IG9uIHRoZSBub2RlIChkbyBub3QgdXNlIG5vZGVQcm9wZXJ0eSBhcyBpdCBtYXkgbm90IGJlIGEgcmVmZXJlbmNlIG9iamVjdClcclxuXHRcdGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlX3Byb3BlcnR5KCB2YWx1ZSApIHtcclxuXHRcdFx0XHRpZiAoICEgdGhpcy5lcXVhbHNWYWx1ZSggdGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdLCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0dGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWVfcHJvcGVydHkoKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdHJpZ2dlciBub2RlIGRpcnR5XHJcblx0XHRpZiAoIHRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBtYXRlcmlhbFxyXG5cclxuXHRcdFx0dGhpcy50cmlnZ2VyRGlydHkgPSBmdW5jdGlvbiB0cmlnZ2VyRGlydHlfbmVlZHNVcGRhdGUoKSB7XHJcblx0XHRcdFx0dGhpcy5ub2RlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG5vZGUgdHJhbnNmb3JtXHJcblxyXG5cdFx0XHR0aGlzLnRyaWdnZXJEaXJ0eSA9IGZ1bmN0aW9uIHRyaWdnZXJEaXJ0eV9tYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCkge1xyXG5cdFx0XHRcdHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9yaWdpbmFsVmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XHJcblxyXG5cdFx0dGhpcy5lcXVhbHNWYWx1ZSA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmdldEVxdWFsc0Z1bmMoIHRoaXMub3JpZ2luYWxWYWx1ZSApO1xyXG5cdFx0dGhpcy5sZXJwVmFsdWUgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRMZXJwRnVuYyggdGhpcy5vcmlnaW5hbFZhbHVlLCB0cnVlICk7XHJcblxyXG5cdFx0dGhpcy5pc0JvdW5kID0gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHk6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdC8vIGZvciBzcGVlZCBjYXB0dXJlIHRoZSBzZXR0ZXIgcGF0dGVybiBhcyBhIGNsb3N1cmUgKHNvcnQgb2YgYSBtZW1vaXphdGlvbiBwYXR0ZXJuOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1vaXphdGlvbilcclxuXHRcdGlmICggISB0aGlzLmlzQm91bmQgKSB0aGlzLmJpbmQoKTtcclxuXHJcblx0XHQvLyBlYXJseSBleGl0IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYXBwbHkuXHJcblx0XHRpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBibGVuZCB3aXRoIG9yaWdpbmFsIHZhbHVlXHJcblx0XHRcdGlmICggdGhpcy5jdW11bGF0aXZlV2VpZ2h0IDwgMSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHJlbWFpbmluZ1dlaWdodCA9IDEgLSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQ7XHJcblx0XHRcdFx0dmFyIGxlcnBBbHBoYSA9IHJlbWFpbmluZ1dlaWdodCAvICggdGhpcy5jdW11bGF0aXZlV2VpZ2h0ICsgcmVtYWluaW5nV2VpZ2h0ICk7XHJcblx0XHRcdFx0dGhpcy5jdW11bGF0aXZlVmFsdWUgPSB0aGlzLmxlcnBWYWx1ZSggdGhpcy5jdW11bGF0aXZlVmFsdWUsIHRoaXMub3JpZ2luYWxWYWx1ZSwgbGVycEFscGhhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmFsdWVDaGFuZ2VkID0gdGhpcy5zZXRWYWx1ZSggdGhpcy5jdW11bGF0aXZlVmFsdWUgKTtcclxuXHJcblx0XHRcdGlmICggdmFsdWVDaGFuZ2VkICYmIHRoaXMudHJpZ2dlckRpcnR5ICkge1xyXG5cdFx0XHRcdHRoaXMudHJpZ2dlckRpcnR5KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHJlc2V0IGFjY3VtdWxhdG9yXHJcblx0XHRcdHRoaXMuY3VtdWxhdGl2ZVZhbHVlID0gbnVsbDtcclxuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUgPSBmdW5jdGlvbiggdHJhY2tOYW1lICkge1xyXG5cclxuXHQvLyBtYXRjaGVzIHN0cmluZ3MgaW4gdGhlIGZvcm0gb2Y6XHJcblx0Ly8gICAgbm9kZU5hbWUucHJvcGVydHlcclxuXHQvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuXHQvLyAgICBub2RlTmFtZS5tYXRlcmlhbC5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuXHQvLyAgICB1dWlkLnByb3BlcnR5W2FjY2Vzc29yXVxyXG5cdC8vICAgIHV1aWQub2JqZWN0TmFtZVtvYmplY3RJbmRleF0ucHJvcGVydHlOYW1lW3Byb3BlcnR5SW5kZXhdXHJcblx0Ly8gICAgcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVxyXG5cdC8vICAgIHBhcmVudE5hbWUvcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVtpbmRleF1cclxuXHQvL1x0ICAuYm9uZVtBcm1hdHVyZS5ERUZfY29nXS5wb3NpdGlvblxyXG5cdC8vIGNyZWF0ZWQgYW5kIHRlc3RlZCB2aWEgaHR0cHM6Ly9yZWdleDEwMS5jb20vI2phdmFzY3JpcHRcclxuXHJcblx0dmFyIHJlID0gL14oKFtcXHddK1xcLykqKShbXFx3LVxcZF0rKT8oXFwuKFtcXHddKykoXFxbKFtcXHdcXGRcXFtcXF1cXF8uIF0rKVxcXSk/KT8oXFwuKFtcXHcuXSspKFxcWyhbXFx3XFxkXFxbXFxdXFxfLiBdKylcXF0pPykkLztcclxuXHR2YXIgbWF0Y2hlcyA9IHJlLmV4ZWModHJhY2tOYW1lKTtcclxuXHJcblx0aWYgKCAhIG1hdGNoZXMgKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2Fubm90IHBhcnNlIHRyYWNrTmFtZSBhdCBhbGw6IFwiICsgdHJhY2tOYW1lICk7XHJcblx0fVxyXG5cclxuICAgIGlmIChtYXRjaGVzLmluZGV4ID09PSByZS5sYXN0SW5kZXgpIHtcclxuICAgICAgICByZS5sYXN0SW5kZXgrKztcclxuICAgIH1cclxuXHJcblx0dmFyIHJlc3VsdHMgPSB7XHJcblx0XHRkaXJlY3RvcnlOYW1lOiBtYXRjaGVzWzFdLFxyXG5cdFx0bm9kZU5hbWU6IG1hdGNoZXNbM10sIFx0Ly8gYWxsb3dlZCB0byBiZSBudWxsLCBzcGVjaWZpZWQgcm9vdCBub2RlLlxyXG5cdFx0b2JqZWN0TmFtZTogbWF0Y2hlc1s1XSxcclxuXHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWzddLFxyXG5cdFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWzldLFxyXG5cdFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sxMV1cdC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgc3BlY2lmaWVzIHRoYXQgdGhlIHdob2xlIHByb3BlcnR5IGlzIHNldC5cclxuXHR9O1xyXG5cclxuXHRpZiAoIHJlc3VsdHMucHJvcGVydHlOYW1lID09PSBudWxsIHx8IHJlc3VsdHMucHJvcGVydHlOYW1lLmxlbmd0aCA9PT0gMCApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvciggXCJjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogXCIgKyB0cmFja05hbWUgKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHRzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlByb3BlcnR5QmluZGluZy5maW5kTm9kZSA9IGZ1bmN0aW9uKCByb290LCBub2RlTmFtZSApIHtcclxuXHJcblx0ZnVuY3Rpb24gc2VhcmNoU2tlbGV0b24oIHNrZWxldG9uICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNrZWxldG9uLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbaV07XHJcblxyXG5cdFx0XHRpZiAoIGJvbmUubmFtZSA9PT0gbm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBib25lO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZHJlbiApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XHJcblxyXG5cdFx0XHRpZiAoIGNoaWxkTm9kZS5uYW1lID09PSBub2RlTmFtZSB8fCBjaGlsZE5vZGUudXVpZCA9PT0gbm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gc2VhcmNoTm9kZVN1YnRyZWUoIGNoaWxkTm9kZS5jaGlsZHJlbiApO1xyXG5cclxuXHRcdFx0aWYgKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRpZiAoICEgbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09IFwiXCIgfHwgbm9kZU5hbWUgPT09IFwicm9vdFwiIHx8IG5vZGVOYW1lID09PSBcIi5cIiB8fCBub2RlTmFtZSA9PT0gLTEgfHwgbm9kZU5hbWUgPT09IHJvb3QubmFtZSB8fCBub2RlTmFtZSA9PT0gcm9vdC51dWlkICkge1xyXG5cclxuXHRcdHJldHVybiByb290O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHNlYXJjaCBpbnRvIHNrZWxldG9uIGJvbmVzLlxyXG5cdGlmICggcm9vdC5za2VsZXRvbiApIHtcclxuXHJcblx0XHR2YXIgYm9uZSA9IHNlYXJjaFNrZWxldG9uKCByb290LnNrZWxldG9uICk7XHJcblxyXG5cdFx0aWYgKCBib25lICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJvbmU7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxyXG5cdGlmICggcm9vdC5jaGlsZHJlbiApIHtcclxuXHJcblx0XHR2YXIgc3ViVHJlZU5vZGUgPSBzZWFyY2hOb2RlU3VidHJlZSggcm9vdC5jaGlsZHJlbiApO1xyXG5cclxuXHRcdGlmICggc3ViVHJlZU5vZGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gc3ViVHJlZU5vZGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vdHJhY2tzL1ZlY3RvcktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFZlY3RvcnNcclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwga2V5cyApIHtcclxuXHJcblx0VEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCBrZXlzICk7XHJcblxyXG5cdC8vIGxvY2FsIGNhY2hlIG9mIHZhbHVlIHR5cGUgdG8gYXZvaWQgYWxsb2NhdGlvbnMgZHVyaW5nIHJ1bnRpbWUuXHJcblx0dGhpcy5yZXN1bHQgPSB0aGlzLmtleXNbMF0udmFsdWUuY2xvbmUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2s7XHJcblxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5zZXRSZXN1bHQgPSBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblxyXG5cdHRoaXMucmVzdWx0LmNvcHkoIHZhbHVlICk7XHJcblxyXG59O1xyXG5cclxuLy8gbWVtb2l6YXRpb24gb2YgdGhlIGxlcnAgZnVuY3Rpb24gZm9yIHNwZWVkLlxyXG4vLyBOT1RFOiBEbyBub3Qgb3B0aW1pemUgYXMgYSBwcm90b3R5cGUgaW5pdGlhbGl6YXRpb24gY2xvc3VyZSwgYXMgdmFsdWUwIHdpbGwgYmUgZGlmZmVyZW50IG9uIGEgcGVyIGNsYXNzIGJhc2lzLlxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5sZXJwVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxLCBhbHBoYSApIHtcclxuXHJcblx0cmV0dXJuIHZhbHVlMC5sZXJwKCB2YWx1ZTEsIGFscGhhICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSApIHtcclxuXHJcblx0cmV0dXJuIHZhbHVlMC5lcXVhbHMoIHZhbHVlMSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBjbG9uZWRLZXlzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGtleSA9IHRoaXMua2V5c1tpXTtcclxuXHRcdGNsb25lZEtleXMucHVzaCgge1xyXG5cdFx0XHR0aW1lOiBrZXkudGltZSxcclxuXHRcdFx0dmFsdWU6IGtleS52YWx1ZS5jbG9uZSgpXHJcblx0XHR9ICk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2soIHRoaXMubmFtZSwgY2xvbmVkS2V5cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcblx0dmFyIGVsZW1lbnRDb3VudCA9IGpzb24ua2V5c1swXS52YWx1ZS5sZW5ndGg7XHJcblx0dmFyIHZhbHVlVHlwZSA9IFRIUkVFWyAnVmVjdG9yJyArIGVsZW1lbnRDb3VudCBdO1xyXG5cclxuXHR2YXIga2V5cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cdFx0dmFyIGpzb25LZXkgPSBqc29uLmtleXNbaV07XHJcblx0XHRrZXlzLnB1c2goIHtcclxuXHRcdFx0dmFsdWU6IG5ldyB2YWx1ZVR5cGUoKS5mcm9tQXJyYXkoIGpzb25LZXkudmFsdWUgKSxcclxuXHRcdFx0dGltZToganNvbktleS50aW1lXHJcblx0XHR9ICk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2soIGpzb24ubmFtZSwga2V5cyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvUXVhdGVybmlvbktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFF1YXRlcm5pb25cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XHJcblxyXG5cdFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xyXG5cclxuXHQvLyBsb2NhbCBjYWNoZSBvZiB2YWx1ZSB0eXBlIHRvIGF2b2lkIGFsbG9jYXRpb25zIGR1cmluZyBydW50aW1lLlxyXG5cdHRoaXMucmVzdWx0ID0gdGhpcy5rZXlzWzBdLnZhbHVlLmNsb25lKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5yZXN1bHQuY29weSggdmFsdWUgKTtcclxuXHJcbn07XHJcblxyXG4vLyBtZW1vaXphdGlvbiBvZiB0aGUgbGVycCBmdW5jdGlvbiBmb3Igc3BlZWQuXHJcbi8vIE5PVEU6IERvIG5vdCBvcHRpbWl6ZSBhcyBhIHByb3RvdHlwZSBpbml0aWFsaXphdGlvbiBjbG9zdXJlLCBhcyB2YWx1ZTAgd2lsbCBiZSBkaWZmZXJlbnQgb24gYSBwZXIgY2xhc3MgYmFzaXMuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5sZXJwVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxLCBhbHBoYSApIHtcclxuXHJcblx0cmV0dXJuIHZhbHVlMC5zbGVycCggdmFsdWUxLCBhbHBoYSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb21wYXJlVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxICkge1xyXG5cclxuXHRyZXR1cm4gdmFsdWUwLmVxdWFscyggdmFsdWUxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oIHF1YXQgKSB7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5rZXlzW2ldLnZhbHVlLm11bHRpcGx5KCBxdWF0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBjbG9uZWRLZXlzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGtleSA9IHRoaXMua2V5c1tpXTtcclxuXHRcdGNsb25lZEtleXMucHVzaCgge1xyXG5cdFx0XHR0aW1lOiBrZXkudGltZSxcclxuXHRcdFx0dmFsdWU6IGtleS52YWx1ZS5jbG9uZSgpXHJcblx0XHR9ICk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuXHR2YXIga2V5cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cdFx0dmFyIGpzb25LZXkgPSBqc29uLmtleXNbaV07XHJcblx0XHRrZXlzLnB1c2goIHtcclxuXHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuZnJvbUFycmF5KCBqc29uS2V5LnZhbHVlICksXHJcblx0XHRcdHRpbWU6IGpzb25LZXkudGltZVxyXG5cdFx0fSApO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaygganNvbi5uYW1lLCBrZXlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9TdHJpbmdLZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XHJcblxyXG5cdFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xyXG5cclxuXHQvLyBsb2NhbCBjYWNoZSBvZiB2YWx1ZSB0eXBlIHRvIGF2b2lkIGFsbG9jYXRpb25zIGR1cmluZyBydW50aW1lLlxyXG5cdHRoaXMucmVzdWx0ID0gdGhpcy5rZXlzWzBdLnZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjaztcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5yZXN1bHQgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG4vLyBtZW1vaXphdGlvbiBvZiB0aGUgbGVycCBmdW5jdGlvbiBmb3Igc3BlZWQuXHJcbi8vIE5PVEU6IERvIG5vdCBvcHRpbWl6ZSBhcyBhIHByb3RvdHlwZSBpbml0aWFsaXphdGlvbiBjbG9zdXJlLCBhcyB2YWx1ZTAgd2lsbCBiZSBkaWZmZXJlbnQgb24gYSBwZXIgY2xhc3MgYmFzaXMuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLmxlcnBWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEsIGFscGhhICkge1xyXG5cclxuXHRyZXR1cm4gKCBhbHBoYSA8IDEuMCApID8gdmFsdWUwIDogdmFsdWUxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbXBhcmVWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEgKSB7XHJcblxyXG5cdHJldHVybiAoIHZhbHVlMCA9PT0gdmFsdWUxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGNsb25lZEtleXMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xyXG5cdFx0Y2xvbmVkS2V5cy5wdXNoKCB7XHJcblx0XHRcdHRpbWU6IGtleS50aW1lLFxyXG5cdFx0XHR2YWx1ZToga2V5LnZhbHVlXHJcblx0XHR9ICk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2soIHRoaXMubmFtZSwgY2xvbmVkS2V5cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrKCBqc29uLm5hbWUsIGpzb24ua2V5cyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvQm9vbGVhbktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIEJvb2xlYW5cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XHJcblxyXG5cdFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xyXG5cclxuXHQvLyBsb2NhbCBjYWNoZSBvZiB2YWx1ZSB0eXBlIHRvIGF2b2lkIGFsbG9jYXRpb25zIGR1cmluZyBydW50aW1lLlxyXG5cdHRoaXMucmVzdWx0ID0gdGhpcy5rZXlzWzBdLnZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjaztcclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5zZXRSZXN1bHQgPSBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblxyXG5cdHRoaXMucmVzdWx0ID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuLy8gbWVtb2l6YXRpb24gb2YgdGhlIGxlcnAgZnVuY3Rpb24gZm9yIHNwZWVkLlxyXG4vLyBOT1RFOiBEbyBub3Qgb3B0aW1pemUgYXMgYSBwcm90b3R5cGUgaW5pdGlhbGl6YXRpb24gY2xvc3VyZSwgYXMgdmFsdWUwIHdpbGwgYmUgZGlmZmVyZW50IG9uIGEgcGVyIGNsYXNzIGJhc2lzLlxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUubGVycFZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSwgYWxwaGEgKSB7XHJcblxyXG5cdHJldHVybiAoIGFscGhhIDwgMS4wICkgPyB2YWx1ZTAgOiB2YWx1ZTE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbXBhcmVWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEgKSB7XHJcblxyXG5cdHJldHVybiAoIHZhbHVlMCA9PT0gdmFsdWUxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBjbG9uZWRLZXlzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGtleSA9IHRoaXMua2V5c1tpXTtcclxuXHRcdGNsb25lZEtleXMucHVzaCgge1xyXG5cdFx0XHR0aW1lOiBrZXkudGltZSxcclxuXHRcdFx0dmFsdWU6IGtleS52YWx1ZVxyXG5cdFx0fSApO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjayggdGhpcy5uYW1lLCBjbG9uZWRLZXlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjaygganNvbi5uYW1lLCBqc29uLmtleXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vdHJhY2tzL051bWJlcktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIE51bWJlcnNcclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwga2V5cyApIHtcclxuXHJcblx0VEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCBrZXlzICk7XHJcblxyXG5cdC8vIGxvY2FsIGNhY2hlIG9mIHZhbHVlIHR5cGUgdG8gYXZvaWQgYWxsb2NhdGlvbnMgZHVyaW5nIHJ1bnRpbWUuXHJcblx0dGhpcy5yZXN1bHQgPSB0aGlzLmtleXNbMF0udmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrO1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuc2V0UmVzdWx0ID0gZnVuY3Rpb24oIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLnJlc3VsdCA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcbi8vIG1lbW9pemF0aW9uIG9mIHRoZSBsZXJwIGZ1bmN0aW9uIGZvciBzcGVlZC5cclxuLy8gTk9URTogRG8gbm90IG9wdGltaXplIGFzIGEgcHJvdG90eXBlIGluaXRpYWxpemF0aW9uIGNsb3N1cmUsIGFzIHZhbHVlMCB3aWxsIGJlIGRpZmZlcmVudCBvbiBhIHBlciBjbGFzcyBiYXNpcy5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUubGVycFZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSwgYWxwaGEgKSB7XHJcblxyXG5cdHJldHVybiB2YWx1ZTAgKiAoIDEgLSBhbHBoYSApICsgdmFsdWUxICogYWxwaGE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSApIHtcclxuXHJcblx0cmV0dXJuICggdmFsdWUwID09PSB2YWx1ZTEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR2YXIgY2xvbmVkS2V5cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBrZXkgPSB0aGlzLmtleXNbaV07XHJcblx0XHRjbG9uZWRLZXlzLnB1c2goIHtcclxuXHRcdFx0dGltZToga2V5LnRpbWUsXHJcblx0XHRcdHZhbHVlOiBrZXkudmFsdWVcclxuXHRcdH0gKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggdGhpcy5uYW1lLCBjbG9uZWRLZXlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIGpzb24ubmFtZSwganNvbi5rZXlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuKi9cclxuXHJcblRIUkVFLkNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcclxuXHJcblx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5nZXRXb3JsZERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBjYW1lcmFzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcclxuXHJcblx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdG0xLmxvb2tBdCggdGhpcy5wb3NpdGlvbiwgdmVjdG9yLCB0aGlzLnVwICk7XHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DdWJlQ2FtZXJhLmpzXHJcblxyXG4vKipcclxuICogQ2FtZXJhIGZvciByZW5kZXJpbmcgY3ViZSBtYXBzXHJcbiAqXHQtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxyXG4gKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN1YmVDYW1lcmEgPSBmdW5jdGlvbiAoIG5lYXIsIGZhciwgY3ViZVJlc29sdXRpb24gKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xyXG5cclxuXHR2YXIgZm92ID0gOTAsIGFzcGVjdCA9IDE7XHJcblxyXG5cdHZhciBjYW1lcmFQWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYVBYLnVwLnNldCggMCwgLSAxLCAwICk7XHJcblx0Y2FtZXJhUFgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYVBYICk7XHJcblxyXG5cdHZhciBjYW1lcmFOWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYU5YLnVwLnNldCggMCwgLSAxLCAwICk7XHJcblx0Y2FtZXJhTlgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggLSAxLCAwLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhTlggKTtcclxuXHJcblx0dmFyIGNhbWVyYVBZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XHJcblx0Y2FtZXJhUFkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XHJcblxyXG5cdHZhciBjYW1lcmFOWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLSAxICk7XHJcblx0Y2FtZXJhTlkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhTlkgKTtcclxuXHJcblx0dmFyIGNhbWVyYVBaID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhUFoudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRjYW1lcmFQWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhUFogKTtcclxuXHJcblx0dmFyIGNhbWVyYU5aID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRjYW1lcmFOWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFOWiApO1xyXG5cclxuXHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgeyBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyIH0gKTtcclxuXHJcblx0dGhpcy51cGRhdGVDdWJlTWFwID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XHJcblx0XHR2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDA7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAyO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDM7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVDYW1lcmE7XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcclxuXHJcblx0VEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XHJcblxyXG5cdHRoaXMuem9vbSA9IDE7XHJcblxyXG5cdHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0dGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdHRoaXMudG9wID0gdG9wO1xyXG5cdHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG5cclxuXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDAuMTtcclxuXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDIwMDA7XHJcblxyXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmE7XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XHJcblx0dmFyIGR5ID0gKCB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcclxuXHR2YXIgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XHJcblx0dmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xyXG5cclxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggY3ggLSBkeCwgY3ggKyBkeCwgY3kgKyBkeSwgY3kgLSBkeSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cdFxyXG5cdFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHRcclxuXHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcclxuXHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xyXG5cdHRoaXMudG9wID0gc291cmNlLnRvcDtcclxuXHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XHJcblx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XHJcblx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xyXG5cdFxyXG5cdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xyXG5cdFxyXG5cdHJldHVybiB0aGlzO1xyXG5cdFx0XHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcclxuXHRkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xyXG5cdGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcclxuXHRkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcclxuXHRkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcclxuXHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG5cdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBncmVnZ21hbiAvIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICovXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSA9IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcclxuXHJcblx0VEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcclxuXHJcblx0dGhpcy56b29tID0gMTtcclxuXHJcblx0dGhpcy5mb3YgPSBmb3YgIT09IHVuZGVmaW5lZCA/IGZvdiA6IDUwO1xyXG5cdHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xyXG5cdHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XHJcblx0dGhpcy5mYXIgPSBmYXIgIT09IHVuZGVmaW5lZCA/IGZhciA6IDIwMDA7XHJcblxyXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmE7XHJcblxyXG5cclxuLyoqXHJcbiAqIFVzZXMgRm9jYWwgTGVuZ3RoIChpbiBtbSkgdG8gZXN0aW1hdGUgYW5kIHNldCBGT1ZcclxuICogMzVtbSAoZnVsbC1mcmFtZSkgY2FtZXJhIGlzIHVzZWQgaWYgZnJhbWUgc2l6ZSBpcyBub3Qgc3BlY2lmaWVkO1xyXG4gKiBGb3JtdWxhIGJhc2VkIG9uIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoLCBmcmFtZUhlaWdodCApIHtcclxuXHJcblx0aWYgKCBmcmFtZUhlaWdodCA9PT0gdW5kZWZpbmVkICkgZnJhbWVIZWlnaHQgPSAyNDtcclxuXHJcblx0dGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xyXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblxyXG4vKipcclxuICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxyXG4gKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxyXG4gKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXHJcbiAqXHJcbiAqICAgKy0tLSstLS0rLS0tK1xyXG4gKiAgIHwgQSB8IEIgfCBDIHxcclxuICogICArLS0tKy0tLSstLS0rXHJcbiAqICAgfCBEIHwgRSB8IEYgfFxyXG4gKiAgICstLS0rLS0tKy0tLStcclxuICpcclxuICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xyXG4gKlxyXG4gKiAgIHZhciB3ID0gMTkyMDtcclxuICogICB2YXIgaCA9IDEwODA7XHJcbiAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xyXG4gKiAgIHZhciBmdWxsSGVpZ2h0ID0gaCAqIDI7XHJcbiAqXHJcbiAqICAgLS1BLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xyXG4gKiAgIC0tQi0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcclxuICogICAtLUMtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XHJcbiAqICAgLS1ELS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xyXG4gKiAgIC0tRS0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcclxuICogICAtLUYtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XHJcbiAqXHJcbiAqICAgTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cclxuICovXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0Vmlld09mZnNldCA9IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHR0aGlzLmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcclxuXHR0aGlzLmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xyXG5cdHRoaXMueCA9IHg7XHJcblx0dGhpcy55ID0geTtcclxuXHR0aGlzLndpZHRoID0gd2lkdGg7XHJcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGZvdiA9IFRIUkVFLk1hdGgucmFkVG9EZWcoIDIgKiBNYXRoLmF0YW4oIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmZvdiApICogMC41ICkgLyB0aGlzLnpvb20gKSApO1xyXG5cclxuXHRpZiAoIHRoaXMuZnVsbFdpZHRoICkge1xyXG5cclxuXHRcdHZhciBhc3BlY3QgPSB0aGlzLmZ1bGxXaWR0aCAvIHRoaXMuZnVsbEhlaWdodDtcclxuXHRcdHZhciB0b3AgPSBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKSAqIHRoaXMubmVhcjtcclxuXHRcdHZhciBib3R0b20gPSAtIHRvcDtcclxuXHRcdHZhciBsZWZ0ID0gYXNwZWN0ICogYm90dG9tO1xyXG5cdFx0dmFyIHJpZ2h0ID0gYXNwZWN0ICogdG9wO1xyXG5cdFx0dmFyIHdpZHRoID0gTWF0aC5hYnMoIHJpZ2h0IC0gbGVmdCApO1xyXG5cdFx0dmFyIGhlaWdodCA9IE1hdGguYWJzKCB0b3AgLSBib3R0b20gKTtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZUZydXN0dW0oXHJcblx0XHRcdGxlZnQgKyB0aGlzLnggKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxyXG5cdFx0XHRsZWZ0ICsgKCB0aGlzLnggKyB0aGlzLndpZHRoICkgKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxyXG5cdFx0XHR0b3AgLSAoIHRoaXMueSArIHRoaXMuaGVpZ2h0ICkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXHJcblx0XHRcdHRvcCAtIHRoaXMueSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcclxuXHRcdFx0dGhpcy5uZWFyLFxyXG5cdFx0XHR0aGlzLmZhclxyXG5cdFx0KTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBmb3YsIHRoaXMuYXNwZWN0LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cdFxyXG5cdFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHRcclxuXHR0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XHJcblx0dGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xyXG5cdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xyXG5cdHRoaXMuZmFyID0gc291cmNlLmZhcjtcclxuXHRcclxuXHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcclxuXHRcclxuXHRyZXR1cm4gdGhpcztcclxuXHRcdFxyXG59O1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcclxuXHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcclxuXHRkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcclxuXHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG5cdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvTGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTGlnaHQnO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xyXG5cclxuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSB1bmRlZmluZWQ7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpZ2h0O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSwge1xyXG5cdG9ubHlTaGFkb3c6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5vbmx5U2hhZG93IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhRm92OiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5mb3YgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYUxlZnQ6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmxlZnQgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYVJpZ2h0OiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhVG9wOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS50b3AgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYUJvdHRvbToge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dDYW1lcmFOZWFyOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5uZWFyID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dDYW1lcmFGYXI6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZhciA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhVmlzaWJsZToge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVZpc2libGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvdyApIGluc3RlYWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Qmlhczoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5iaWFzID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dEYXJrbmVzczoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5kYXJrbmVzcyA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93TWFwV2lkdGg6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0dGhpcy5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93TWFwSGVpZ2h0OiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cdGlmICggdGhpcy5ncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZ3JvdW5kQ29sb3IgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpO1xyXG5cclxuXHRpZiAoIHRoaXMuaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcclxuXHRpZiAoIHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcclxuXHRpZiAoIHRoaXMuYW5nbGUgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcclxuXHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcclxuXHRpZiAoIHRoaXMuZXhwb25lbnQgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmV4cG9uZW50ID0gdGhpcy5leHBvbmVudDtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0xpZ2h0U2hhZG93LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MaWdodFNoYWRvdyA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xyXG5cclxuXHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0dGhpcy5iaWFzID0gMDtcclxuXHR0aGlzLmRhcmtuZXNzID0gMTtcclxuXHJcblx0dGhpcy5tYXBTaXplID0gbmV3IFRIUkVFLlZlY3RvcjIoIDUxMiwgNTEyICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHR0aGlzLm1hdHJpeCA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGlnaHRTaGFkb3cucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTGlnaHRTaGFkb3csXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuY2FtZXJhID0gc291cmNlLmNhbWVyYS5jbG9uZSgpO1xyXG5cclxuXHRcdHRoaXMuYmlhcyA9IHNvdXJjZS5iaWFzO1xyXG5cdFx0dGhpcy5kYXJrbmVzcyA9IHNvdXJjZS5kYXJrbmVzcztcclxuXHJcblx0XHR0aGlzLm1hcFNpemUuY29weSggc291cmNlLm1hcFNpemUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvQW1iaWVudExpZ2h0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BbWJpZW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcclxuXHJcblx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFtYmllbnRMaWdodDtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XHJcblxyXG5cdHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XHJcblx0dGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cclxuXHR0aGlzLnNoYWRvdyA9IG5ldyBUSFJFRS5MaWdodFNoYWRvdyggbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1MDAsIDUwMCwgNTAwLCAtIDUwMCwgNTAsIDUwMDAgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodDtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuXHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcclxuXHJcblx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodCA9IGZ1bmN0aW9uICggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9yICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XHJcblxyXG5cdHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XHJcblx0dGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggZ3JvdW5kQ29sb3IgKTtcclxuXHR0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xyXG5cdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL1BvaW50TGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblxyXG5USFJFRS5Qb2ludExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcclxuXHJcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcclxuXHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXHJcblxyXG5cdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAxLCA1MDAgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodDtcclxuXHJcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuXHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xyXG5cdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XHJcblxyXG5cdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvU3BvdExpZ2h0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcG90TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgZXhwb25lbnQsIGRlY2F5ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcclxuXHJcblx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcclxuXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHR0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XHJcblx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xyXG5cdHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XHJcblx0dGhpcy5leHBvbmVudCA9ICggZXhwb25lbnQgIT09IHVuZGVmaW5lZCApID8gZXhwb25lbnQgOiAxMDtcclxuXHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXHJcblxyXG5cdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDUwLCAxLCA1MCwgNTAwMCApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0O1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XHJcblx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcclxuXHR0aGlzLmFuZ2xlID0gc291cmNlLmFuZ2xlO1xyXG5cdHRoaXMuZXhwb25lbnQgPSBzb3VyY2UuZXhwb25lbnQ7XHJcblx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcclxuXHJcblx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XHJcblxyXG5cdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NhY2hlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DYWNoZSA9IHtcclxuXHJcblx0ZW5hYmxlZDogZmFsc2UsXHJcblxyXG5cdGZpbGVzOiB7fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIGtleSwgZmlsZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xyXG5cclxuXHRcdHRoaXMuZmlsZXNbIGtleSBdID0gZmlsZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xlYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmZpbGVzID0ge307XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTG9hZGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Mb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTG9hZGVyLFxyXG5cclxuXHRjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxyXG5cclxuXHRleHRyYWN0VXJsQmFzZTogZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0dmFyIHBhcnRzID0gdXJsLnNwbGl0KCAnLycgKTtcclxuXHJcblx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xyXG5cclxuXHRcdHBhcnRzLnBvcCgpO1xyXG5cclxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcclxuXHJcblx0fSxcclxuXHJcblx0aW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyArKyBpICkge1xyXG5cclxuXHRcdFx0YXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcmVhdGVNYXRlcmlhbDogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGNvbG9yLCB0ZXh0dXJlTG9hZGVyLCBtYXRlcmlhbExvYWRlcjtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xyXG5cdFx0XHRpZiAoIHRleHR1cmVMb2FkZXIgPT09IHVuZGVmaW5lZCApIHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xyXG5cdFx0XHRpZiAoIG1hdGVyaWFsTG9hZGVyID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbExvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xyXG5cclxuXHRcdFx0Ly8gY29udmVydCBmcm9tIG9sZCBtYXRlcmlhbCBmb3JtYXRcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIHBhdGgsIHJlcGVhdCwgb2Zmc2V0LCB3cmFwLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZnVsbFBhdGggPSB0ZXh0dXJlUGF0aCArIHBhdGg7XHJcblx0XHRcdFx0dmFyIGxvYWRlciA9IFRIUkVFLkxvYWRlci5IYW5kbGVycy5nZXQoIGZ1bGxQYXRoICk7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZUxvYWRlci5zZXRDcm9zc09yaWdpbiggY3Jvc3NPcmlnaW4gKTtcclxuXHRcdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCByZXBlYXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIHJlcGVhdCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblx0XHRcdFx0XHRpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBvZmZzZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHdyYXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHdyYXBbIDAgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblx0XHRcdFx0XHRpZiAoIHdyYXBbIDAgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZztcclxuXHJcblx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB1dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHRcdFx0dGV4dHVyZXNbIHV1aWQgXSA9IHRleHR1cmU7XHJcblxyXG5cdFx0XHRcdHJldHVybiB1dWlkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHZhciBqc29uID0ge1xyXG5cdFx0XHRcdHV1aWQ6IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCksXHJcblx0XHRcdFx0dHlwZTogJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmFsdWUgPSBtWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XHJcblx0XHRcdFx0XHRjYXNlICdEYmdDb2xvcic6XHJcblx0XHRcdFx0XHRcdGpzb24uY29sb3IgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdEYmdJbmRleCc6XHJcblx0XHRcdFx0XHRjYXNlICdvcHRpY2FsRGVuc2l0eSc6XHJcblx0XHRcdFx0XHRjYXNlICdpbGx1bWluYXRpb24nOlxyXG5cdFx0XHRcdFx0XHQvLyBUaGVzZSB3ZXJlIG5ldmVyIHN1cHBvcnRlZFxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ0RiZ05hbWUnOlxyXG5cdFx0XHRcdFx0XHRqc29uLm5hbWUgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdibGVuZGluZyc6XHJcblx0XHRcdFx0XHRcdGpzb24uYmxlbmRpbmcgPSBUSFJFRVsgdmFsdWUgXTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdjb2xvckRpZmZ1c2UnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmNvbG9yID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yU3BlY3VsYXInOlxyXG5cdFx0XHRcdFx0XHRqc29uLnNwZWN1bGFyID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yRW1pc3NpdmUnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmVtaXNzaXZlID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ3NwZWN1bGFyQ29lZic6XHJcblx0XHRcdFx0XHRcdGpzb24uc2hpbmluZXNzID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnc2hhZGluZyc6XHJcblx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Jhc2ljJyApIGpzb24udHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XHJcblx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZSc6XHJcblx0XHRcdFx0XHRcdGpzb24ubWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VSZXBlYXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZU9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlV3JhcCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHQnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmxpZ2h0TWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFJlcGVhdCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodE9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRBbmlzb3Ryb3B5JzpcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBTyc6XHJcblx0XHRcdFx0XHRcdGpzb24uYW9NYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQU9SZXBlYXQsIG0ubWFwQU9PZmZzZXQsIG0ubWFwQU9XcmFwLCBtLm1hcEFPQW5pc290cm9weSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPT2Zmc2V0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPV3JhcCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBT0FuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXAnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmJ1bXBNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQnVtcFJlcGVhdCwgbS5tYXBCdW1wT2Zmc2V0LCBtLm1hcEJ1bXBXcmFwLCBtLm1hcEJ1bXBBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFNjYWxlJzpcclxuXHRcdFx0XHRcdFx0anNvbi5idW1wU2NhbGUgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBCdW1wUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBPZmZzZXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcEFuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbCc6XHJcblx0XHRcdFx0XHRcdGpzb24ubm9ybWFsTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsRmFjdG9yJzpcclxuXHRcdFx0XHRcdFx0anNvbi5ub3JtYWxTY2FsZSA9IFsgdmFsdWUsIHZhbHVlIF07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbE9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxXcmFwJzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEFuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyJzpcclxuXHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhck1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJSZXBlYXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJPZmZzZXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJXcmFwJzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGEnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmFscGhhTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVJlcGVhdCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYU9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFBbmlzb3Ryb3B5JzpcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdmbGlwU2lkZWQnOlxyXG5cdFx0XHRcdFx0XHRqc29uLnNpZGUgPSBUSFJFRS5CYWNrU2lkZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdkb3VibGVTaWRlZCc6XHJcblx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5JyApO1xyXG5cdFx0XHRcdFx0XHRqc29uLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdvcGFjaXR5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcclxuXHRcdFx0XHRcdGNhc2UgJ2RlcHRoVGVzdCc6XHJcblx0XHRcdFx0XHRjYXNlICdkZXB0aFdyaXRlJzpcclxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcclxuXHRcdFx0XHRcdGNhc2UgJ3Zpc2libGUnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnd2lyZWZyYW1lJzpcclxuXHRcdFx0XHRcdFx0anNvblsgbmFtZSBdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAndmVydGV4Q29sb3JzJzpcclxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIGpzb24udmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xyXG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSAnZmFjZScgKSBqc29uLnZlcnRleENvbG9ycyA9IFRIUkVFLkZhY2VDb2xvcnM7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ0xvYWRlci5jcmVhdGVNYXRlcmlhbDogVW5zdXBwb3J0ZWQnLCBuYW1lLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpzb24udHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLnNwZWN1bGFyO1xyXG5cdFx0XHRpZiAoIGpzb24ub3BhY2l0eSA8IDEgKSBqc29uLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuXHJcblx0XHRcdG1hdGVyaWFsTG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsTG9hZGVyLnBhcnNlKCBqc29uICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKClcclxuXHJcbn07XHJcblxyXG5USFJFRS5Mb2FkZXIuSGFuZGxlcnMgPSB7XHJcblxyXG5cdGhhbmRsZXJzOiBbXSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIHJlZ2V4LCBsb2FkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldDogZnVuY3Rpb24gKCBmaWxlICkge1xyXG5cclxuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xyXG5cclxuXHRcdFx0dmFyIHJlZ2V4ID0gaGFuZGxlcnNbIGkgXTtcclxuXHRcdFx0dmFyIGxvYWRlciAgPSBoYW5kbGVyc1sgaSArIDEgXTtcclxuXHJcblx0XHRcdGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvWEhSTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5YSFJMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlhIUkxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5YSFJMb2FkZXIsXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcclxuXHJcblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSB7XHJcblxyXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRvbkxvYWQoIGNhY2hlZCApO1xyXG5cclxuXHRcdFx0XHR9LCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0cmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XHJcblxyXG5cdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzcG9uc2UgPSBldmVudC50YXJnZXQucmVzcG9uc2U7XHJcblxyXG5cdFx0XHRUSFJFRS5DYWNoZS5hZGQoIHVybCwgcmVzcG9uc2UgKTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xyXG5cclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0XHRvblByb2dyZXNzKCBldmVudCApO1xyXG5cclxuXHRcdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcblx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcblx0XHRpZiAoIHRoaXMucmVzcG9uc2VUeXBlICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xyXG5cdFx0aWYgKCB0aGlzLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcclxuXHJcblx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcclxuXHJcblx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlcXVlc3Q7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJlc3BvbnNlVHlwZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9JbWFnZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSW1hZ2VMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkltYWdlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkltYWdlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XHJcblxyXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICkge1xyXG5cclxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdFx0b25Mb2FkKCBjYWNoZWQgKTtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0XHR9LCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcclxuXHJcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5DYWNoZS5hZGQoIHVybCwgdGhpcyApO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHRpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcblx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cclxuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG5cdFx0cmV0dXJuIGltYWdlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0pTT05Mb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkpTT05Mb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBzaG93U3RhdHVzIHBhcmFtZXRlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gY29uc3RydWN0b3IuJyApO1xyXG5cdFx0bWFuYWdlciA9IHVuZGVmaW5lZDtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkpTT05Mb2FkZXIsXHJcblxyXG5cdC8vIERlcHJlY2F0ZWRcclxuXHJcblx0Z2V0IHN0YXR1c0RvbUVsZW1lbnQgKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IC5zdGF0dXNEb21FbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGhpcy50ZXh0dXJlUGF0aCA6IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdHZhciBqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xyXG5cdFx0XHR2YXIgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xyXG5cclxuXHRcdFx0aWYgKCBtZXRhZGF0YSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1ldGFkYXRhLnR5cGUgPT09ICdvYmplY3QnICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuT2JqZWN0TG9hZGVyIGluc3RlYWQuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggbWV0YWRhdGEudHlwZSA9PT0gJ3NjZW5lJyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLlNjZW5lTG9hZGVyIGluc3RlYWQuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XHJcblx0XHRcdG9uTG9hZCggb2JqZWN0Lmdlb21ldHJ5LCBvYmplY3QubWF0ZXJpYWxzICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXHJcblx0XHRzY2FsZSA9ICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgPyAxLjAgLyBqc29uLnNjYWxlIDogMS4wO1xyXG5cclxuXHRcdHBhcnNlTW9kZWwoIHNjYWxlICk7XHJcblxyXG5cdFx0cGFyc2VTa2luKCk7XHJcblx0XHRwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xyXG5cdFx0cGFyc2VBbmltYXRpb25zKCk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGksIGosIGZpLFxyXG5cclxuXHRcdFx0b2Zmc2V0LCB6TGVuZ3RoLFxyXG5cclxuXHRcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxyXG5cclxuXHRcdFx0dHlwZSxcclxuXHRcdFx0aXNRdWFkLFxyXG5cdFx0XHRoYXNNYXRlcmlhbCxcclxuXHRcdFx0aGFzRmFjZVZlcnRleFV2LFxyXG5cdFx0XHRoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxyXG5cdFx0XHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcclxuXHJcblx0XHR2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXHJcblxyXG5cdFx0XHR1dkxheWVyLCB1diwgdSwgdixcclxuXHJcblx0XHRcdGZhY2VzID0ganNvbi5mYWNlcyxcclxuXHRcdFx0dmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxyXG5cdFx0XHRub3JtYWxzID0ganNvbi5ub3JtYWxzLFxyXG5cdFx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcclxuXHJcblx0XHRcdG5VdkxheWVycyA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gMDtcclxuXHRcdFx0ekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gMDtcclxuXHRcdFx0ekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblxyXG5cdFx0XHRcdGlzUXVhZCAgICAgICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMCApO1xyXG5cdFx0XHRcdGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xyXG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhVdiAgICAgPSBpc0JpdFNldCggdHlwZSwgMyApO1xyXG5cdFx0XHRcdGhhc0ZhY2VOb3JtYWwgICAgICAgPSBpc0JpdFNldCggdHlwZSwgNCApO1xyXG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xyXG5cdFx0XHRcdGhhc0ZhY2VDb2xvclx0ICAgICA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XHJcblx0XHRcdFx0aGFzRmFjZVZlcnRleENvbG9yICA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XHJcblxyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XHJcblxyXG5cdFx0XHRcdGlmICggaXNRdWFkICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VBID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcblx0XHRcdFx0XHRmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xyXG5cdFx0XHRcdFx0ZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XHJcblx0XHRcdFx0XHRmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcclxuXHJcblx0XHRcdFx0XHRmYWNlQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG5cdFx0XHRcdFx0ZmFjZUIuYSA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XHJcblx0XHRcdFx0XHRmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcclxuXHRcdFx0XHRcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCArPSA0O1xyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRmYWNlQS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHRcdFx0XHRcdFx0ZmFjZUIubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxyXG5cclxuXHRcdFx0XHRcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgNDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlQS5ub3JtYWwuc2V0KFxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHRcdFx0XHRcdFx0ZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VBICk7XHJcblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoKTtcclxuXHRcdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXHJcblxyXG5cdFx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcclxuXHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZS5ub3JtYWwuc2V0KFxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5mbHVlbmNlc1BlclZlcnRleCA9ICgganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4ICE9PSB1bmRlZmluZWQgKSA/IGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCA6IDI7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB4ID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luV2VpZ2h0c1sgaSBdO1xyXG5cdFx0XHRcdFx0dmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcclxuXHRcdFx0XHRcdHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XHJcblx0XHRcdFx0XHR2YXIgdyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAzIF0gOiAwO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbkluZGljZXNbIGkgXTtcclxuXHRcdFx0XHRcdHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XHJcblx0XHRcdFx0XHR2YXIgYyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAyIF0gOiAwO1xyXG5cdFx0XHRcdFx0dmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1doZW4gc2tpbm5pbmcsIG51bWJlciBvZiB2ZXJ0aWNlcyAoJyArIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCArICcpLCBza2luSW5kaWNlcyAoJyArXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XHJcblx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHRcdFx0XHRcdHZhciBzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0XHRcdFx0dmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XHJcblx0XHRcdFx0XHRcdHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcclxuXHRcdFx0XHRcdFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRcdFx0ZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IFwibW9ycGhDb2xvcnNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2luZyB0aGVtIGFzIGZhY2UgY29sb3JzLicgKTtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHRcdFx0dmFyIG1vcnBoQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgMCBdLmNvbG9ycztcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlc1sgaSBdLmNvbG9yLmZyb21BcnJheSggbW9ycGhDb2xvcnMsIGkgKiAzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCkge1xyXG5cclxuXHRcdFx0dmFyIG91dHB1dEFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRcdC8vIHBhcnNlIG9sZCBzdHlsZSBCb25lL0hpZXJhcmNoeSBhbmltYXRpb25zXHJcblx0XHRcdHZhciBhbmltYXRpb25zID0gW107XHJcblx0XHRcdGlmICgganNvbi5hbmltYXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGpzb24uYW5pbWF0aW9uICk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCBqc29uLmFuaW1hdGlvbnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9ucy5sZW5ndGggKSB7XHJcblx0XHRcdFx0XHRhbmltYXRpb25zID0gYW5pbWF0aW9ucy5jb25jYXQoIGpzb24uYW5pbWF0aW9ucyApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGpzb24uYW5pbWF0aW9ucyApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjbGlwID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZUFuaW1hdGlvbiggYW5pbWF0aW9uc1tpXSwgZ2VvbWV0cnkuYm9uZXMgKTtcclxuXHRcdFx0XHRpZiAoIGNsaXAgKSBvdXRwdXRBbmltYXRpb25zLnB1c2goIGNsaXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHBhcnNlIGltcGxpY2l0IG1vcnBoIGFuaW1hdGlvbnNcclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBhbiBhcHByb3ByYWl0ZSBGUFMgaXMgZm9yIG1vcnBoIHRhcmdldCBhbmltYXRpb25zIC0tIGRlZmF1bHRpbmcgdG8gMTAsIGJ1dCByZWFsbHkgaXQgaXMgY29tcGxldGVseSBhcmJpdHJhcnkuXHJcblx0XHRcdFx0dmFyIG1vcnBoQW5pbWF0aW9uQ2xpcHMgPSBUSFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMsIDEwICk7XHJcblx0XHRcdFx0b3V0cHV0QW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnMuY29uY2F0KCBtb3JwaEFuaW1hdGlvbkNsaXBzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG91dHB1dEFuaW1hdGlvbnMubGVuZ3RoID4gMCApIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGgsIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcblx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSwgbWF0ZXJpYWxzOiBtYXRlcmlhbHMgfTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRpbmdNYW5hZ2VyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Mb2FkaW5nTWFuYWdlciA9IGZ1bmN0aW9uICggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgaXNMb2FkaW5nID0gZmFsc2UsIGl0ZW1zTG9hZGVkID0gMCwgaXRlbXNUb3RhbCA9IDA7XHJcblxyXG5cdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcclxuXHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcclxuXHR0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xyXG5cdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XHJcblxyXG5cdHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0aXRlbXNUb3RhbCArKztcclxuXHJcblx0XHRpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpc0xvYWRpbmcgPSB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHRpdGVtc0xvYWRlZCArKztcclxuXHJcblx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcclxuXHJcblx0XHRcdGlzTG9hZGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c2NvcGUub25FcnJvciggdXJsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9CdWZmZXJHZW9tZXRyeUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0XHR2YXIgaW5kZXggPSBqc29uLmRhdGEuaW5kZXg7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgc2VsZlsgaW5kZXgudHlwZSBdKCBpbmRleC5hcnJheSApO1xyXG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBzZWxmWyBhdHRyaWJ1dGUudHlwZSBdKCBhdHRyaWJ1dGUuYXJyYXkgKTtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgga2V5LCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ3JvdXBzID0ganNvbi5kYXRhLmdyb3VwcyB8fCBqc29uLmRhdGEuZHJhd2NhbGxzIHx8IGpzb24uZGF0YS5vZmZzZXRzO1xyXG5cclxuXHRcdGlmICggZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XHJcblxyXG5cdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9NYXRlcmlhbExvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWF0ZXJpYWxMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cdHRoaXMudGV4dHVyZXMgPSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRlcmlhbExvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRlcmlhbExvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFRleHR1cmVzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZXMgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VGV4dHVyZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlc1sgbmFtZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsganNvbi50eXBlIF07XHJcblx0XHRtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xyXG5cclxuXHRcdGlmICgganNvbi5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xyXG5cdFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcclxuXHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XHJcblx0XHRpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xyXG5cdFx0aWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XHJcblx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3JtcztcclxuXHRcdGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xyXG5cdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XHJcblx0XHRpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcclxuXHRcdGlmICgganNvbi5zaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGFkaW5nID0ganNvbi5zaGFkaW5nO1xyXG5cdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XHJcblx0XHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcclxuXHRcdGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xyXG5cdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XHJcblx0XHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcclxuXHRcdGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xyXG5cdFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XHJcblx0XHRpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcclxuXHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHRcdC8vIGZvciBQb2ludHNNYXRlcmlhbFxyXG5cdFx0aWYgKCBqc29uLnNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XHJcblx0XHRpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0XHQvLyBtYXBzXHJcblxyXG5cdFx0aWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLm1hcCApO1xyXG5cclxuXHRcdGlmICgganNvbi5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwuYWxwaGFNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uYWxwaGFNYXAgKTtcclxuXHRcdFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5idW1wTWFwICk7XHJcblx0XHRpZiAoIGpzb24uYnVtcFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wU2NhbGUgPSBqc29uLmJ1bXBTY2FsZTtcclxuXHJcblx0XHRpZiAoIGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubm9ybWFsTWFwICk7XHJcblx0XHRpZiAoIGpzb24ubm9ybWFsU2NhbGUgKVx0bWF0ZXJpYWwubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMigganNvbi5ub3JtYWxTY2FsZSwganNvbi5ub3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5kaXNwbGFjZW1lbnRNYXAgKTtcclxuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhck1hcCApO1xyXG5cclxuXHRcdGlmICgganNvbi5lbnZNYXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5lbnZNYXAgKTtcclxuXHRcdFx0bWF0ZXJpYWwuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpzb24ucmVmbGVjdGl2aXR5ICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0ganNvbi5yZWZsZWN0aXZpdHk7XHJcblxyXG5cdFx0aWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xyXG5cdFx0aWYgKCBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGpzb24ubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0aWYgKCBqc29uLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5hb01hcCApO1xyXG5cdFx0aWYgKCBqc29uLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGpzb24uYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0Ly8gTWVzaEZhY2VNYXRlcmlhbFxyXG5cclxuXHRcdGlmICgganNvbi5tYXRlcmlhbHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLnBhcnNlKCBqc29uLm1hdGVyaWFsc1sgaSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9PYmplY3RMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk9iamVjdExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblx0dGhpcy50ZXh0dXJlUGF0aCA9ICcnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9iamVjdExvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3RMb2FkZXIsXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnRleHR1cmVQYXRoID09PSAnJyApIHtcclxuXHJcblx0XHRcdHRoaXMudGV4dHVyZVBhdGggPSB1cmwuc3Vic3RyaW5nKCAwLCB1cmwubGFzdEluZGV4T2YoICcvJyApICsgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICksIG9uTG9hZCApO1xyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMgKTtcclxuXHJcblx0XHR2YXIgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcygganNvbi5pbWFnZXMsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHR2YXIgdGV4dHVyZXMgID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcclxuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcclxuXHJcblx0XHR2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xyXG5cclxuXHRcdGlmICgganNvbi5hbmltYXRpb25zICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJpZXMgPSB7fTtcclxuXHJcblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XHJcblx0XHRcdHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ2VvbWV0cnk7XHJcblx0XHRcdFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdQbGFuZUdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ1BsYW5lQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUVbIGRhdGEudHlwZSBdKFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEud2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHNcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ0JveEdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ0N1YmVHZW9tZXRyeSc6IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGVwdGgsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aFNlZ21lbnRzXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDaXJjbGVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNUb3AsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNCb3R0b20sXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdEb2RlY2FoZWRyb25HZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmRldGFpbFxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdUZXRyYWhlZHJvbkdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1JpbmdHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5pbm5lclJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLm91dGVyUmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdUb3J1c0dlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5hcmNcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudHViZSxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnEsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTY2FsZVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YS5kYXRhLCB0aGlzLnRleHR1cmVQYXRoICkuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJyArIGRhdGEudHlwZSArICdcIicgKTtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cmllcztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFscyA9IHt9O1xyXG5cclxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xyXG5cdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSgganNvblsgaSBdICk7XHJcblx0XHRcdFx0bWF0ZXJpYWxzWyBtYXRlcmlhbC51dWlkIF0gPSBtYXRlcmlhbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFscztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VBbmltYXRpb25zOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjbGlwID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZSgganNvbltpXSApO1xyXG5cclxuXHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhbmltYXRpb25zO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZUltYWdlczogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHRcdHZhciBpbWFnZXMgPSB7fTtcclxuXHJcblx0XHRmdW5jdGlvbiBsb2FkSW1hZ2UoIHVybCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBtYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcclxuXHJcblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKTtcclxuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbWFnZSA9IGpzb25bIGkgXTtcclxuXHRcdFx0XHR2YXIgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggaW1hZ2UudXJsICkgPyBpbWFnZS51cmwgOiBzY29wZS50ZXh0dXJlUGF0aCArIGltYWdlLnVybDtcclxuXHJcblx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBsb2FkSW1hZ2UoIHBhdGggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGltYWdlcztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VUZXh0dXJlczogZnVuY3Rpb24gKCBqc29uLCBpbWFnZXMgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VDb25zdGFudCggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHR5cGVvZiggdmFsdWUgKSA9PT0gJ251bWJlcicgKSByZXR1cm4gdmFsdWU7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gVEhSRUVbIHZhbHVlIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xyXG5cclxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLmltYWdlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBcImltYWdlXCIgc3BlY2lmaWVkIGZvcicsIGRhdGEudXVpZCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggaW1hZ2VzWyBkYXRhLmltYWdlIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSApO1xyXG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XHJcblx0XHRcdFx0aWYgKCBkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFwcGluZyApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEub2Zmc2V0WyAwIF0sIGRhdGEub2Zmc2V0WyAxIF0gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBkYXRhLnJlcGVhdFsgMCBdLCBkYXRhLnJlcGVhdFsgMSBdICk7XHJcblx0XHRcdFx0aWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIgKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gZGF0YS5hbmlzb3Ryb3B5O1xyXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggZGF0YS53cmFwICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMCBdICk7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAxIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdDtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJpZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgbmFtZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyaWVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbCggbmFtZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBuYW1lID09PSB1bmRlZmluZWQgKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG1hdGVyaWFsc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdTY2VuZSc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdPcnRob2dyYXBoaWNDYW1lcmEnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ0FtYmllbnRMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggZGF0YS5jb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEuZXhwb25lbnQsIGRhdGEuZGVjYXkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdNZXNoJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdMT0QnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnTGluZSc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdQb2ludENsb3VkJzpcclxuXHRcdFx0XHRjYXNlICdQb2ludHMnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnU3ByaXRlJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ0dyb3VwJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuR3JvdXAoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xyXG5cdFx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XHJcblx0XHRcdFx0bWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcclxuXHRcdFx0aWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xyXG5cdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggZGF0YS5jaGlsZHJlblsgY2hpbGQgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XHJcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvVGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcclxuXHJcblx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcclxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ3ViZVRleHR1cmVMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJlVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmxzLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtdICk7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0dmFyIGxvYWRlZCA9IDA7XHJcblxyXG5cdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XHJcblxyXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsc1sgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlc1sgaSBdID0gaW1hZ2U7XHJcblxyXG5cdFx0XHRcdGxvYWRlZCArKztcclxuXHJcblx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSwgdW5kZWZpbmVkLCBvbkVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyArKyBpICkge1xyXG5cclxuXHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvQmluYXJ5VGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgTmlrb3MgTS4gLyBodHRwczovL2dpdGh1Yi5jb20vZm9vMTIzL1xyXG4gKlxyXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGxvYWQgZ2VuZXJpYyBiaW5hcnkgdGV4dHVyZXMgZm9ybWF0cyAocmdiZSwgaGRyLCAuLi4pXHJcbiAqL1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmVMb2FkZXIgPSBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcclxuXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCk7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblxyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4RGF0YSA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCAhIHRleERhdGEgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcclxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLmRhdGEgPSB0ZXhEYXRhLmRhdGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0XHRcdHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHJcblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5hbmlzb3Ryb3B5ID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcclxuXHJcblx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NvbXByZXNzZWRUZXh0dXJlTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICpcclxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBibG9jayBiYXNlZCB0ZXh0dXJlcyBsb2FkZXIgKGRkcywgcHZyLCAuLi4pXHJcbiAqL1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxuXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xyXG5cdHRoaXMuX3BhcnNlciA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGltYWdlcyA9IFtdO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlKCk7XHJcblx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVkID0gMDtcclxuXHJcblx0XHRcdHZhciBsb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggaSApIHtcclxuXHJcblx0XHRcdFx0bG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0XHRpbWFnZXNbIGkgXSA9IHtcclxuXHRcdFx0XHRcdFx0d2lkdGg6IHRleERhdGFzLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcclxuXHRcdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXHJcblx0XHRcdFx0XHRcdG1pcG1hcHM6IHRleERhdGFzLm1pcG1hcHNcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0bG9hZGVkICs9IDE7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcclxuIFx0XHRcdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcclxuXHRcdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxyXG5cclxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcclxuXHRcdFx0XHRcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcclxuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuTWF0ZXJpYWxJZENvdW50ICsrIH0gKTtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy50eXBlID0gJ01hdGVyaWFsJztcclxuXHJcblx0dGhpcy5zaWRlID0gVEhSRUUuRnJvbnRTaWRlO1xyXG5cclxuXHR0aGlzLm9wYWNpdHkgPSAxO1xyXG5cdHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5ibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHR0aGlzLmJsZW5kU3JjID0gVEhSRUUuU3JjQWxwaGFGYWN0b3I7XHJcblx0dGhpcy5ibGVuZERzdCA9IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XHJcblx0dGhpcy5ibGVuZEVxdWF0aW9uID0gVEhSRUUuQWRkRXF1YXRpb247XHJcblx0dGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcclxuXHR0aGlzLmJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcclxuXHJcblx0dGhpcy5kZXB0aEZ1bmMgPSBUSFJFRS5MZXNzRXF1YWxEZXB0aDtcclxuXHR0aGlzLmRlcHRoVGVzdCA9IHRydWU7XHJcblx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5jb2xvcldyaXRlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxyXG5cclxuXHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcclxuXHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xyXG5cdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcclxuXHJcblx0dGhpcy5hbHBoYVRlc3QgPSAwO1xyXG5cclxuXHR0aGlzLm92ZXJkcmF3ID0gMDsgLy8gT3ZlcmRyYXduIHBpeGVscyAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgZm9yIGZpeGluZyBhbnRpYWxpYXNpbmcgZ2FwcyBpbiBDYW52YXNSZW5kZXJlclxyXG5cclxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXHJcblxyXG5cdGdldCBuZWVkc1VwZGF0ZSAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRWYWx1ZXM6IGZ1bmN0aW9uICggdmFsdWVzICkge1xyXG5cclxuXHRcdGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuTWF0ZXJpYWw6ICdcIiArIGtleSArIFwiJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlwiICk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuXCIgKyB0aGlzLnR5cGUgKyBcIjogJ1wiICsga2V5ICsgXCInIGlzIG5vdCBhIHByb3BlcnR5IG9mIHRoaXMgbWF0ZXJpYWwuXCIgKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICYmIG5ld1ZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGVuc3VyZSBvdmVyZHJhdyBpcyBiYWNrd2FyZHMtY29tcGF0aWJsZSB3aXRoIGxlZ2FjeSBib29sZWFuIHR5cGVcclxuXHRcdFx0XHR0aGlzWyBrZXkgXSA9IE51bWJlciggbmV3VmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXHJcblx0XHRcdFx0dHlwZTogJ01hdGVyaWFsJyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc3RhbmRhcmQgTWF0ZXJpYWwgc2VyaWFsaXphdGlvblxyXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuXHRcdGlmICggdGhpcy5jb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XHJcblx0XHRpZiAoIHRoaXMuZW1pc3NpdmUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xyXG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcclxuXHRcdGlmICggdGhpcy5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRpZiAoIHRoaXMuYWxwaGFNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdGlmICggdGhpcy5saWdodE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLmJ1bXBNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRcdGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XHJcblxyXG5cdFx0fVxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRkYXRhLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRcdGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlOyAvLyBSZW1vdmVkIGZvciBub3csIGNhdXNlcyBpc3N1ZSBpbiBlZGl0b3IgdWkuanNcclxuXHJcblx0XHR9XHJcblx0XHRpZiAoIHRoaXMuZGlzcGxhY2VtZW50TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcblx0XHR9XHJcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdGlmICggdGhpcy5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5lbnZNYXAgPSB0aGlzLmVudk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5OyAvLyBTY2FsZSBiZWhpbmQgZW52TWFwXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5zaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XHJcblx0XHRpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xyXG5cclxuXHRcdGlmICggdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBkYXRhLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xyXG5cdFx0aWYgKCB0aGlzLnNoYWRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNoYWRpbmcgIT09IFRIUkVFLlNtb290aFNoYWRpbmcgKSBkYXRhLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XHJcblx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJsZW5kaW5nICE9PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xyXG5cdFx0aWYgKCB0aGlzLnNpZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNpZGUgIT09IFRIUkVFLkZyb250U2lkZSApIGRhdGEuc2lkZSA9IHRoaXMuc2lkZTtcclxuXHJcblx0XHRpZiAoIHRoaXMub3BhY2l0eSA8IDEgKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IHRydWUgKSBkYXRhLnRyYW5zcGFyZW50ID0gdGhpcy50cmFuc3BhcmVudDtcclxuXHRcdGlmICggdGhpcy5hbHBoYVRlc3QgPiAwICkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcclxuXHRcdGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xyXG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEgKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0dGhpcy5zaWRlID0gc291cmNlLnNpZGU7XHJcblxyXG5cdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XHJcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XHJcblxyXG5cdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcclxuXHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XHJcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcclxuXHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xyXG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XHJcblx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XHJcblxyXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xyXG5cdFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xyXG5cdFx0dGhpcy5kZXB0aFdyaXRlID0gc291cmNlLmRlcHRoV3JpdGU7XHJcblxyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xyXG5cclxuXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xyXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XHJcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcblxyXG5cdFx0dGhpcy5hbHBoYVRlc3QgPSBzb3VyY2UuYWxwaGFUZXN0O1xyXG5cclxuXHRcdHRoaXMub3ZlcmRyYXcgPSBzb3VyY2Uub3ZlcmRyYXc7XHJcblxyXG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gRGVwcmVjYXRlZFxyXG5cclxuXHRnZXQgd3JhcEFyb3VuZCAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgd3JhcEFyb3VuZCAoIGJvb2xlYW4gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgd3JhcFJHQiAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Db2xvcigpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NYXRlcmlhbElkQ291bnQgPSAwO1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcclxuICogIGxpbmVjYXA6IFwicm91bmRcIixcclxuICogIGxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG5cdHRoaXMubGluZXdpZHRoID0gMTtcclxuXHR0aGlzLmxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsO1xyXG5cclxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcclxuXHR0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcclxuXHR0aGlzLmxpbmVqb2luID0gc291cmNlLmxpbmVqb2luO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL0xpbmVEYXNoZWRNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzY2FsZTogPGZsb2F0PixcclxuICogIGRhc2hTaXplOiA8ZmxvYXQ+LFxyXG4gKiAgZ2FwU2l6ZTogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogPGJvb2w+XHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMuc2NhbGUgPSAxO1xyXG5cdHRoaXMuZGFzaFNpemUgPSAzO1xyXG5cdHRoaXMuZ2FwU2l6ZSA9IDE7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblx0XHJcblx0dGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xyXG5cclxuXHR0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xyXG5cdHRoaXMuZGFzaFNpemUgPSBzb3VyY2UuZGFzaFNpemU7XHJcblx0dGhpcy5nYXBTaXplID0gc291cmNlLmdhcFNpemU7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXHJcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcclxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcclxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcclxuICpcclxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXHJcbiAqXHJcbiAqICBza2lubmluZzogPGJvb2w+LFxyXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcclxuXHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmFvTWFwID0gbnVsbDtcclxuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gbnVsbDtcclxuXHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblx0XHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcblx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xyXG5cdFxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTGFtYmVydE1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIGVtaXNzaXZlOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXHJcbiAqXHJcbiAqICBza2lubmluZzogPGJvb2w+LFxyXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcclxuICpcclxuICpcdGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcblx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxyXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxyXG4gKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGJ1bXBTY2FsZTogPGZsb2F0PixcclxuICpcclxuICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXHJcbiAqXHJcbiAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcclxuICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0dGhpcy5zcGVjdWxhciA9IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKTtcclxuXHR0aGlzLnNoaW5pbmVzcyA9IDMwO1xyXG5cclxuXHR0aGlzLm1ldGFsID0gZmFsc2U7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYnVtcE1hcCA9IG51bGw7XHJcblx0dGhpcy5idW1wU2NhbGUgPSAxO1xyXG5cclxuXHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcblx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcclxuXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xyXG5cclxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gbnVsbDtcclxuXHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsO1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcclxuXHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xyXG5cdHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcclxuXHJcblx0dGhpcy5tZXRhbCA9IHNvdXJjZS5tZXRhbDtcclxuXHJcblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xyXG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG5cdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XHJcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcclxuXHJcblx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcclxuXHJcblx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xyXG5cclxuXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcblx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaERlcHRoTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoRGVwdGhNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsO1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTm9ybWFsTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NdWx0aU1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NdWx0aU1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNdWx0aU1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5tYXRlcmlhbHMgPSBtYXRlcmlhbHMgaW5zdGFuY2VvZiBBcnJheSA/IG1hdGVyaWFscyA6IFtdO1xyXG5cclxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk11bHRpTWF0ZXJpYWwucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTXVsdGlNYXRlcmlhbCxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG91dHB1dCA9IHtcclxuXHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjIsXHJcblx0XHRcdFx0dHlwZTogJ21hdGVyaWFsJyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbEV4cG9ydGVyJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXHJcblx0XHRcdHR5cGU6IHRoaXMudHlwZSxcclxuXHRcdFx0bWF0ZXJpYWxzOiBbXVxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0b3V0cHV0Lm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLnRvSlNPTigpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG91dHB1dC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBUSFJFRS5NdWx0aU1hdGVyaWFsO1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1BvaW50c01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzaXplOiA8ZmxvYXQ+LFxyXG4gKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50c01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5zaXplID0gMTtcclxuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHR0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcclxuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG5cdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG5cdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgZGVmaW5lczogeyBcImxhYmVsXCIgOiBcInZhbHVlXCIgfSxcclxuICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHR5cGU6IFwiaVwiIHZhbHVlMjogMiB9IH0sXHJcbiAqXHJcbiAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXHJcbiAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBsaWdodHM6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5kZWZpbmVzID0ge307XHJcblx0dGhpcy51bmlmb3JtcyA9IHt9O1xyXG5cclxuXHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xyXG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLmZvZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGZvZ1xyXG5cclxuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzOyAvLyBzZXQgdG8gdXNlIFwiY29sb3JcIiBhdHRyaWJ1dGUgc3RyZWFtXHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBza2lubmluZyBhdHRyaWJ1dGUgc3RyZWFtc1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0dGhpcy5kZXJpdmF0aXZlcyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIGRlcml2YXRpdmVzXHJcblxyXG5cdC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxyXG5cdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cclxuXHR0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSB7XHJcblx0XHQnY29sb3InOiBbIDEsIDEsIDEgXSxcclxuXHRcdCd1dic6IFsgMCwgMCBdLFxyXG5cdFx0J3V2Mic6IFsgMCwgMCBdXHJcblx0fTtcclxuXHJcblx0dGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdW5kZWZpbmVkO1xyXG5cclxuXHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiBhdHRyaWJ1dGVzIHNob3VsZCBub3cgYmUgZGVmaW5lZCBpbiBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFkZXJNYXRlcmlhbDtcclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xyXG5cdHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcclxuXHJcblx0dGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNvdXJjZS51bmlmb3JtcyApO1xyXG5cclxuXHR0aGlzLmF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcclxuXHR0aGlzLmRlZmluZXMgPSBzb3VyY2UuZGVmaW5lcztcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcblx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdHRoaXMuZGVyaXZhdGl2ZXMgPSBzb3VyY2UuZGVyaXZhdGl2ZXM7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdHZhciBkYXRhID0gVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG5cdGRhdGEudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xyXG5cdGRhdGEuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHRkYXRhLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xyXG5cdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvUmF3U2hhZGVyTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5TaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsO1xyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU3ByaXRlTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKlx0dXZPZmZzZXQ6IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAqXHR1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uID0gMDtcclxuXHJcblx0dGhpcy5mb2cgPSBmYWxzZTtcclxuXHJcblx0Ly8gc2V0IHBhcmFtZXRlcnNcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3ByaXRlTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XHJcblxyXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICovXHJcblxyXG5USFJFRS5UZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLlRleHR1cmVJZENvdW50ICsrIH0gKTtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy5zb3VyY2VGaWxlID0gJyc7XHJcblxyXG5cdHRoaXMuaW1hZ2UgPSBpbWFnZSAhPT0gdW5kZWZpbmVkID8gaW1hZ2UgOiBUSFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0U7XHJcblx0dGhpcy5taXBtYXBzID0gW107XHJcblxyXG5cdHRoaXMubWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORztcclxuXHJcblx0dGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0dGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG5cdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcclxuXHJcblx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XHJcblxyXG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xyXG5cdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xyXG5cclxuXHR0aGlzLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XHJcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XHJcblx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XHJcblx0dGhpcy5mbGlwWSA9IHRydWU7XHJcblx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0OyAvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcclxuXHJcblx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHR0aGlzLm9uVXBkYXRlID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XHJcblRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVEhSRUUuVVZNYXBwaW5nO1xyXG5cclxuVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlLFxyXG5cclxuXHRzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5pbWFnZSA9IHNvdXJjZS5pbWFnZTtcclxuXHRcdHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XHJcblxyXG5cdFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XHJcblxyXG5cdFx0dGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcclxuXHRcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XHJcblxyXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBzb3VyY2UubWFnRmlsdGVyO1xyXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xyXG5cclxuXHRcdHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xyXG5cclxuXHRcdHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcclxuXHRcdHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xyXG5cclxuXHRcdHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcclxuXHRcdHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcclxuXHJcblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbHlBbHBoYTtcclxuXHRcdHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XHJcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuXHRcdGlmICggbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YVVSTCggaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2FudmFzO1xyXG5cclxuXHRcdFx0aWYgKCBpbWFnZS50b0RhdGFVUkwgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y2FudmFzID0gaW1hZ2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xyXG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICkuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4ICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL2pwZWcnLCAwLjYgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvcG5nJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3V0cHV0ID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNCxcclxuXHRcdFx0XHR0eXBlOiAnVGV4dHVyZScsXHJcblx0XHRcdFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXHJcblx0XHRcdG5hbWU6IHRoaXMubmFtZSxcclxuXHJcblx0XHRcdG1hcHBpbmc6IHRoaXMubWFwcGluZyxcclxuXHJcblx0XHRcdHJlcGVhdDogWyB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55IF0sXHJcblx0XHRcdG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXHJcblx0XHRcdHdyYXA6IFsgdGhpcy53cmFwUywgdGhpcy53cmFwVCBdLFxyXG5cclxuXHRcdFx0bWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcclxuXHRcdFx0bWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcclxuXHRcdFx0YW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggdGhpcy5pbWFnZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gVE9ETzogTW92ZSB0byBUSFJFRS5JbWFnZVxyXG5cclxuXHRcdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZTtcclxuXHJcblx0XHRcdGlmICggaW1hZ2UudXVpZCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpbWFnZS51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTsgLy8gVUdIXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9IHtcclxuXHRcdFx0XHRcdHV1aWQ6IGltYWdlLnV1aWQsXHJcblx0XHRcdFx0XHR1cmw6IGdldERhdGFVUkwoIGltYWdlIClcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3V0cHV0LmltYWdlID0gaW1hZ2UudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKCB1diApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubWFwcGluZyAhPT0gVEhSRUUuVVZNYXBwaW5nICkgIHJldHVybjtcclxuXHJcblx0XHR1di5tdWx0aXBseSggdGhpcy5yZXBlYXQgKTtcclxuXHRcdHV2LmFkZCggdGhpcy5vZmZzZXQgKTtcclxuXHJcblx0XHRpZiAoIHV2LnggPCAwIHx8IHV2LnggPiAxICkge1xyXG5cclxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwUyApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5SZXBlYXRXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHV2LnggPSBNYXRoLmNlaWwoIHV2LnggKSAtIHV2Lng7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHV2LnkgPCAwIHx8IHV2LnkgPiAxICkge1xyXG5cclxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwVCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5SZXBlYXRXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0dXYueSA9IHV2LnkgPCAwID8gMCA6IDE7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnkgKSAlIDIgKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHV2LnkgPSBNYXRoLmNlaWwoIHV2LnkgKSAtIHV2Lnk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuZmxpcFkgKSB7XHJcblxyXG5cdFx0XHR1di55ID0gMSAtIHV2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlRleHR1cmVJZENvdW50ID0gMDtcclxuXHJcbi8vIEZpbGU6c3JjL3RleHR1cmVzL0NhbnZhc1RleHR1cmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNhbnZhc1RleHR1cmUgPSBmdW5jdGlvbiAoIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNhbnZhc1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ2FudmFzVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW52YXNUZXh0dXJlO1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ3ViZVRleHR1cmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcclxuXHJcblx0bWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5pbWFnZXMgPSBpbWFnZXM7XHJcblx0dGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVUZXh0dXJlO1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHRcclxuXHR0aGlzLmltYWdlcyA9IHNvdXJjZS5pbWFnZXM7XHJcblx0XHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cdHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XHJcblxyXG5cdC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXHJcblx0Ly8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcclxuXHJcblx0dGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cclxuXHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXHJcblx0Ly8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xyXG5cclxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvRGF0YVRleHR1cmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRhdGFUZXh0dXJlID0gZnVuY3Rpb24gKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuXHJcblx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XHJcblx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XHJcblx0XHJcblx0dGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzICA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRhdGFUZXh0dXJlO1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVmlkZW9UZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5WaWRlb1RleHR1cmUgPSBmdW5jdGlvbiAoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcclxuXHJcblx0XHRpZiAoIHZpZGVvLnJlYWR5U3RhdGUgPT09IHZpZGVvLkhBVkVfRU5PVUdIX0RBVEEgKSB7XHJcblxyXG5cdFx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5USFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmlkZW9UZXh0dXJlO1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Hcm91cC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR3JvdXAgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0dyb3VwJztcclxuXHJcbn07XHJcblxyXG5USFJFRS5Hcm91cC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuR3JvdXA7XHJcbi8vIEZpbGU6c3JjL29iamVjdHMvUG9pbnRzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Qb2ludHMgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUG9pbnRzJztcclxuXHJcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzO1xyXG5cclxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHR2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdHZhciBvYmplY3QgPSB0aGlzO1xyXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcclxuXHJcblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggcmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XHJcblx0XHR2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XHJcblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHRlc3RQb2ludCggcG9pbnQsIGluZGV4ICkge1xyXG5cclxuXHRcdFx0dmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IHJheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcclxuXHJcblx0XHRcdGlmICggcmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGludGVyc2VjdFBvaW50ID0gcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50ICk7XHJcblx0XHRcdFx0aW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcclxuXHJcblx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG5cdFx0XHRcdFx0ZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KCByYXlQb2ludERpc3RhbmNlU3EgKSxcclxuXHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxyXG5cdFx0XHRcdFx0aW5kZXg6IGluZGV4LFxyXG5cdFx0XHRcdFx0ZmFjZTogbnVsbCxcclxuXHRcdFx0XHRcdG9iamVjdDogb2JqZWN0XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9IGluZGljZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcclxuXHJcblx0XHRcdFx0XHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBhICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSAqIDMgKTtcclxuXHJcblx0XHRcdFx0XHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0ZXN0UG9pbnQoIHZlcnRpY2VzWyBpIF0sIGkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLlBvaW50cy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuUG9pbnRDbG91ZCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcclxuXHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFydGljbGVTeXN0ZW0gPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xyXG5cdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxpbmUgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgbW9kZSApIHtcclxuXHJcblx0aWYgKCBtb2RlID09PSAxICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmU6IHBhcmFtZXRlciBUSFJFRS5MaW5lUGllY2VzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIENyZWF0ZWQgVEhSRUUuTGluZVNlZ21lbnRzIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5MaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0xpbmUnO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmU7XHJcblxyXG5USFJFRS5MaW5lLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHR2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xyXG5cdHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XHJcblxyXG5cdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xyXG5cdFx0dmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxyXG5cclxuXHRcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xyXG5cdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG5cdFx0dmFyIHZTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgaW50ZXJTZWdtZW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBpbnRlclJheSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgc3RlcCA9IHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgPyAyIDogMTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcclxuXHRcdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0dmFyIGIgPSBpbmRpY2VzWyBpICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcclxuXHRcdFx0XHRcdHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxyXG5cclxuXHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG5cdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cclxuXHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXHJcblx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcclxuXHRcdFx0XHRcdFx0aW5kZXg6IGksXHJcblx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcclxuXHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXHJcblxyXG5cdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xyXG5cclxuXHRcdFx0XHRcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKTtcclxuXHRcdFx0XHRcdHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICsgMyApO1xyXG5cclxuXHRcdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cclxuXHJcblx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XHJcblx0XHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxyXG5cdFx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXHJcblx0XHRcdFx0XHRcdGluZGV4OiBpLFxyXG5cdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXHJcblx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xyXG5cclxuXHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdFx0dmFyIG5iVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSArPSBzdGVwICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XHJcblxyXG5cdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxyXG5cclxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG5cdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXHJcblx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXHJcblx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXHJcblx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn0oKSApO1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBERVBSRUNBVEVEXHJcblxyXG5USFJFRS5MaW5lU3RyaXAgPSAwO1xyXG5USFJFRS5MaW5lUGllY2VzID0gMTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvTGluZVNlZ21lbnRzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MaW5lU2VnbWVudHMgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0VEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0xpbmVTZWdtZW50cyc7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XHJcblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lU2VnbWVudHM7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL01lc2guanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoJztcclxuXHJcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblxyXG5cdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoO1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0QmFzZSA9IC0gMTtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcclxuXHJcblx0fVxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcclxuXHJcblx0cmV0dXJuIDA7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0dmFyIHZBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciB0ZW1wQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHRlbXBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdGVtcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR2YXIgdXZBID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgdXZCID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgdXZDID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0dmFyIGJhcnljb29yZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRmdW5jdGlvbiB1dkludGVyc2VjdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMgKSB7XHJcblxyXG5cdFx0VEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgcDEsIHAyLCBwMywgYmFyeWNvb3JkICk7XHJcblxyXG5cdFx0dXYxLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueCApO1xyXG5cdFx0dXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xyXG5cdFx0dXYzLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueiApO1xyXG5cclxuXHRcdHV2MS5hZGQoIHV2MiApLmFkZCggdXYzICk7XHJcblxyXG5cdFx0cmV0dXJuIHV2MS5jbG9uZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApe1xyXG5cclxuXHRcdHZhciBpbnRlcnNlY3Q7XHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcclxuXHJcblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlLCBwb2ludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcclxuXHRcdGludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XHJcblxyXG5cdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0cG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcclxuXHRcdFx0b2JqZWN0OiBvYmplY3RcclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0dkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XHJcblx0XHR2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcclxuXHRcdHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xyXG5cclxuXHRcdHZhciBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIHJheSwgdkEsIHZCLCB2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcclxuXHJcblx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcclxuXHJcblx0XHRcdGlmICggdXZzICkge1xyXG5cclxuXHRcdFx0XHR1dkEuZnJvbUFycmF5KCB1dnMsIGEgKiAyICk7XHJcblx0XHRcdFx0dXZCLmZyb21BcnJheSggdXZzLCBiICogMiApO1xyXG5cdFx0XHRcdHV2Qy5mcm9tQXJyYXkoIHV2cywgYyAqIDIgKTtcclxuXHJcblx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCAgdkEsIHZCLCB2QywgIHV2QSwgdXZCLCB1dkMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGludGVyc2VjdGlvbi5mYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHZBLCB2QiwgdkMgKSApO1xyXG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gYTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblx0XHR2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuXHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcclxuXHJcblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHJheS5pc0ludGVyc2VjdGlvbkJveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB1dnMsIGludGVyc2VjdGlvbjtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSwgYiwgYztcclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApe1xyXG5cclxuXHRcdFx0XHR1dnMgPSBhdHRyaWJ1dGVzLnV2LmFycmF5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YSA9IGluZGljZXNbIGkgXTtcclxuXHRcdFx0XHRcdGIgPSBpbmRpY2VzWyBpICsgMSBdO1xyXG5cdFx0XHRcdFx0YyA9IGluZGljZXNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGljZXMgYnVmZmVyIHNlbWFudGljc1xyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICs9IDkgKSB7XHJcblxyXG5cdFx0XHRcdFx0YSA9IGkgLyAzO1xyXG5cdFx0XHRcdFx0YiA9IGEgKyAxO1xyXG5cdFx0XHRcdFx0YyA9IGEgKyAyO1xyXG5cclxuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbnMsIHV2cywgYSwgYiwgYyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmluZGV4ID0gYTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIHBvc2l0aW9ucyBidWZmZXIgc2VtYW50aWNzXHJcblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdHZhciBmdkEsIGZ2QiwgZnZDO1xyXG5cdFx0XHR2YXIgaXNGYWNlTWF0ZXJpYWwgPSBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWw7XHJcblx0XHRcdHZhciBtYXRlcmlhbHMgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG1hdGVyaWFsLm1hdGVyaWFscyA6IG51bGw7XHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cdFx0XHRpZiAoIGZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHV2cyA9IGZhY2VWZXJ0ZXhVdnM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGYgXTtcclxuXHRcdFx0XHR2YXIgZmFjZU1hdGVyaWFsID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbHNbIGZhY2UubWF0ZXJpYWxJbmRleCBdIDogbWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0ZnZBID0gdmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdGZ2QiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRmdkMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG5cdFx0XHRcdFx0dmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG5cclxuXHRcdFx0XHRcdHZBLnNldCggMCwgMCwgMCApO1xyXG5cdFx0XHRcdFx0dkIuc2V0KCAwLCAwLCAwICk7XHJcblx0XHRcdFx0XHR2Qy5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0XHR2QS5hZGRTY2FsZWRWZWN0b3IoIHRlbXBBLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYSBdLCBmdkEgKSwgaW5mbHVlbmNlICk7XHJcblx0XHRcdFx0XHRcdHZCLmFkZFNjYWxlZFZlY3RvciggdGVtcEIuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5iIF0sIGZ2QiApLCBpbmZsdWVuY2UgKTtcclxuXHRcdFx0XHRcdFx0dkMuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQy5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmMgXSwgZnZDICksIGluZmx1ZW5jZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR2QS5hZGQoIGZ2QSApO1xyXG5cdFx0XHRcdFx0dkIuYWRkKCBmdkIgKTtcclxuXHRcdFx0XHRcdHZDLmFkZCggZnZDICk7XHJcblxyXG5cdFx0XHRcdFx0ZnZBID0gdkE7XHJcblx0XHRcdFx0XHRmdkIgPSB2QjtcclxuXHRcdFx0XHRcdGZ2QyA9IHZDO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgZnZBLCBmdkIsIGZ2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1dnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdXZzX2YgPSB1dnNbIGYgXTtcclxuXHRcdFx0XHRcdFx0dXZBLmNvcHkoIHV2c19mWyAwIF0gKTtcclxuXHRcdFx0XHRcdFx0dXZCLmNvcHkoIHV2c19mWyAxIF0gKTtcclxuXHRcdFx0XHRcdFx0dXZDLmNvcHkoIHV2c19mWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgZnZBLCBmdkIsIGZ2QywgdXZBLCB1dkIsIHV2QyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gZjtcclxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Cb25lLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uICggc2tpbiApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQm9uZSc7XHJcblxyXG5cdHRoaXMuc2tpbiA9IHNraW47XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm9uZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb25lO1xyXG5cclxuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cdFxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cdFxyXG5cdHRoaXMuc2tpbiA9IHNvdXJjZS5za2luO1xyXG5cdFxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvU2tlbGV0b24uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pY2hhZWwgZ3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxyXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuICovXHJcblxyXG5USFJFRS5Ta2VsZXRvbiA9IGZ1bmN0aW9uICggYm9uZXMsIGJvbmVJbnZlcnNlcywgdXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0dGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XHJcblxyXG5cdHRoaXMuaWRlbnRpdHlNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHQvLyBjb3B5IHRoZSBib25lIGFycmF5XHJcblxyXG5cdGJvbmVzID0gYm9uZXMgfHwgW107XHJcblxyXG5cdHRoaXMuYm9uZXMgPSBib25lcy5zbGljZSggMCApO1xyXG5cclxuXHQvLyBjcmVhdGUgYSBib25lIHRleHR1cmUgb3IgYW4gYXJyYXkgb2YgZmxvYXRzXHJcblxyXG5cdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcclxuXHRcdC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcclxuXHRcdC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXHJcblx0XHQvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcclxuXHRcdC8vICAgICAgIDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4ICAyNTYgYm9uZXMgKiA0IHBpeGVscyA9ICgzMiAqIDMyKVxyXG5cdFx0Ly8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXHJcblxyXG5cdFx0XHJcblx0XHR2YXIgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5ib25lcy5sZW5ndGggKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcclxuXHRcdHNpemUgPSBUSFJFRS5NYXRoLm5leHRQb3dlck9mVHdvKCBNYXRoLmNlaWwoIHNpemUgKSApO1xyXG5cdFx0c2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XHJcblxyXG5cdFx0dGhpcy5ib25lVGV4dHVyZVdpZHRoID0gc2l6ZTtcclxuXHRcdHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgPSBzaXplO1xyXG5cclxuXHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5ib25lVGV4dHVyZVdpZHRoICogdGhpcy5ib25lVGV4dHVyZUhlaWdodCAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcclxuXHRcdHRoaXMuYm9uZVRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIHRoaXMuYm9uZU1hdHJpY2VzLCB0aGlzLmJvbmVUZXh0dXJlV2lkdGgsIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQsIFRIUkVFLlJHQkFGb3JtYXQsIFRIUkVFLkZsb2F0VHlwZSApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB0aGlzLmJvbmVzLmxlbmd0aCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHVzZSB0aGUgc3VwcGxpZWQgYm9uZSBpbnZlcnNlcyBvciBjYWxjdWxhdGUgdGhlIGludmVyc2VzXHJcblxyXG5cdGlmICggYm9uZUludmVyc2VzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0dGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib25lcy5sZW5ndGggPT09IGJvbmVJbnZlcnNlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcy5zbGljZSggMCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbiBib25JbnZlcnNlcyBpcyB0aGUgd3JvbmcgbGVuZ3RoLicgKTtcclxuXHJcblx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IFRIUkVFLk1hdHJpeDQoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jYWxjdWxhdGVJbnZlcnNlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG5cdFx0dmFyIGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5ib25lc1sgYiBdICkge1xyXG5cclxuXHRcdFx0aW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBib25lO1xyXG5cclxuXHQvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcclxuXHJcblx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG5cdFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcclxuXHJcblx0XHRpZiAoIGJvbmUgKSB7XHJcblxyXG5cdFx0XHRib25lLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcclxuXHJcblx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG5cdFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcclxuXHJcblx0XHRpZiAoIGJvbmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJvbmUucGFyZW50ICkge1xyXG5cclxuXHRcdFx0XHRib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdGJvbmUubWF0cml4Lm11bHRpcGx5KCBib25lLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG9mZnNldE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG5cdFx0Ly8gZmxhdHRlbiBib25lIG1hdHJpY2VzIHRvIGFycmF5XHJcblxyXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxyXG5cclxuXHRcdFx0dmFyIG1hdHJpeCA9IHRoaXMuYm9uZXNbIGIgXSA/IHRoaXMuYm9uZXNbIGIgXS5tYXRyaXhXb3JsZCA6IHRoaXMuaWRlbnRpdHlNYXRyaXg7XHJcblxyXG5cdFx0XHRvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XHJcblx0XHRcdG9mZnNldE1hdHJpeC5mbGF0dGVuVG9BcnJheU9mZnNldCggdGhpcy5ib25lTWF0cmljZXMsIGIgKiAxNiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn0gKSgpO1xyXG5cclxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlNrZWxldG9uKCB0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcywgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLlNraW5uZWRNZXNoID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XHJcblxyXG5cdHRoaXMuYmluZE1vZGUgPSBcImF0dGFjaGVkXCI7XHJcblx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0Ly8gaW5pdCBib25lc1xyXG5cclxuXHQvLyBUT0RPOiByZW1vdmUgYm9uZSBjcmVhdGlvbiBhcyB0aGVyZSBpcyBubyByZWFzb24gKG90aGVyIHRoYW5cclxuXHQvLyBjb252ZW5pZW5jZSkgZm9yIFRIUkVFLlNraW5uZWRNZXNoIHRvIGRvIHRoaXMuXHJcblxyXG5cdHZhciBib25lcyA9IFtdO1xyXG5cclxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHZhciBib25lLCBnYm9uZTtcclxuXHJcblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKysgYiApIHtcclxuXHJcblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xyXG5cclxuXHRcdFx0Ym9uZSA9IG5ldyBUSFJFRS5Cb25lKCB0aGlzICk7XHJcblx0XHRcdGJvbmVzLnB1c2goIGJvbmUgKTtcclxuXHJcblx0XHRcdGJvbmUubmFtZSA9IGdib25lLm5hbWU7XHJcblx0XHRcdGJvbmUucG9zaXRpb24uZnJvbUFycmF5KCBnYm9uZS5wb3MgKTtcclxuXHRcdFx0Ym9uZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggZ2JvbmUucm90cSApO1xyXG5cdFx0XHRpZiAoIGdib25lLnNjbCAhPT0gdW5kZWZpbmVkICkgYm9uZS5zY2FsZS5mcm9tQXJyYXkoIGdib25lLnNjbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKysgYiApIHtcclxuXHJcblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xyXG5cclxuXHRcdFx0aWYgKCBnYm9uZS5wYXJlbnQgIT09IC0gMSAmJiBnYm9uZS5wYXJlbnQgIT09IG51bGwpIHtcclxuXHJcblx0XHRcdFx0Ym9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZXNbIGIgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGQoIGJvbmVzWyBiIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xyXG5cclxuXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblx0dGhpcy5iaW5kKCBuZXcgVEhSRUUuU2tlbGV0b24oIGJvbmVzLCB1bmRlZmluZWQsIHVzZVZlcnRleFRleHR1cmUgKSwgdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ta2lubmVkTWVzaDtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xyXG5cclxuXHR0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XHJcblxyXG5cdGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHRcdFxyXG5cdFx0dGhpcy5za2VsZXRvbi5jYWxjdWxhdGVJbnZlcnNlcygpO1xyXG5cclxuXHRcdGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XHJcblx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCBiaW5kTWF0cml4ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuc2tlbGV0b24ucG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5ub3JtYWxpemVTa2luV2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0aWYgKCB0aGlzLmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHR2YXIgc2NhbGUgPSAxLjAgLyBzdy5sZW5ndGhNYW5oYXR0YW4oKTtcclxuXHJcblx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xyXG5cclxuXHRcdFx0XHRzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHN3LnNldCggMSApOyAvLyB0aGlzIHdpbGwgYmUgbm9ybWFsaXplZCBieSB0aGUgc2hhZGVyIGFueXdheVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHQvLyBza2lubmluZyB3ZWlnaHRzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCBmb3IgVEhSRUUuQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uKCBmb3JjZSApIHtcclxuXHJcblx0VEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgdHJ1ZSApO1xyXG5cclxuXHRpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiYXR0YWNoZWRcIiApIHtcclxuXHJcblx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSBlbHNlIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gXCJkZXRhY2hlZFwiICkge1xyXG5cclxuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tpbm5lZE1lc2ggdW5yZWNvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCwgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvTE9ELmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MT0QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0xPRCc7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XHJcblx0XHRsZXZlbHM6IHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0dmFsdWU6IFtdXHJcblx0XHR9LFxyXG5cdFx0b2JqZWN0czoge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTE9EOiAub2JqZWN0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5sZXZlbHMuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmxldmVscztcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9ICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTE9ELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxPRDtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuYWRkTGV2ZWwgPSBmdW5jdGlvbiAoIG9iamVjdCwgZGlzdGFuY2UgKSB7XHJcblxyXG5cdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcclxuXHJcblx0ZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcclxuXHJcblx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG5cclxuXHRmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xyXG5cclxuXHRcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGwgXS5kaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRsZXZlbHMuc3BsaWNlKCBsLCAwLCB7IGRpc3RhbmNlOiBkaXN0YW5jZSwgb2JqZWN0OiBvYmplY3QgfSApO1xyXG5cclxuXHR0aGlzLmFkZCggb2JqZWN0ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS5nZXRPYmplY3RGb3JEaXN0YW5jZSA9IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XHJcblxyXG5cdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0aWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIG1hdHJpeFBvc2l0aW9uICk7XHJcblxyXG5cdFx0dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKSApO1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xyXG5cclxuXHRcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcblx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHRcdFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSB2MS5kaXN0YW5jZVRvKCB2MiApO1xyXG5cclxuXHRcdFx0bGV2ZWxzWyAwIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPj0gbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGV2ZWxzWyBpIC0gMSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgZmFsc2UgKTtcclxuXHJcblx0dmFyIGxldmVscyA9IHNvdXJjZS5sZXZlbHM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xyXG5cclxuXHRcdHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuXHR2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xyXG5cclxuXHRkYXRhLm9iamVjdC5sZXZlbHMgPSBbXTtcclxuXHJcblx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcclxuXHJcblx0XHRkYXRhLm9iamVjdC5sZXZlbHMucHVzaCgge1xyXG5cdFx0XHRvYmplY3Q6IGxldmVsLm9iamVjdC51dWlkLFxyXG5cdFx0XHRkaXN0YW5jZTogbGV2ZWwuZGlzdGFuY2VcclxuXHRcdH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL1Nwcml0ZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDIsICAwLCAyLCAzIF0gKTtcclxuXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIC0gMC41LCAtIDAuNSwgMCwgICAwLjUsIC0gMC41LCAwLCAgIDAuNSwgMC41LCAwLCAgIC0gMC41LCAwLjUsIDAgXSApO1xyXG5cdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIDAsIDAsICAgMSwgMCwgICAxLCAxLCAgIDAsIDEgXSApO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gU3ByaXRlKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1Nwcml0ZSc7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG5cdFx0dGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoKTtcclxuXHJcblx0fTtcclxuXHJcbn0gKSgpO1xyXG5cclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3ByaXRlO1xyXG5cclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XHJcblxyXG5cdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dmFyIGRpc3RhbmNlU3EgPSByYXljYXN0ZXIucmF5LmRpc3RhbmNlU3FUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xyXG5cdFx0dmFyIGd1ZXNzU2l6ZVNxID0gdGhpcy5zY2FsZS54ICogdGhpcy5zY2FsZS55O1xyXG5cclxuXHRcdGlmICggZGlzdGFuY2VTcSA+IGd1ZXNzU2l6ZVNxICkge1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdGRpc3RhbmNlOiBNYXRoLnNxcnQoIGRpc3RhbmNlU3EgKSxcclxuXHRcdFx0cG9pbnQ6IHRoaXMucG9zaXRpb24sXHJcblx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdG9iamVjdDogdGhpc1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKSApO1xyXG5cclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG5USFJFRS5QYXJ0aWNsZSA9IFRIUkVFLlNwcml0ZTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvTGVuc0ZsYXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MZW5zRmxhcmUgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5sZW5zRmxhcmVzID0gW107XHJcblxyXG5cdHRoaXMucG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcblxyXG5cdGlmICggdGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMuYWRkKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MZW5zRmxhcmU7XHJcblxyXG5cclxuLypcclxuICogQWRkOiBhZGRzIGFub3RoZXIgZmxhcmVcclxuICovXHJcblxyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcclxuXHJcblx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gLSAxO1xyXG5cdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcclxuXHRpZiAoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xyXG5cdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XHJcblxyXG5cdGRpc3RhbmNlID0gTWF0aC5taW4oIGRpc3RhbmNlLCBNYXRoLm1heCggMCwgZGlzdGFuY2UgKSApO1xyXG5cclxuXHR0aGlzLmxlbnNGbGFyZXMucHVzaCgge1xyXG5cdFx0dGV4dHVyZTogdGV4dHVyZSxcdC8vIFRIUkVFLlRleHR1cmVcclxuXHRcdHNpemU6IHNpemUsIFx0XHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcclxuXHRcdGRpc3RhbmNlOiBkaXN0YW5jZSwgXHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXHJcblx0XHR4OiAwLCB5OiAwLCB6OiAwLFx0Ly8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBpbiBmcm9udCB6ID0gMSBpcyBiYWNrXHJcblx0XHRzY2FsZTogMSwgXHRcdC8vIHNjYWxlXHJcblx0XHRyb3RhdGlvbjogMCwgXHRcdC8vIHJvdGF0aW9uXHJcblx0XHRvcGFjaXR5OiBvcGFjaXR5LFx0Ly8gb3BhY2l0eVxyXG5cdFx0Y29sb3I6IGNvbG9yLFx0XHQvLyBjb2xvclxyXG5cdFx0YmxlbmRpbmc6IGJsZW5kaW5nXHQvLyBibGVuZGluZ1xyXG5cdH0gKTtcclxuXHJcbn07XHJcblxyXG4vKlxyXG4gKiBVcGRhdGUgbGVucyBmbGFyZXMgdXBkYXRlIHBvc2l0aW9ucyBvbiBhbGwgZmxhcmVzIGJhc2VkIG9uIHRoZSBzY3JlZW4gcG9zaXRpb25cclxuICogU2V0IG15TGVuc0ZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrIHRvIGFsdGVyIHRoZSBmbGFyZXMgaW4geW91ciBwcm9qZWN0IHNwZWNpZmljIHdheS5cclxuICovXHJcblxyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLnVwZGF0ZUxlbnNGbGFyZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBmLCBmbCA9IHRoaXMubGVuc0ZsYXJlcy5sZW5ndGg7XHJcblx0dmFyIGZsYXJlO1xyXG5cdHZhciB2ZWNYID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKiAyO1xyXG5cdHZhciB2ZWNZID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKiAyO1xyXG5cclxuXHRmb3IgKCBmID0gMDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdGZsYXJlID0gdGhpcy5sZW5zRmxhcmVzWyBmIF07XHJcblxyXG5cdFx0ZmxhcmUueCA9IHRoaXMucG9zaXRpb25TY3JlZW4ueCArIHZlY1ggKiBmbGFyZS5kaXN0YW5jZTtcclxuXHRcdGZsYXJlLnkgPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKyB2ZWNZICogZmxhcmUuZGlzdGFuY2U7XHJcblxyXG5cdFx0ZmxhcmUud2FudGVkUm90YXRpb24gPSBmbGFyZS54ICogTWF0aC5QSSAqIDAuMjU7XHJcblx0XHRmbGFyZS5yb3RhdGlvbiArPSAoIGZsYXJlLndhbnRlZFJvdGF0aW9uIC0gZmxhcmUucm90YXRpb24gKSAqIDAuMjU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMucG9zaXRpb25TY3JlZW4uY29weSggc291cmNlLnBvc2l0aW9uU2NyZWVuICk7XHJcblx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHNvdXJjZS5jdXN0b21VcGRhdGVDYWxsYmFjaztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmxlbnNGbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR0aGlzLmxlbnNGbGFyZXMucHVzaCggc291cmNlLmxlbnNGbGFyZXNbIGkgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3NjZW5lcy9TY2VuZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2NlbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1NjZW5lJztcclxuXHJcblx0dGhpcy5mb2cgPSBudWxsO1xyXG5cdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNjZW5lO1xyXG5cclxuVEhSRUUuU2NlbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdGlmICggc291cmNlLmZvZyAhPT0gbnVsbCApIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xyXG5cdGlmICggc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xyXG5cclxuXHR0aGlzLmF1dG9VcGRhdGUgPSBzb3VyY2UuYXV0b1VwZGF0ZTtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvc2NlbmVzL0ZvZy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRm9nID0gZnVuY3Rpb24gKCBjb2xvciwgbmVhciwgZmFyICkge1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcclxuXHJcblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAxO1xyXG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Gb2cucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2dFeHAyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Gb2dFeHAyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVuc2l0eSApIHtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XHJcblx0dGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkZvZ0V4cDIoIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMuZGVuc2l0eSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rLmpzXHJcblxyXG5USFJFRS5TaGFkZXJDaHVuayA9IHt9O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYXRlc3RfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYXRlc3RfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIEFMUEhBVEVTVFxcblxcblx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hb21hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXG5cdHRvdGFsQW1iaWVudExpZ2h0ICo9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYmVnaW5fdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYmVnaW5fdmVydGV4J10gPSBcIlxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYmVnaW5ub3JtYWxfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYmVnaW5ub3JtYWxfdmVydGV4J10gPSBcIlxcbnZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9idW1wbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdidW1wbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFxuXFxuXFxuXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXG5cdFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblx0XHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFxuXHRcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cdFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXHRcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcblx0XHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXG5cdH1cXG5cXG5cdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXFxuXHRcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXHRcdHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXG5cdFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblxcblx0XHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcblxcblx0XHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dkNvbG9yLnh5eiA9IGNvbG9yLnh5ejtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbW1vbi5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbW1vbiddID0gXCIjZGVmaW5lIFBJIDMuMTQxNTlcXG4jZGVmaW5lIFBJMiA2LjI4MzE4XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0XFxuI2RlZmluZSBMT0cyIDEuNDQyNjk1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG5cXG4jZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2RlZmluZSB3aGl0ZUNvbXBsaW1lbnQoYSkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5cXG52ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBub3JtYWwsIGluIG1hdDQgbWF0cml4ICkge1xcblxcblx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBub3JtYWwsIDAuMCApICkueHl6ICk7XFxuXFxufVxcblxcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBub3JtYWwsIGluIG1hdDQgbWF0cml4ICkge1xcblxcblx0cmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBub3JtYWwsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxuXFxufVxcblxcbnZlYzMgcHJvamVjdE9uUGxhbmUoaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuXHRmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50IC0gcG9pbnRPblBsYW5lICk7XFxuXFxuXHRyZXR1cm4gLSBkaXN0YW5jZSAqIHBsYW5lTm9ybWFsICsgcG9pbnQ7XFxuXFxufVxcblxcbmZsb2F0IHNpZGVPZlBsYW5lKCBpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG5cdHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxuXFxufVxcblxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblx0cmV0dXJuIGxpbmVEaXJlY3Rpb24gKiAoIGRvdCggcGxhbmVOb3JtYWwsIHBvaW50T25QbGFuZSAtIHBvaW50T25MaW5lICkgLyBkb3QoIHBsYW5lTm9ybWFsLCBsaW5lRGlyZWN0aW9uICkgKSArIHBvaW50T25MaW5lO1xcblxcbn1cXG5cXG5mbG9hdCBjYWxjTGlnaHRBdHRlbnVhdGlvbiggZmxvYXQgbGlnaHREaXN0YW5jZSwgZmxvYXQgY3V0b2ZmRGlzdGFuY2UsIGZsb2F0IGRlY2F5RXhwb25lbnQgKSB7XFxuXFxuXHRpZiAoIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuXFxuXHQgIHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG5cXG5cdH1cXG5cXG5cdHJldHVybiAxLjA7XFxuXFxufVxcblxcbnZlYzMgRl9TY2hsaWNrKCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGluIGZsb2F0IGRvdExIICkge1xcblxcblxcblx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLTUuNTU0MzcgKiBkb3RMSCAtIDYuOTgzMTYgKSAqIGRvdExIICk7XFxuXFxuXHRyZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcXG5cXG59XFxuXFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCAvKiBpbiBmbG9hdCBkb3ROTCwgaW4gZmxvYXQgZG90TlYgKi8gKSB7XFxuXFxuXFxuXHRyZXR1cm4gMC4yNTtcXG5cXG59XFxuXFxuZmxvYXQgRF9CbGlublBob25nKCBpbiBmbG9hdCBzaGluaW5lc3MsIGluIGZsb2F0IGRvdE5IICkge1xcblxcblxcblx0cmV0dXJuICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG5cXG59XFxuXFxudmVjMyBCUkRGX0JsaW5uUGhvbmcoIGluIHZlYzMgc3BlY3VsYXJDb2xvciwgaW4gZmxvYXQgc2hpbmluZXNzLCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjMyBsaWdodERpciwgaW4gdmVjMyB2aWV3RGlyICkge1xcblxcblx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcXG5cXG5cdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggbGlnaHREaXIsIGhhbGZEaXIgKSApO1xcblxcblx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcblxcblx0ZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggLyogZG90TkwsIGRvdE5WICovICk7XFxuXFxuXHRmbG9hdCBEID0gRF9CbGlublBob25nKCBzaGluaW5lc3MsIGRvdE5IICk7XFxuXFxuXHRyZXR1cm4gRiAqIEcgKiBEO1xcblxcbn1cXG5cXG52ZWMzIGlucHV0VG9MaW5lYXIoIGluIHZlYzMgYSApIHtcXG5cXG5cdCNpZmRlZiBHQU1NQV9JTlBVVFxcblxcblx0XHRyZXR1cm4gcG93KCBhLCB2ZWMzKCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKSApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0cmV0dXJuIGE7XFxuXFxuXHQjZW5kaWZcXG5cXG59XFxuXFxudmVjMyBsaW5lYXJUb091dHB1dCggaW4gdmVjMyBhICkge1xcblxcblx0I2lmZGVmIEdBTU1BX09VVFBVVFxcblxcblx0XHRyZXR1cm4gcG93KCBhLCB2ZWMzKCAxLjAgLyBmbG9hdCggR0FNTUFfRkFDVE9SICkgKSApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0cmV0dXJuIGE7XFxuXFxuXHQjZW5kaWZcXG5cXG59XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kZWZhdWx0bm9ybWFsX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2RlZmF1bHRub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBGTElQX1NJREVEXFxuXFxuXHRvYmplY3ROb3JtYWwgPSAtb2JqZWN0Tm9ybWFsO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiBvYmplY3ROb3JtYWw7XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXNwbGFjZW1lbnRtYXBfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZGlzcGxhY2VtZW50bWFwX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcblx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXG5cdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50U2NhbGU7XFxuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2VtaXNzaXZlbWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXG5cdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZVdiApO1xcblxcblx0ZW1pc3NpdmVDb2xvci5yZ2IgPSBpbnB1dFRvTGluZWFyKCBlbWlzc2l2ZUNvbG9yLnJnYiApO1xcblxcblx0dG90YWxFbWlzc2l2ZUxpZ2h0ICo9IGVtaXNzaXZlQ29sb3IucmdiO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2VtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHRcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG5cdFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcblx0XHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcblx0XHRcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcblx0XHQjZWxzZVxcblxcblx0XHRcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0I2Vsc2VcXG5cXG5cdFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBET1VCTEVfU0lERURcXG5cdFx0ZmxvYXQgZmxpcE5vcm1hbCA9ICggZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKiAyLjAgLSAxLjAgKTtcXG5cdCNlbHNlXFxuXHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAxLjA7XFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXG5cdFx0dmVjMiBzYW1wbGVVVjtcXG5cdFx0c2FtcGxlVVYueSA9IHNhdHVyYXRlKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy55ICogMC41ICsgMC41ICk7XFxuXHRcdHNhbXBsZVVWLnggPSBhdGFuKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy56LCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcblxcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXG5cdFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoKHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSkueHl6ICsgdmVjMygwLjAsMC4wLDEuMCkpO1xcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41ICk7XFxuXHQjZW5kaWZcXG5cXG5cdGVudkNvbG9yLnh5eiA9IGlucHV0VG9MaW5lYXIoIGVudkNvbG9yLnh5eiApO1xcblxcblx0I2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWVxcblxcblx0XHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXG5cXG5cdFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXG5cXG5cdFx0b3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5O1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXHRcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcblx0I2Vsc2VcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcblx0I2VuZGlmXFxuXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFxuXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0XHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcblx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXG5cdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG5cdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcblx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG5cdFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZm9nX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdEZXB0aEVYVCAvIGdsX0ZyYWdDb29yZC53O1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1xcblxcblx0I2VuZGlmXFxuXFxuXHQjaWZkZWYgRk9HX0VYUDJcXG5cXG5cdFx0ZmxvYXQgZm9nRmFjdG9yID0gd2hpdGVDb21wbGltZW50KCBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKSApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0ZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApO1xcblxcblx0I2VuZGlmXFxuXHRcXG5cdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2ZvZ19wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZm9nX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXG5cdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cXG5cdCNpZmRlZiBGT0dfRVhQMlxcblxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9oZW1pbGlnaHRfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdoZW1pbGlnaHRfZnJhZ21lbnQnXSA9IFwiI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdO1xcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcblx0XHR0b3RhbEFtYmllbnRMaWdodCArPSBsaWdodENvbG9yO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHR0b3RhbEFtYmllbnRMaWdodCArPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG5cdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4J10gPSBcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREZWNheVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfbGFtYmVydF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfbGFtYmVydF92ZXJ0ZXgnXSA9IFwidkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHR2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBwb2ludExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcblx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdHZMaWdodEJhY2sgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIC0gZG90UHJvZHVjdCApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBzcG90TGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0UG9zaXRpb24gPSBzcG90TGlnaHRQb3NpdGlvblsgaSBdO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsaWdodFBvc2l0aW9uIC0gbXZQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cdFx0ZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIGxpZ2h0RGlyICk7XFxuXFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXHRcdFx0c3BvdEVmZmVjdCA9IHNhdHVyYXRlKCBwb3coIHNhdHVyYXRlKCBzcG90RWZmZWN0ICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSApO1xcblxcblxcblx0XHRcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXHRcdFx0YXR0ZW51YXRpb24gKj0gc3BvdEVmZmVjdDtcXG5cXG5cXG5cdFx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdFx0dkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0XHR2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0XHQjZW5kaWZcXG5cXG5cdFx0fVxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHR2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdHZMaWdodEJhY2sgKz0gbGlnaHRDb2xvciAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdO1xcblxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHRCYWNrID0gLSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcblx0XHRcdHZMaWdodEJhY2sgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfZnJhZ21lbnQnXSA9IFwidmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuXFxudmVjMyB0b3RhbERpZmZ1c2VMaWdodCA9IHZlYzMoIDAuMCApO1xcbnZlYzMgdG90YWxTcGVjdWxhckxpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBwb2ludExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gcG9pbnRMaWdodFBvc2l0aW9uWyBpIF07XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxpZ2h0UG9zaXRpb24gKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcblx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXFxuXHRcdGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG5cdFx0dG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cXG5cdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG5cdFx0dmVjMyBsVmVjdG9yID0gbGlnaHRQb3NpdGlvbiArIHZWaWV3UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBsaWdodERpciApO1xcblxcblx0XHRpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1xcblxcblx0XHRcdHNwb3RFZmZlY3QgPSBzYXR1cmF0ZSggcG93KCBzYXR1cmF0ZSggc3BvdEVmZmVjdCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICkgKTtcXG5cXG5cXG5cdFx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblx0XHRcdGF0dGVudWF0aW9uICo9IHNwb3RFZmZlY3Q7XFxuXFxuXFxuXHRcdFx0ZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcblx0XHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXFxuXHRcdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cdFx0fVxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cXG5cdFx0ZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcblx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogY29zaW5lVGVybTtcXG5cXG5cXG5cdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCddID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERlY2F5WyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5cXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX3ZlcnRleCddID0gXCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfdmVydGV4J10gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpbmVhcl90b19nYW1tYV9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpbmVhcl90b19nYW1tYV9mcmFnbWVudCddID0gXCJcXG5cdG91dGdvaW5nTGlnaHQgPSBsaW5lYXJUb091dHB1dCggb3V0Z29pbmdMaWdodCApO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9mcmFnbWVudCddID0gXCIjaWYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUYpICYmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGX0VYVClcXG5cXG5cdGdsX0ZyYWdEZXB0aEVYVCA9IGxvZzIodkZyYWdEZXB0aCkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cdCNlbmRpZlxcblxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cdGdsX1Bvc2l0aW9uLnogPSBsb2cyKG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApKSAqIGxvZ0RlcHRoQnVmRkM7XFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXG4jZWxzZVxcblxcblx0XHRnbF9Qb3NpdGlvbi56ID0gKGdsX1Bvc2l0aW9uLnogLSAxLjApICogZ2xfUG9zaXRpb24udztcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxuXFxuXHR0ZXhlbENvbG9yLnh5eiA9IGlucHV0VG9MaW5lYXIoIHRleGVsQ29sb3IueHl6ICk7XFxuXFxuXHRkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5ICk7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGhub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcblx0I2Vsc2VcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBodGFyZ2V0X3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ub3JtYWxfcGhvbmdfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdub3JtYWxfcGhvbmdfZnJhZ21lbnQnXSA9IFwiI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcblx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTtcXG5cXG5cdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0bm9ybWFsID0gbm9ybWFsICogKCAtMS4wICsgMi4wICogZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbHNlXFxuXFxuXHR2ZWMzIGZkeCA9IGRGZHgoIHZWaWV3UG9zaXRpb24gKTtcXG5cdHZlYzMgZmR5ID0gZEZkeSggdlZpZXdQb3NpdGlvbiApO1xcblx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBmZHgsIGZkeSApICk7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXG5cdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuXFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXG5cXG4jZW5kaWZcXG5cXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG5cdHVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcXG5cXG5cXG5cdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XFxuXFxuXHRcdHZlYzMgcTAgPSBkRmR4KCBleWVfcG9zLnh5eiApO1xcblx0XHR2ZWMzIHExID0gZEZkeSggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXG5cdFx0dmVjMiBzdDEgPSBkRmR5KCB2VXYuc3QgKTtcXG5cXG5cdFx0dmVjMyBTID0gbm9ybWFsaXplKCBxMCAqIHN0MS50IC0gcTEgKiBzdDAudCApO1xcblx0XHR2ZWMzIFQgPSBub3JtYWxpemUoIC1xMCAqIHN0MS5zICsgcTEgKiBzdDAucyApO1xcblx0XHR2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1xcblxcblx0XHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblx0XHRtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1xcblx0XHRtYXQzIHRzbiA9IG1hdDMoIFMsIFQsIE4gKTtcXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvcHJvamVjdF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdwcm9qZWN0X3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBza2lubmVkO1xcblxcbiNlbHNlXFxuXFxuXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFxuI2VuZGlmXFxuXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuXHRcdGZsb2F0IHRleGVsU2l6ZVkgPSAgMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XFxuXFxuXHRcdGZsb2F0IHNoYWRvdyA9IDAuMDtcXG5cXG4jaWYgZGVmaW5lZCggUE9JTlRfTElHSFRfU0hBRE9XUyApXFxuXFxuXHRcdGJvb2wgaXNQb2ludExpZ2h0ID0gc2hhZG93RGFya25lc3NbIGkgXSA8IDAuMDtcXG5cXG5cdFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XFxuXFxuXHRcdFx0ZmxvYXQgcmVhbFNoYWRvd0RhcmtuZXNzID0gYWJzKCBzaGFkb3dEYXJrbmVzc1sgaSBdICk7XFxuXFxuXHRcdFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSB2U2hhZG93Q29vcmRbIGkgXS54eXo7XFxuXFxuXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcblx0XHRcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXHRcdFx0ZmxvYXQgZHAgPSBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFxuXFxuXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cdFx0XHRjb25zdCBmbG9hdCBEciA9IDEuMjU7XFxuXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXHRcdFx0Y29uc3QgZmxvYXQgRHIgPSAyLjI1O1xcblx0I2VuZGlmXFxuXFxuXHRcdFx0ZmxvYXQgb3MgPSBEciAqICAyLjAgKiB0ZXhlbFNpemVZO1xcblxcblx0XHRcdGNvbnN0IHZlYzMgR3NkID0gdmVjMyggLSAxLCAwLCAxICk7XFxuXFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp6eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenh6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eHogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh6eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenp4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56eHggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh4eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHp4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56enkgKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp4eSAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHh5ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54enkgKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp5eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHl6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56eXggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh5eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueXp6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC55eHogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnl4eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueXp4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcblx0XHRcdHNoYWRvdyAqPSByZWFsU2hhZG93RGFya25lc3MgKiAoIDEuMCAvIDIxLjAgKTtcXG5cXG5cdCNlbHNlIFxcblx0XHRcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXHRcdFx0ZmxvYXQgZHAgPSBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFxuXHRcdFx0c2hhZG93ICo9IHJlYWxTaGFkb3dEYXJrbmVzcztcXG5cXG5cdCNlbmRpZlxcblxcblx0XHR9IGVsc2Uge1xcblxcbiNlbmRpZiBcXG5cdFx0XHRmbG9hdCB0ZXhlbFNpemVYID0gIDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS54O1xcblxcblx0XHRcdHZlYzMgc2hhZG93Q29vcmQgPSB2U2hhZG93Q29vcmRbIGkgXS54eXogLyB2U2hhZG93Q29vcmRbIGkgXS53O1xcblxcblxcblx0XHRcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXG5cdFx0XHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFxuXHRcdFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcblx0XHRcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFxuXHRcdFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXG5cdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcblxcblx0XHRcdFx0LypcXG5cdFx0XHRcdFx0Zm9yICggZmxvYXQgeSA9IC0xLjI1OyB5IDw9IDEuMjU7IHkgKz0gMS4yNSApXFxuXHRcdFx0XHRcdFx0Zm9yICggZmxvYXQgeCA9IC0xLjI1OyB4IDw9IDEuMjU7IHggKz0gMS4yNSApIHtcXG5cdFx0XHRcdFx0XHRcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKTtcXG5cdFx0XHRcdFx0XHRcdGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcXG5cdFx0XHRcdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuXHRcdFx0XHRcdFx0XHRcdHNoYWRvdyArPSAxLjA7XFxuXHRcdFx0XHRcdH1cXG5cdFx0XHRcdFx0c2hhZG93IC89IDkuMDtcXG5cdFx0XHRcdCovXFxuXFxuXHRcdFx0XHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXNbIGkgXTtcXG5cXG5cdFx0XHRcdGNvbnN0IGZsb2F0IFNoYWRvd0RlbHRhID0gMS4wIC8gOS4wO1xcblxcblx0XHRcdFx0ZmxvYXQgeFBpeGVsT2Zmc2V0ID0gdGV4ZWxTaXplWDtcXG5cdFx0XHRcdGZsb2F0IHlQaXhlbE9mZnNldCA9IHRleGVsU2l6ZVk7XFxuXFxuXHRcdFx0XHRmbG9hdCBkeDAgPSAtIDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTAgPSAtIDEuMjUgKiB5UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeDEgPSAxLjI1ICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkxID0gMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cXG5cdFx0XHRcdGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0c2hhZG93ICo9IHNoYWRvd0RhcmtuZXNzWyBpIF07XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFxuXFxuXHRcdFx0XHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXNbIGkgXTtcXG5cXG5cdFx0XHRcdGZsb2F0IHhQaXhlbE9mZnNldCA9IHRleGVsU2l6ZVg7XFxuXHRcdFx0XHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSB0ZXhlbFNpemVZO1xcblxcblx0XHRcdFx0ZmxvYXQgZHgwID0gLSAxLjAgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTAgPSAtIDEuMCAqIHlQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR4MSA9IDEuMCAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MSA9IDEuMCAqIHlQaXhlbE9mZnNldDtcXG5cXG5cdFx0XHRcdG1hdDMgc2hhZG93S2VybmVsO1xcblx0XHRcdFx0bWF0MyBkZXB0aEtlcm5lbDtcXG5cXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAwIF1bIDAgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDAgXVsgMSBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMCBdWyAyIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAxIF1bIDAgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDEgXVsgMSBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAxIF1bIDIgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDIgXVsgMCBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMiBdWyAxIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAyIF1bIDIgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1xcblxcblx0XHRcdFx0dmVjMyBzaGFkb3daID0gdmVjMyggc2hhZG93Q29vcmQueiApO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWyAwIF0gPSB2ZWMzKCBsZXNzVGhhbiggZGVwdGhLZXJuZWxbIDAgXSwgc2hhZG93WiApICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDAgXSAqPSB2ZWMzKCAwLjI1ICk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDEgXSA9IHZlYzMoIGxlc3NUaGFuKCBkZXB0aEtlcm5lbFsgMSBdLCBzaGFkb3daICkgKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMSBdICo9IHZlYzMoIDAuMjUgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMiBdID0gdmVjMyggbGVzc1RoYW4oIGRlcHRoS2VybmVsWyAyIF0sIHNoYWRvd1ogKSApO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWyAyIF0gKj0gdmVjMyggMC4yNSApO1xcblxcblx0XHRcdFx0dmVjMiBmcmFjdGlvbmFsQ29vcmQgPSAxLjAgLSBmcmFjdCggc2hhZG93Q29vcmQueHkgKiBzaGFkb3dNYXBTaXplWyBpIF0ueHkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMCBdID0gbWl4KCBzaGFkb3dLZXJuZWxbIDEgXSwgc2hhZG93S2VybmVsWyAwIF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDEgXSA9IG1peCggc2hhZG93S2VybmVsWyAyIF0sIHNoYWRvd0tlcm5lbFsgMSBdLCBmcmFjdGlvbmFsQ29vcmQueCApO1xcblxcblx0XHRcdFx0dmVjNCBzaGFkb3dWYWx1ZXM7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWyAwIF1bIDEgXSwgc2hhZG93S2VybmVsWyAwIF1bIDAgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy55ID0gbWl4KCBzaGFkb3dLZXJuZWxbIDAgXVsgMiBdLCBzaGFkb3dLZXJuZWxbIDAgXVsgMSBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLnogPSBtaXgoIHNoYWRvd0tlcm5lbFsgMSBdWyAxIF0sIHNoYWRvd0tlcm5lbFsgMSBdWyAwIF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWyAxIF1bIDIgXSwgc2hhZG93S2VybmVsWyAxIF1bIDEgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvdyA9IGRvdCggc2hhZG93VmFsdWVzLCB2ZWM0KCAxLjAgKSApICogc2hhZG93RGFya25lc3NbIGkgXTtcXG5cXG5cdCNlbHNlIFxcblx0XHRcdFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzWyBpIF07XFxuXFxuXHRcdFx0XHR2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcblx0XHRcdFx0XHRzaGFkb3cgPSBzaGFkb3dEYXJrbmVzc1sgaSBdO1xcblxcblx0I2VuZGlmXFxuXFxuXHRcdFx0fVxcblxcbiNpZmRlZiBTSEFET1dNQVBfREVCVUdcXG5cXG5cdFx0XHRpZiAoIGluRnJ1c3R1bSApIHtcXG5cXG5cdFx0XHRcdGlmICggaSA9PSAwICkge1xcblxcblx0XHRcdFx0XHRvdXRnb2luZ0xpZ2h0ICo9IHZlYzMoIDEuMCwgMC41LCAwLjAgKTtcXG5cXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGkgPT0gMSApIHtcXG5cXG5cdFx0XHRcdFx0b3V0Z29pbmdMaWdodCAqPSB2ZWMzKCAwLjAsIDEuMCwgMC44ICk7XFxuXFxuXHRcdFx0XHR9IGVsc2Uge1xcblxcblx0XHRcdFx0XHRvdXRnb2luZ0xpZ2h0ICo9IHZlYzMoIDAuMCwgMC41LCAxLjAgKTtcXG5cXG5cdFx0XHRcdH1cXG5cXG5cdFx0XHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQoIFBPSU5UX0xJR0hUX1NIQURPV1MgKVxcblxcblx0XHR9XFxuXFxuI2VuZGlmXFxuXFxuXHRcdHNoYWRvd01hc2sgPSBzaGFkb3dNYXNrICogdmVjMyggMS4wIC0gc2hhZG93ICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dNYXBbIE1BWF9TSEFET1dTIF07XFxuXHR1bmlmb3JtIHZlYzIgc2hhZG93TWFwU2l6ZVsgTUFYX1NIQURPV1MgXTtcXG5cXG5cdHVuaWZvcm0gZmxvYXQgc2hhZG93RGFya25lc3NbIE1BWF9TSEFET1dTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0JpYXNbIE1BWF9TSEFET1dTIF07XFxuXFxuXHR2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0ZmxvYXQgdW5wYWNrRGVwdGgoIGNvbnN0IGluIHZlYzQgcmdiYV9kZXB0aCApIHtcXG5cXG5cdFx0Y29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1xcblx0XHRmbG9hdCBkZXB0aCA9IGRvdCggcmdiYV9kZXB0aCwgYml0X3NoaWZ0ICk7XFxuXHRcdHJldHVybiBkZXB0aDtcXG5cXG5cdH1cXG5cXG5cdCNpZiBkZWZpbmVkKFBPSU5UX0xJR0hUX1NIQURPV1MpXFxuXFxuXFxuXHRcdHZvaWQgYWRqdXN0U2hhZG93VmFsdWUxSyggY29uc3QgZmxvYXQgdGVzdERlcHRoLCBjb25zdCB2ZWM0IHRleHR1cmVEYXRhLCBjb25zdCBmbG9hdCBiaWFzLCBpbm91dCBmbG9hdCBzaGFkb3dWYWx1ZSApIHtcXG5cXG5cdFx0XHRjb25zdCB2ZWM0IGJpdFNoID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG5cdFx0XHRpZiAoIHRlc3REZXB0aCA+PSBkb3QoIHRleHR1cmVEYXRhLCBiaXRTaCApICogMTAwMC4wICsgYmlhcyApXFxuXHRcdFx0XHRzaGFkb3dWYWx1ZSArPSAxLjA7XFxuXFxuXHRcdH1cXG5cXG5cXG5cdFx0dmVjMiBjdWJlVG9VViggdmVjMyB2LCBmbG9hdCB0ZXhlbFNpemVZICkge1xcblxcblxcblx0XHRcdHZlYzMgYWJzViA9IGFicyggdiApO1xcblxcblxcblx0XHRcdGZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApO1xcblx0XHRcdGFic1YgKj0gc2NhbGVUb0N1YmU7XFxuXFxuXFxuXHRcdFx0diAqPSBzY2FsZVRvQ3ViZSAqICggMS4wIC0gMi4wICogdGV4ZWxTaXplWSApO1xcblxcblxcblxcblx0XHRcdHZlYzIgcGxhbmFyID0gdi54eTtcXG5cXG5cdFx0XHRmbG9hdCBhbG1vc3RBVGV4ZWwgPSAxLjUgKiB0ZXhlbFNpemVZO1xcblx0XHRcdGZsb2F0IGFsbW9zdE9uZSA9IDEuMCAtIGFsbW9zdEFUZXhlbDtcXG5cXG5cdFx0XHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XFxuXFxuXHRcdFx0XHRpZiAoIHYueiA+IDAuMCApXFxuXHRcdFx0XHRcdHBsYW5hci54ID0gNC4wIC0gdi54O1xcblxcblx0XHRcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XFxuXFxuXHRcdFx0XHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xcblx0XHRcdFx0cGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YO1xcblxcblx0XHRcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxuXFxuXHRcdFx0XHRmbG9hdCBzaWduWSA9IHNpZ24oIHYueSApO1xcblx0XHRcdFx0cGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDtcXG5cdFx0XHRcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxuXFxuXHRcdFx0fVxcblxcblxcblx0XHRcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcXG5cXG5cdFx0fVxcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdHVuaWZvcm0gZmxvYXQgc2hhZG93RGFya25lc3NbIE1BWF9TSEFET1dTIF07XFxuXHR1bmlmb3JtIG1hdDQgc2hhZG93TWF0cml4WyBNQVhfU0hBRE9XUyBdO1xcblx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG5cdFx0XHR2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5iYXNlX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5iYXNlX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG5cdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7XFxuXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFxuXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcblx0XHR1bmlmb3JtIGludCBib25lVGV4dHVyZVdpZHRoO1xcblx0XHR1bmlmb3JtIGludCBib25lVGV4dHVyZUhlaWdodDtcXG5cXG5cdFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcblx0XHRcdGZsb2F0IGogPSBpICogNC4wO1xcblx0XHRcdGZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cdFx0XHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXFxuXHRcdFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApO1xcblx0XHRcdGZsb2F0IGR5ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlSGVpZ2h0ICk7XFxuXFxuXHRcdFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFxuXHRcdFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcblx0XHRcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFxuXHRcdFx0cmV0dXJuIGJvbmU7XFxuXFxuXHRcdH1cXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHVuaWZvcm0gbWF0NCBib25lR2xvYmFsTWF0cmljZXNbIE1BWF9CT05FUyBdO1xcblxcblx0XHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXHRcdFx0bWF0NCBib25lID0gYm9uZUdsb2JhbE1hdHJpY2VzWyBpbnQoaSkgXTtcXG5cdFx0XHRyZXR1cm4gYm9uZTtcXG5cXG5cdFx0fVxcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubmluZ192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXG5cdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcblx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcblx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5ub3JtYWxfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblx0c2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcblx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX2ZyYWdtZW50J10gPSBcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxuXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcblx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcblxcbiNlbHNlXFxuXFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXHRhdHRyaWJ1dGUgdmVjMiB1djI7XFxuXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcblx0dlV2MiA9IHV2MjtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXY7XFxuXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXZfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG5cdHZVdiA9IHV2ICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5O1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvd29ybGRwb3NfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnd29ybGRwb3NfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcblxcblx0I2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0XHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHNraW5uZWQ7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIFVuaWZvcm0gVXRpbGl0aWVzXHJcbiAqL1xyXG5cclxuVEhSRUUuVW5pZm9ybXNVdGlscyA9IHtcclxuXHJcblx0bWVyZ2U6IGZ1bmN0aW9uICggdW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0dmFyIG1lcmdlZCA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcclxuXHJcblx0XHRcdHZhciB0bXAgPSB0aGlzLmNsb25lKCB1bmlmb3Jtc1sgdSBdICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XHJcblxyXG5cdFx0XHRcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtZXJnZWQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcclxuXHJcblx0XHR2YXIgdW5pZm9ybXNfZHN0ID0ge307XHJcblxyXG5cdFx0Zm9yICggdmFyIHUgaW4gdW5pZm9ybXNfc3JjICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcGFyYW1ldGVyX3NyYyA9IHVuaWZvcm1zX3NyY1sgdSBdWyBwIF07XHJcblxyXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yIHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjIgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3I0IHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDMgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHBhcmFtZXRlcl9zcmMgKSApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmlmb3Jtc19kc3Q7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc0xpYi5qc1xyXG5cclxuLyoqXHJcbiAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXHJcbiAqL1xyXG5cclxuVEhSRUUuVW5pZm9ybXNMaWIgPSB7XHJcblxyXG5cdGNvbW1vbjoge1xyXG5cclxuXHRcdFwiZGlmZnVzZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxyXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblxyXG5cdFx0XCJtYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXHJcblxyXG5cdFx0XCJzcGVjdWxhck1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwiYWxwaGFNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblxyXG5cdFx0XCJlbnZNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImZsaXBFbnZNYXBcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSxcclxuXHRcdFwicmVmbGVjdGl2aXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcInJlZnJhY3Rpb25SYXRpb1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuOTggfVxyXG5cclxuXHR9LFxyXG5cclxuXHRhb21hcDoge1xyXG5cclxuXHRcdFwiYW9NYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImFvTWFwSW50ZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cclxuXHR9LFxyXG5cclxuXHRsaWdodG1hcDoge1xyXG5cclxuXHRcdFwibGlnaHRNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImxpZ2h0TWFwSW50ZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cclxuXHR9LFxyXG5cclxuXHRlbWlzc2l2ZW1hcDoge1xyXG5cclxuXHRcdFwiZW1pc3NpdmVNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblxyXG5cdH0sXHJcblxyXG5cdGJ1bXBtYXA6IHtcclxuXHJcblx0XHRcImJ1bXBNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImJ1bXBTY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxtYXA6IHtcclxuXHJcblx0XHRcIm5vcm1hbE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwibm9ybWFsU2NhbGVcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3BsYWNlbWVudG1hcDoge1xyXG5cclxuXHRcdFwiZGlzcGxhY2VtZW50TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJkaXNwbGFjZW1lbnRTY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHRcdFwiZGlzcGxhY2VtZW50Qmlhc1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRmb2cgOiB7XHJcblxyXG5cdFx0XCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxyXG5cdFx0XCJmb2dOZWFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XCJmb2dGYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwIH0sXHJcblx0XHRcImZvZ0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cclxuXHJcblx0fSxcclxuXHJcblx0bGlnaHRzOiB7XHJcblxyXG5cdFx0XCJhbWJpZW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwiZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJkaXJlY3Rpb25hbExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcImhlbWlzcGhlcmVMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwicG9pbnRMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInBvaW50TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJwb2ludExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInBvaW50TGlnaHREZWNheVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcInNwb3RMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNwb3RMaWdodFBvc2l0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNwb3RMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHREaXN0YW5jZVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic3BvdExpZ2h0QW5nbGVDb3NcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNwb3RMaWdodEV4cG9uZW50XCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHREZWNheVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfVxyXG5cclxuXHR9LFxyXG5cclxuXHRwb2ludHM6IHtcclxuXHJcblx0XHRcInBzQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlICkgfSxcclxuXHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG5cdFx0XCJzaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcInNjYWxlXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwib2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcclxuXHJcblx0XHRcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXHJcblx0XHRcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblx0XHRcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcclxuXHRcdFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRzaGFkb3dtYXA6IHtcclxuXHJcblx0XHRcInNoYWRvd01hcFwiOiB7IHR5cGU6IFwidHZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNoYWRvd01hcFNpemVcIjogeyB0eXBlOiBcInYydlwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcInNoYWRvd0JpYXNcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNoYWRvd0RhcmtuZXNzXCI6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0XCJzaGFkb3dNYXRyaXhcIiA6IHsgdHlwZTogXCJtNHZcIiwgdmFsdWU6IFtdIH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi5qc1xyXG5cclxuLyoqXHJcbiAqIFdlYmdsIFNoYWRlciBMaWJyYXJ5IGZvciB0aHJlZS5qc1xyXG4gKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKi9cclxuXHJcblxyXG5USFJFRS5TaGFkZXJMaWIgPSB7XHJcblxyXG5cdCdiYXNpYyc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9FTlZNQVBcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0I2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblx0XHRcdFwiXHR2ZWMzIHRvdGFsQW1iaWVudExpZ2h0ID0gdmVjMyggMS4wICk7XCIsIC8vIGhhcmR3aXJlZFxyXG5cdFx0XHRcIlx0dmVjMyBzaGFkb3dNYXNrID0gdmVjMyggMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiB0b3RhbEFtYmllbnRMaWdodCAqIHNoYWRvd01hc2s7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0J2xhbWJlcnQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXHJcblxyXG5cdFx0XHR7XHJcblx0XHRcdFx0XCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9XHJcblx0XHRcdH1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgTEFNQkVSVFwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFwiXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFwiXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXHQvLyBvdXRnb2luZyBsaWdodCBkb2VzIG5vdCBoYXZlIGFuIGFscGhhLCB0aGUgc3VyZmFjZSBkb2VzXHJcblx0XHRcdFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuXHRcdFx0XCJcdHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSBhbWJpZW50TGlnaHRDb2xvcjtcIixcclxuXHRcdFx0XCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0I2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdFx0aWYgKCBnbF9Gcm9udEZhY2luZyApXCIsXHJcblx0XHRcdFwiXHRcdFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB2TGlnaHRGcm9udCAqIHNoYWRvd01hc2sgKyB0b3RhbEFtYmllbnRMaWdodCApICsgZW1pc3NpdmU7XCIsXHJcblx0XHRcdFwiXHRcdGVsc2VcIixcclxuXHRcdFx0XCJcdFx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHZMaWdodEJhY2sgKiBzaGFkb3dNYXNrICsgdG90YWxBbWJpZW50TGlnaHQgKSArIGVtaXNzaXZlO1wiLFxyXG5cclxuXHRcdFx0XCJcdCNlbHNlXCIsXHJcblxyXG5cdFx0XHRcIlx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHZMaWdodEZyb250ICogc2hhZG93TWFzayArIHRvdGFsQW1iaWVudExpZ2h0ICkgKyBlbWlzc2l2ZTtcIixcclxuXHJcblx0XHRcdFwiXHQjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQncGhvbmcnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFvbWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImJ1bXBtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJub3JtYWxtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJkaXNwbGFjZW1lbnRtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuXHRcdFx0XHRcInNwZWN1bGFyXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXHJcblx0XHRcdFx0XCJzaGluaW5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDMwIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwiI2RlZmluZSBQSE9OR1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLCAvLyBOb3JtYWwgY29tcHV0ZWQgd2l0aCBkZXJpdmF0aXZlcyB3aGVuIEZMQVRfU0hBREVEXHJcblxyXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCIjZGVmaW5lIFBIT05HXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BlY3VsYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnVtcG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibm9ybWFsbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG5cdFx0XHRcIlx0dmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IGFtYmllbnRMaWdodENvbG9yO1wiLFxyXG5cdFx0XHRcIlx0dmVjMyB0b3RhbEVtaXNzaXZlTGlnaHQgPSBlbWlzc2l2ZTtcIixcclxuXHRcdFx0XCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbF9waG9uZ19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImhlbWlsaWdodF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRcInRvdGFsRGlmZnVzZUxpZ2h0ICo9IHNoYWRvd01hc2s7XCIsXHJcblx0XHRcdFx0XCJ0b3RhbFNwZWN1bGFyTGlnaHQgKj0gc2hhZG93TWFzaztcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgTUVUQUxcIixcclxuXHJcblx0XHRcdFx0XCJcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICogc3BlY3VsYXIgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyB0b3RhbEVtaXNzaXZlTGlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XCJcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICsgdG90YWxTcGVjdWxhckxpZ2h0ICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH0sXHJcblxyXG5cdCdwb2ludHMnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInBvaW50c1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2l6ZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cIixcclxuXHRcdFx0XCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyBsZW5ndGgoIG12UG9zaXRpb24ueHl6ICkgKTtcIixcclxuXHRcdFx0XCJcdCNlbHNlXCIsXHJcblx0XHRcdFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemU7XCIsXHJcblx0XHRcdFwiXHQjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwc0NvbG9yO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBwc0NvbG9yLCBvcGFjaXR5ICk7XCIsXHJcblx0XHRcdFwiXHR2ZWMzIHNoYWRvd01hc2sgPSB2ZWMzKCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYiAqIHNoYWRvd01hc2s7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0J2Rhc2hlZCc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRcInNjYWxlXCIgICAgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XHRcdFwiZGFzaFNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblx0XHRcdFx0XCJ0b3RhbFNpemVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIgfVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0XCJcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHRcdFx0XCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFwiXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcIixcclxuXHJcblx0XHRcdFwiXHRcdGRpc2NhcmQ7XCIsXHJcblxyXG5cdFx0XHRcIlx0fVwiLFxyXG5cclxuXHRcdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XCIsIC8vIHNpbXBsZSBzaGFkZXJcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQnZGVwdGgnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFwibU5lYXJcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG5cdFx0XHRcIm1GYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwLjAgfSxcclxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbUZhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcclxuXHJcblx0XHRcdFwiXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2Vsc2VcIixcclxuXHJcblx0XHRcdFwiXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcclxuXHJcblx0XHRcdFwiXHQjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiXHRmbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1wiLFxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQnbm9ybWFsJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFwiXHR2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuNSAqIG5vcm1hbGl6ZSggdk5vcm1hbCApICsgMC41LCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHRDdWJlIG1hcCBzaGFkZXJcclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHQnY3ViZSc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFx0XHRcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSB9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFwiXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XCIsXHJcblxyXG5cdFx0XHRcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0Ly9cdEN1YmUgbWFwIHNoYWRlclxyXG5cdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5cdCdlcXVpcmVjdCc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogeyBcInRFcXVpcmVjdFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcdFx0XCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0gfSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxyXG5cclxuXHRcdFx0XCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdC8vIFwiXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMyIHNhbXBsZVVWO1wiLFxyXG5cdFx0XHRcdFwic2FtcGxlVVYueSA9IHNhdHVyYXRlKCB0RmxpcCAqIGRpcmVjdGlvbi55ICogLTAuNSArIDAuNSApO1wiLFxyXG5cdFx0XHRcdFwic2FtcGxlVVYueCA9IGF0YW4oIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XCIsXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQvKiBEZXB0aCBlbmNvZGluZyBpbnRvIFJHQkEgdGV4dHVyZVxyXG5cdCAqXHJcblx0ICogYmFzZWQgb24gU3BpZGVyR0wgc2hhZG93IG1hcCBleGFtcGxlXHJcblx0ICogaHR0cDovL3NwaWRlcmdsLm9yZy9leGFtcGxlLnBocD9pZD02XHJcblx0ICpcclxuXHQgKiBvcmlnaW5hbGx5IGZyb21cclxuXHQgKiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzQ0MjEzOC1wYWNraW5nLWEtZmxvYXQtaW50by1hLWE4cjhnOGI4LXRleHR1cmUtc2hhZGVyL3BhZ2VfX3doaWNocGFnZV9fMSUyNUVGJTI1QkYlMjVCRFxyXG5cdCAqXHJcblx0ICogc2VlIGFsc29cclxuXHQgKiBodHRwOi8vYXJhcy1wLmluZm8vYmxvZy8yMDA5LzA3LzMwL2VuY29kaW5nLWZsb2F0cy10by1yZ2JhLXRoZS1maW5hbC9cclxuXHQgKi9cclxuXHJcblx0J2RlcHRoUkdCQSc6IHtcclxuXHJcblx0XHR1bmlmb3Jtczoge30sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0Y29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjAgKTtcIixcclxuXHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0X21hc2sgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcclxuXHRcdFx0XCJcdHZlYzQgcmVzID0gbW9kKCBkZXB0aCAqIGJpdF9zaGlmdCAqIHZlYzQoIDI1NSApLCB2ZWM0KCAyNTYgKSApIC8gdmVjNCggMjU1ICk7XCIsIC8vIFwiXHR2ZWM0IHJlcyA9IGZyYWN0KCBkZXB0aCAqIGJpdF9zaGlmdCApO1wiLFxyXG5cdFx0XHRcIlx0cmVzIC09IHJlcy54eHl6ICogYml0X21hc2s7XCIsXHJcblx0XHRcdFwiXHRyZXR1cm4gcmVzO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXHJcblxyXG5cdFx0XHRcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2Vsc2VcIixcclxuXHJcblx0XHRcdFwiXHRcdGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxyXG5cclxuXHRcdFx0XCJcdCNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcclxuXHRcdFx0XHQvL1wiZmxvYXQgeiA9ICggKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICkgLSAzLjAgKSAvICggNDAwMC4wIC0gMy4wICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCB6ICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdCdkaXN0YW5jZVJHQkEnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFwibGlnaHRQb3NcIjogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblxyXG5cdFx0XHRcInZlYzQgcGFjazFLICggZmxvYXQgZGVwdGggKSB7XCIsXHJcblxyXG5cdFx0XHRcIiAgIGRlcHRoIC89IDEwMDAuMDtcIixcclxuXHRcdFx0XCIgICBjb25zdCB2ZWM0IGJpdFNoID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXHJcbiAgXHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0TXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXHJcbiAgIFx0XHRcdFwiXHR2ZWM0IHJlcyA9IGZyYWN0KCBkZXB0aCAqIGJpdFNoICk7XCIsXHJcbiAgIFx0XHRcdFwiXHRyZXMgLT0gcmVzLnh4eXogKiBiaXRNc2s7XCIsXHJcbiAgIFx0XHRcdFwiXHRyZXR1cm4gcmVzOyBcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJmbG9hdCB1bnBhY2sxSyAoIHZlYzQgY29sb3IgKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0Y29uc3QgdmVjNCBiaXRTaCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XCIsXHJcblx0XHRcdFwiXHRyZXR1cm4gZG90KCBjb2xvciwgYml0U2ggKSAqIDEwMDAuMDtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4gKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHBhY2sxSyggbGVuZ3RoKCB2V29ybGRQb3NpdGlvbi54eXogLSBsaWdodFBvcy54eXogKSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgVEhSRUUuUkVWSVNJT04gKTtcclxuXHJcblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG5cdHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcclxuXHRfY29udGV4dCA9IHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jb250ZXh0IDogbnVsbCxcclxuXHJcblx0X3dpZHRoID0gX2NhbnZhcy53aWR0aCxcclxuXHRfaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXHJcblxyXG5cdHBpeGVsUmF0aW8gPSAxLFxyXG5cclxuXHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXHJcblx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXHJcblx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXHJcblx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxyXG5cdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxyXG5cdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcclxuXHJcblx0X2NsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXHJcblx0X2NsZWFyQWxwaGEgPSAwO1xyXG5cclxuXHR2YXIgbGlnaHRzID0gW107XHJcblxyXG5cdHZhciBvcGFxdWVPYmplY3RzID0gW107XHJcblx0dmFyIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcblx0dmFyIHRyYW5zcGFyZW50T2JqZWN0cyA9IFtdO1xyXG5cdHZhciB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcblxyXG5cdHZhciBtb3JwaEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICk7XHJcblxyXG5cclxuXHR2YXIgc3ByaXRlcyA9IFtdO1xyXG5cdHZhciBsZW5zRmxhcmVzID0gW107XHJcblxyXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XHJcblx0dGhpcy5jb250ZXh0ID0gbnVsbDtcclxuXHJcblx0Ly8gY2xlYXJpbmdcclxuXHJcblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XHJcblxyXG5cdC8vIHNjZW5lIGdyYXBoXHJcblxyXG5cdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xyXG5cclxuXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcclxuXHJcblx0dGhpcy5nYW1tYUZhY3RvciA9IDIuMDtcdC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xyXG5cdHRoaXMuZ2FtbWFPdXRwdXQgPSBmYWxzZTtcclxuXHJcblx0Ly8gbW9ycGhzXHJcblxyXG5cdHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcclxuXHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XHJcblxyXG5cdC8vIGZsYWdzXHJcblxyXG5cdHRoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgPSB0cnVlO1xyXG5cclxuXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXHJcblxyXG5cdHZhciBfdGhpcyA9IHRoaXMsXHJcblxyXG5cdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXHJcblxyXG5cdF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXHJcblx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXHJcblx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxLFxyXG5cdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJycsXHJcblx0X2N1cnJlbnRDYW1lcmEgPSBudWxsLFxyXG5cclxuXHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXHJcblxyXG5cdF92aWV3cG9ydFggPSAwLFxyXG5cdF92aWV3cG9ydFkgPSAwLFxyXG5cdF92aWV3cG9ydFdpZHRoID0gX2NhbnZhcy53aWR0aCxcclxuXHRfdmlld3BvcnRIZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcclxuXHRfY3VycmVudFdpZHRoID0gMCxcclxuXHRfY3VycmVudEhlaWdodCA9IDAsXHJcblxyXG5cdC8vIGZydXN0dW1cclxuXHJcblx0X2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxyXG5cclxuXHQgLy8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXHJcblxyXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHQvLyBsaWdodCBhcnJheXMgY2FjaGVcclxuXHJcblx0X2RpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZSxcclxuXHJcblx0X2xpZ2h0cyA9IHtcclxuXHJcblx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcclxuXHRcdGRpcmVjdGlvbmFsOiB7IGxlbmd0aDogMCwgY29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSB9LFxyXG5cdFx0cG9pbnQ6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdLCBkaXN0YW5jZXM6IFtdLCBkZWNheXM6IFtdIH0sXHJcblx0XHRzcG90OiB7IGxlbmd0aDogMCwgY29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSwgZGlzdGFuY2VzOiBbXSwgZGlyZWN0aW9uczogW10sIGFuZ2xlc0NvczogW10sIGV4cG9uZW50czogW10sIGRlY2F5czogW10gfSxcclxuXHRcdGhlbWk6IHsgbGVuZ3RoOiAwLCBza3lDb2xvcnM6IFtdLCBncm91bmRDb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdIH1cclxuXHJcblx0fSxcclxuXHJcblx0Ly8gaW5mb1xyXG5cclxuXHRfaW5mb01lbW9yeSA9IHtcclxuXHJcblx0XHRnZW9tZXRyaWVzOiAwLFxyXG5cdFx0dGV4dHVyZXM6IDBcclxuXHJcblx0fSxcclxuXHJcblx0X2luZm9SZW5kZXIgPSB7XHJcblxyXG5cdFx0Y2FsbHM6IDAsXHJcblx0XHR2ZXJ0aWNlczogMCxcclxuXHRcdGZhY2VzOiAwLFxyXG5cdFx0cG9pbnRzOiAwXHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuaW5mbyA9IHtcclxuXHJcblx0XHRyZW5kZXI6IF9pbmZvUmVuZGVyLFxyXG5cdFx0bWVtb3J5OiBfaW5mb01lbW9yeSxcclxuXHRcdHByb2dyYW1zOiBudWxsXHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvLyBpbml0aWFsaXplXHJcblxyXG5cdHZhciBfZ2w7XHJcblxyXG5cdHRyeSB7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdGFscGhhOiBfYWxwaGEsXHJcblx0XHRcdGRlcHRoOiBfZGVwdGgsXHJcblx0XHRcdHN0ZW5jaWw6IF9zdGVuY2lsLFxyXG5cdFx0XHRhbnRpYWxpYXM6IF9hbnRpYWxpYXMsXHJcblx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogX3ByZW11bHRpcGxpZWRBbHBoYSxcclxuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyXHJcblx0XHR9O1xyXG5cclxuXHRcdF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLic7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHJcblx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgZXh0ZW5zaW9ucyA9IG5ldyBUSFJFRS5XZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xyXG5cclxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcblx0aWYgKCBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XHJcblxyXG5cdFx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2O1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBjYXBhYmlsaXRpZXMgPSBuZXcgVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApO1xyXG5cclxuXHR2YXIgc3RhdGUgPSBuZXcgVEhSRUUuV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApO1xyXG5cdHZhciBwcm9wZXJ0aWVzID0gbmV3IFRIUkVFLldlYkdMUHJvcGVydGllcygpO1xyXG5cdHZhciBvYmplY3RzID0gbmV3IFRIUkVFLldlYkdMT2JqZWN0cyggX2dsLCBwcm9wZXJ0aWVzLCB0aGlzLmluZm8gKTtcclxuXHR2YXIgcHJvZ3JhbUNhY2hlID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbXMoIHRoaXMsIGNhcGFiaWxpdGllcyApO1xyXG5cclxuXHR0aGlzLmluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XHJcblxyXG5cdHZhciBidWZmZXJSZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XHJcblx0dmFyIGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBnbENsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKSB7XHJcblxyXG5cdFx0aWYgKCBfcHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0ciAqPSBhOyBnICo9IGE7IGIgKj0gYTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2dsLmNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXREZWZhdWx0R0xTdGF0ZSgpIHtcclxuXHJcblx0XHRzdGF0ZS5pbml0KCk7XHJcblxyXG5cdFx0X2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XHJcblxyXG5cdFx0Z2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlc2V0R0xTdGF0ZSgpIHtcclxuXHJcblx0XHRfY3VycmVudFByb2dyYW0gPSBudWxsO1xyXG5cdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xyXG5cclxuXHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XHJcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XHJcblxyXG5cdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHN0YXRlLnJlc2V0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RGVmYXVsdEdMU3RhdGUoKTtcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gX2dsO1xyXG5cdHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xyXG5cdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XHJcblx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuXHQvLyBzaGFkb3cgbWFwXHJcblxyXG5cdHZhciBzaGFkb3dNYXAgPSBuZXcgVEhSRUUuV2ViR0xTaGFkb3dNYXAoIHRoaXMsIGxpZ2h0cywgb2JqZWN0cyApO1xyXG5cclxuXHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcclxuXHJcblxyXG5cdC8vIFBsdWdpbnNcclxuXHJcblx0dmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcclxuXHR2YXIgbGVuc0ZsYXJlUGx1Z2luID0gbmV3IFRIUkVFLkxlbnNGbGFyZVBsdWdpbiggdGhpcywgbGVuc0ZsYXJlcyApO1xyXG5cclxuXHQvLyBBUElcclxuXHJcblx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2w7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0ZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICkubG9zZUNvbnRleHQoKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHZhbHVlID0gX2dsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApKCk7XHJcblxyXG5cdHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHBpeGVsUmF0aW87XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcGl4ZWxSYXRpbyA9IHZhbHVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0d2lkdGg6IF93aWR0aCxcclxuXHRcdFx0aGVpZ2h0OiBfaGVpZ2h0XHJcblx0XHR9O1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xyXG5cclxuXHRcdF93aWR0aCA9IHdpZHRoO1xyXG5cdFx0X2hlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRfY2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xyXG5cdFx0X2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xyXG5cclxuXHRcdGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0X2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuXHRcdFx0X2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0X3ZpZXdwb3J0WCA9IHggKiBwaXhlbFJhdGlvO1xyXG5cdFx0X3ZpZXdwb3J0WSA9IHkgKiBwaXhlbFJhdGlvO1xyXG5cclxuXHRcdF92aWV3cG9ydFdpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xyXG5cdFx0X3ZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcclxuXHJcblx0XHRfZ2wudmlld3BvcnQoIF92aWV3cG9ydFgsIF92aWV3cG9ydFksIF92aWV3cG9ydFdpZHRoLCBfdmlld3BvcnRIZWlnaHQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggZGltZW5zaW9ucyApIHtcclxuXHJcblx0XHRkaW1lbnNpb25zLnggPSBfdmlld3BvcnRYIC8gcGl4ZWxSYXRpbztcclxuXHRcdGRpbWVuc2lvbnMueSA9IF92aWV3cG9ydFkgLyBwaXhlbFJhdGlvO1xyXG5cclxuXHRcdGRpbWVuc2lvbnMueiA9IF92aWV3cG9ydFdpZHRoIC8gcGl4ZWxSYXRpbztcclxuXHRcdGRpbWVuc2lvbnMudyA9IF92aWV3cG9ydEhlaWdodCAvIHBpeGVsUmF0aW87XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRfZ2wuc2Npc3NvcihcclxuXHRcdFx0eCAqIHBpeGVsUmF0aW8sXHJcblx0XHRcdHkgKiBwaXhlbFJhdGlvLFxyXG5cdFx0XHR3aWR0aCAqIHBpeGVsUmF0aW8sXHJcblx0XHRcdGhlaWdodCAqIHBpeGVsUmF0aW9cclxuXHRcdCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5hYmxlU2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGJvb2xlYW4gKSB7XHJcblxyXG5cdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIGJvb2xlYW4gKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQ2xlYXJpbmdcclxuXHJcblx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfY2xlYXJDb2xvcjtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0X2NsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xyXG5cclxuXHRcdF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcclxuXHJcblx0XHRnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX2NsZWFyQWxwaGE7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICggYWxwaGEgKSB7XHJcblxyXG5cdFx0X2NsZWFyQWxwaGEgPSBhbHBoYTtcclxuXHJcblx0XHRnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcclxuXHJcblx0XHR2YXIgYml0cyA9IDA7XHJcblxyXG5cdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkIHx8IGNvbG9yICkgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcclxuXHRcdGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XHJcblx0XHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xyXG5cclxuXHRcdF9nbC5jbGVhciggYml0cyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0X2dsLmNsZWFyKCBfZ2wuQ09MT1JfQlVGRkVSX0JJVCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0X2dsLmNsZWFyKCBfZ2wuREVQVEhfQlVGRkVSX0JJVCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRfZ2wuY2xlYXIoIF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFJlc2V0XHJcblxyXG5cdHRoaXMucmVzZXRHTFN0YXRlID0gcmVzZXRHTFN0YXRlO1xyXG5cclxuXHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gRXZlbnRzXHJcblxyXG5cdGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoIGV2ZW50ICkge1xyXG5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0cmVzZXRHTFN0YXRlKCk7XHJcblx0XHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xyXG5cclxuXHRcdHByb3BlcnRpZXMuY2xlYXIoKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XHJcblxyXG5cdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcclxuXHJcblx0XHRkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xyXG5cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblJlbmRlclRhcmdldERpc3Bvc2UoIGV2ZW50ICkge1xyXG5cclxuXHRcdHZhciByZW5kZXJUYXJnZXQgPSBldmVudC50YXJnZXQ7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG5cdFx0ZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoIGV2ZW50ICkge1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XHJcblxyXG5cdFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cclxuXHJcblx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcclxuXHJcblx0XHRcdC8vIGN1YmUgdGV4dHVyZVxyXG5cclxuXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gMkQgdGV4dHVyZVxyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlbW92ZSBhbGwgd2ViZ2wgcHJvcGVydGllc1xyXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIHRleHR1cmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoICEgcmVuZGVyVGFyZ2V0IHx8IHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcclxuXHRcdFx0XHRfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XHJcblx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtSW5mbyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLnByb2dyYW07XHJcblxyXG5cdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAoIHByb2dyYW1JbmZvICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0oIHByb2dyYW1JbmZvICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIEJ1ZmZlciByZW5kZXJpbmdcclxuXHJcblx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHR2YXIgYnVmZmVycyA9IHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgISBidWZmZXJzLm5vcm1hbCApIGJ1ZmZlcnMubm9ybWFsID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5ub3JtYWwgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyAmJiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNvdW50ICogMzsgaSA8IGw7IGkgKz0gOSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIG54ID0gKCBhcnJheVsgaSArIDAgXSArIGFycmF5WyBpICsgMyBdICsgYXJyYXlbIGkgKyA2IF0gKSAvIDM7XHJcblx0XHRcdFx0XHR2YXIgbnkgPSAoIGFycmF5WyBpICsgMSBdICsgYXJyYXlbIGkgKyA0IF0gKyBhcnJheVsgaSArIDcgXSApIC8gMztcclxuXHRcdFx0XHRcdHZhciBueiA9ICggYXJyYXlbIGkgKyAyIF0gKyBhcnJheVsgaSArIDUgXSArIGFycmF5WyBpICsgOCBdICkgLyAzO1xyXG5cclxuXHRcdFx0XHRcdGFycmF5WyBpICsgMCBdID0gbng7XHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDEgXSA9IG55O1xyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyAyIF0gPSBuejtcclxuXHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDMgXSA9IG54O1xyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA0IF0gPSBueTtcclxuXHRcdFx0XHRcdGFycmF5WyBpICsgNSBdID0gbno7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA2IF0gPSBueDtcclxuXHRcdFx0XHRcdGFycmF5WyBpICsgNyBdID0gbnk7XHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDggXSA9IG56O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Lm5vcm1hbEFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XHJcblxyXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5ub3JtYWwsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnV2ICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XHJcblxyXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLmNvbG9yICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XHJcblxyXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xyXG5cclxuXHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcclxuXHJcblx0XHRvYmplY3QuY291bnQgPSAwO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICkge1xyXG5cclxuXHRcdHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2U7XHJcblx0XHR2YXIgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgbWF0ZXJpYWwud2lyZWZyYW1lO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlQcm9ncmFtICE9PSBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSApIHtcclxuXHJcblx0XHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnlQcm9ncmFtO1xyXG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbW9ycGggdGFyZ2V0c1xyXG5cclxuXHRcdHZhciBtb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG5cclxuXHRcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWN0aXZlSW5mbHVlbmNlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcclxuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLnB1c2goIFsgaW5mbHVlbmNlLCBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFjdGl2ZUluZmx1ZW5jZXMuc29ydCggbnVtZXJpY2FsU29ydCApO1xyXG5cclxuXHRcdFx0aWYgKCBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA+IDggKSB7XHJcblxyXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID0gODtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBhY3RpdmVJbmZsdWVuY2VzWyBpIF07XHJcblx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzWyBpIF0gPSBpbmZsdWVuY2VbIDAgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmZsdWVuY2VbIDAgXSAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5kZXggPSBpbmZsdWVuY2VbIDEgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSAmJiBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb25bIGluZGV4IF0gKTtcclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5ub3JtYWwgKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsWyBpbmRleCBdICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpICk7XHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9PT0gdHJ1ZSApIGdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHVuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpO1xyXG5cclxuXHRcdFx0aWYgKCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWZ2KCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMsIG1vcnBoSW5mbHVlbmNlcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0aW5kZXggPSBvYmplY3RzLmdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJlbmRlcmVyO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlciA9IGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcclxuXHRcdFx0cmVuZGVyZXIuc2V0SW5kZXgoIGluZGV4ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJlbmRlcmVyID0gYnVmZmVyUmVuZGVyZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcclxuXHJcblx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggaW5kZXggKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBkYXRhU3RhcnQgPSAwO1xyXG5cdFx0dmFyIGRhdGFDb3VudCA9IEluZmluaXR5O1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRkYXRhQ291bnQgPSBpbmRleC5jb3VudFxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRkYXRhQ291bnQgPSBwb3NpdGlvbi5jb3VudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJhbmdlU3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQ7XHJcblx0XHR2YXIgcmFuZ2VDb3VudCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudDtcclxuXHJcblx0XHR2YXIgZ3JvdXBTdGFydCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuc3RhcnQgOiAwO1xyXG5cdFx0dmFyIGdyb3VwQ291bnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLmNvdW50IDogSW5maW5pdHk7XHJcblxyXG5cdFx0dmFyIGRyYXdTdGFydCA9IE1hdGgubWF4KCBkYXRhU3RhcnQsIHJhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKTtcclxuXHRcdHZhciBkcmF3RW5kID0gTWF0aC5taW4oIGRhdGFTdGFydCArIGRhdGFDb3VudCwgcmFuZ2VTdGFydCArIHJhbmdlQ291bnQsIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICkgLSAxO1xyXG5cclxuXHRcdHZhciBkcmF3Q291bnQgPSBNYXRoLm1heCggMCwgZHJhd0VuZCAtIGRyYXdTdGFydCArIDEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIHBpeGVsUmF0aW8gKTtcclxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0dmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcclxuXHJcblx0XHRcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxyXG5cclxuXHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBsaW5lV2lkdGggKiBwaXhlbFJhdGlvICk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVTZWdtZW50cyApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9TVFJJUCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcclxuXHJcblx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5QT0lOVFMgKTtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XHJcblxyXG5cdFx0dmFyIGV4dGVuc2lvbjtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCApIHN0YXJ0SW5kZXggPSAwO1xyXG5cclxuXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xyXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IG9iamVjdHMuZ2V0QXR0cmlidXRlQnVmZmVyKCBnZW9tZXRyeUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcclxuXHRcdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xyXG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSwgZXh0ZW5zaW9uICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgc3RyaWRlICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiA0ICk7IC8vIDQgYnl0ZXMgcGVyIEZsb2F0MzJcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgNDpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gU29ydGluZ1xyXG5cclxuXHRmdW5jdGlvbiBudW1lcmljYWxTb3J0ICggYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gYlsgMCBdIC0gYVsgMCBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcclxuXHJcblx0XHRpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcclxuXHJcblx0XHRcdHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5tYXRlcmlhbC5pZCAtIGIubWF0ZXJpYWwuaWQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS56IC0gYi56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XHJcblxyXG5cdFx0aWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcclxuXHJcblx0XHR9IGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYi56IC0gYS56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIFJlbmRlcmluZ1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xyXG5cclxuXHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmb2cgPSBzY2VuZS5mb2c7XHJcblxyXG5cdFx0Ly8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxyXG5cclxuXHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XHJcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XHJcblx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XHJcblx0XHRfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXHJcblxyXG5cdFx0aWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRsaWdodHMubGVuZ3RoID0gMDtcclxuXHJcblx0XHRvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG5cdFx0dHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG5cclxuXHRcdHNwcml0ZXMubGVuZ3RoID0gMDtcclxuXHRcdGxlbnNGbGFyZXMubGVuZ3RoID0gMDtcclxuXHJcblx0XHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cdFx0b3BhcXVlT2JqZWN0cy5sZW5ndGggPSBvcGFxdWVPYmplY3RzTGFzdEluZGV4ICsgMTtcclxuXHRcdHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPSB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggKyAxO1xyXG5cclxuXHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRvcGFxdWVPYmplY3RzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XHJcblx0XHRcdHRyYW5zcGFyZW50T2JqZWN0cy5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRzaGFkb3dNYXAucmVuZGVyKCBzY2VuZSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0X2luZm9SZW5kZXIuY2FsbHMgPSAwO1xyXG5cdFx0X2luZm9SZW5kZXIudmVydGljZXMgPSAwO1xyXG5cdFx0X2luZm9SZW5kZXIuZmFjZXMgPSAwO1xyXG5cdFx0X2luZm9SZW5kZXIucG9pbnRzID0gMDtcclxuXHJcblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF1dG9DbGVhciB8fCBmb3JjZUNsZWFyICkge1xyXG5cclxuXHRcdFx0dGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dmFyIG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xyXG5cclxuXHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gb3BhcXVlIHBhc3MgKGZyb250LXRvLWJhY2sgb3JkZXIpXHJcblxyXG5cdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XHJcblxyXG5cdFx0XHQvLyB0cmFuc3BhcmVudCBwYXNzIChiYWNrLXRvLWZyb250IG9yZGVyKVxyXG5cclxuXHRcdFx0cmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxyXG5cclxuXHRcdHNwcml0ZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHRcdGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50V2lkdGgsIF9jdXJyZW50SGVpZ2h0ICk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XHJcblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApO1xyXG5cdFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkge1xyXG5cclxuXHRcdFx0XHQgdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRW5zdXJlIGRlcHRoIGJ1ZmZlciB3cml0aW5nIGlzIGVuYWJsZWQgc28gaXQgY2FuIGJlIGNsZWFyZWQgb24gbmV4dCByZW5kZXJcclxuXHJcblx0XHRzdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcclxuXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIHRydWUgKTtcclxuXHRcdHN0YXRlLnNldENvbG9yV3JpdGUoIHRydWUgKTtcclxuXHJcblx0XHQvLyBfZ2wuZmluaXNoKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgeiwgZ3JvdXAgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5LCBpbmRleDtcclxuXHJcblx0XHQvLyBhbGxvY2F0ZSB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aGUgYXBwcm9wcmlhdGUgYXJyYXlcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xyXG5cclxuXHRcdFx0YXJyYXkgPSB0cmFuc3BhcmVudE9iamVjdHM7XHJcblx0XHRcdGluZGV4ID0gKysgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRhcnJheSA9IG9wYXF1ZU9iamVjdHM7XHJcblx0XHRcdGluZGV4ID0gKysgb3BhcXVlT2JqZWN0c0xhc3RJbmRleDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVjeWNsZSBleGlzdGluZyByZW5kZXIgaXRlbSBvciBncm93IHRoZSBhcnJheVxyXG5cclxuXHRcdHZhciByZW5kZXJJdGVtID0gYXJyYXlbIGluZGV4IF07XHJcblxyXG5cdFx0aWYgKCByZW5kZXJJdGVtICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xyXG5cdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcclxuXHRcdFx0cmVuZGVySXRlbS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG5cdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblx0XHRcdHJlbmRlckl0ZW0ueiA9IF92ZWN0b3IzLno7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVySXRlbSA9IHtcclxuXHRcdFx0XHRpZDogb2JqZWN0LmlkLFxyXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxyXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeSxcclxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXHJcblx0XHRcdFx0ejogX3ZlY3RvcjMueixcclxuXHRcdFx0XHRncm91cDogZ3JvdXBcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vIGFzc2VydCggaW5kZXggPT09IGFycmF5Lmxlbmd0aCApO1xyXG5cdFx0XHRhcnJheS5wdXNoKCByZW5kZXJJdGVtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdGlmICggKCBvYmplY3QuY2hhbm5lbHMubWFzayAmIGNhbWVyYS5jaGFubmVscy5tYXNrICkgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRsaWdodHMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XHJcblxyXG5cdFx0XHRcdHNwcml0ZXMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MZW5zRmxhcmUgKSB7XHJcblxyXG5cdFx0XHRcdGxlbnNGbGFyZXMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBudWxsLCBvYmplY3QubWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBfdmVjdG9yMy56LCBncm91cCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHJlbmRlckl0ZW0gPSByZW5kZXJMaXN0WyBpIF07XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xyXG5cdFx0XHR2YXIgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xyXG5cclxuXHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0b2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0dmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR2YXIgcGFyYW1ldGVycyA9IHByb2dyYW1DYWNoZS5nZXRQYXJhbWV0ZXJzKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xyXG5cdFx0dmFyIGNvZGUgPSBwcm9ncmFtQ2FjaGUuZ2V0UHJvZ3JhbUNvZGUoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbTtcclxuXHRcdHZhciBwcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIG5ldyBtYXRlcmlhbFxyXG5cdFx0XHRtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xyXG5cclxuXHRcdFx0Ly8gY2hhbmdlZCBnbHNsIG9yIHBhcmFtZXRlcnNcclxuXHRcdFx0cmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQvLyBzYW1lIGdsc2wgYW5kIHVuaWZvcm0gbGlzdFxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIG9ubHkgcmVidWlsZCB1bmlmb3JtIGxpc3RcclxuXHRcdFx0cHJvZ3JhbUNoYW5nZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHByb2dyYW1DaGFuZ2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIHBhcmFtZXRlcnMuc2hhZGVySUQgXTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIgPSB7XHJcblx0XHRcdFx0XHRuYW1lOiBtYXRlcmlhbC50eXBlLFxyXG5cdFx0XHRcdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApLFxyXG5cdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxyXG5cdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcclxuXHRcdFx0XHRcdG5hbWU6IG1hdGVyaWFsLnR5cGUsXHJcblx0XHRcdFx0XHR1bmlmb3JtczogbWF0ZXJpYWwudW5pZm9ybXMsXHJcblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcclxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBtYXRlcmlhbC5mcmFnbWVudFNoYWRlclxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5fX3dlYmdsU2hhZGVyID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXI7XHJcblxyXG5cdFx0XHRwcm9ncmFtID0gcHJvZ3JhbUNhY2hlLmFjcXVpcmVQcm9ncmFtKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApO1xyXG5cclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cdFx0XHRtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaFRhcmdldHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIGkgXSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgaSBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSBbXTtcclxuXHJcblx0XHR2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLmdldFVuaWZvcm1zKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIHUgaW4gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9jYXRpb24gPSB1bmlmb3JtTG9jYXRpb25zWyB1IF07XHJcblxyXG5cdFx0XHRpZiAoIGxvY2F0aW9uICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LnB1c2goIFsgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXNbIHUgXSwgbG9jYXRpb24gXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0c2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5zZXREZXB0aEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xyXG5cdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcclxuXHRcdHN0YXRlLnNldENvbG9yV3JpdGUoIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcclxuXHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgPyBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKSA6IHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdHN0YXRlLnNldEZsaXBTaWRlZCggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdF91c2VkVGV4dHVyZVVuaXRzID0gMDtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSB8fCAhIG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtICkge1xyXG5cclxuXHRcdFx0aW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xyXG5cdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcclxuXHRcdHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcclxuXHRcdHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSxcclxuXHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcclxuXHRcdFx0bV91bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbS5pZCAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xyXG5cclxuXHRcdFx0X2dsLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApO1xyXG5cdFx0XHRfY3VycmVudFByb2dyYW0gPSBwcm9ncmFtLmlkO1xyXG5cclxuXHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xyXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xyXG5cclxuXHRcdFx0aWYgKCBfY3VycmVudE1hdGVyaWFsSWQgPT09IC0gMSApIHJlZnJlc2hMaWdodHMgPSB0cnVlO1xyXG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcclxuXHJcblx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggcF91bmlmb3Jtcy5sb2dEZXB0aEJ1ZkZDLCAyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0aWYgKCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkgX2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0XHQvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXHJcblx0XHRcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5lbnZNYXAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsLnNraW5uaW5nICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMudmlld01hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXHJcblx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcclxuXHRcdC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmJpbmRNYXRyaXggJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXgsIGZhbHNlLCBvYmplY3QuYmluZE1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UgJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZS5lbGVtZW50cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVXaWR0aCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVXaWR0aCwgb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlV2lkdGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0LCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVIZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMsIGZhbHNlLCBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCByZWZyZXNoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xyXG5cclxuXHRcdFx0aWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNGb2coIG1fdW5pZm9ybXMsIGZvZyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5saWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggX2xpZ2h0c05lZWRVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XHJcblx0XHRcdFx0XHRzZXR1cExpZ2h0cyggbGlnaHRzLCBjYW1lcmEgKTtcclxuXHRcdFx0XHRcdF9saWdodHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCByZWZyZXNoTGlnaHRzICkge1xyXG5cclxuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpZ2h0cyggbV91bmlmb3JtcywgX2xpZ2h0cyApO1xyXG5cdFx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgZmFsc2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BhcnRpY2xlKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRtX3VuaWZvcm1zLm1OZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XHJcblx0XHRcdFx0bV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcclxuXHRcdFx0XHRtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmICEgbWF0ZXJpYWwuX3NoYWRvd1Bhc3MgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1NoYWRvdyggbV91bmlmb3JtcywgbGlnaHRzLCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGxvYWQgY29tbW9uIHVuaWZvcm1zXHJcblxyXG5cdFx0XHRsb2FkVW5pZm9ybXNHZW5lcmljKCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYW9NYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcclxuXHRcdC8vIDEuIGNvbG9yIG1hcFxyXG5cdFx0Ly8gMi4gc3BlY3VsYXIgbWFwXHJcblx0XHQvLyAzLiBub3JtYWwgbWFwXHJcblx0XHQvLyA0LiBidW1wIG1hcFxyXG5cdFx0Ly8gNS4gYWxwaGEgbWFwXHJcblx0XHQvLyA2LiBlbWlzc2l2ZSBtYXBcclxuXHJcblx0XHR2YXIgdXZTY2FsZU1hcDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHV2U2NhbGVNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCApIHV2U2NhbGVNYXAgPSB1dlNjYWxlTWFwLnRleHR1cmU7XHJcblx0XHRcdHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcclxuXHRcdFx0dmFyIHJlcGVhdCA9IHV2U2NhbGVNYXAucmVwZWF0O1xyXG5cclxuXHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwO1xyXG5cdFx0dW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggbWF0ZXJpYWwuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkgPyAxIDogLSAxO1xyXG5cclxuXHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcclxuXHRcdHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcclxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2ggKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcclxuXHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcclxuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGFydGljbGUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMucHNDb2xvci52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcclxuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gX2NhbnZhcy5oZWlnaHQgLyAyLjA7IC8vIFRPRE86IENhY2hlIHRoaXMuXHJcblxyXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dmFyIG9mZnNldCA9IG1hdGVyaWFsLm1hcC5vZmZzZXQ7XHJcblx0XHRcdHZhciByZXBlYXQgPSBtYXRlcmlhbC5tYXAucmVwZWF0O1xyXG5cclxuXHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRm9nICggdW5pZm9ybXMsIGZvZyApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcclxuXHJcblx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcclxuXHRcdFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xyXG5cdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgoIG1hdGVyaWFsLnNoaW5pbmVzcywgMWUtNCApOyAvLyB0byBwcmV2ZW50IHBvdyggMC4wLCAwLjAgKVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubGlnaHRNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XHJcblx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XHJcblx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGlnaHRzICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5hbWJpZW50O1xyXG5cclxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnM7XHJcblx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucztcclxuXHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xyXG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnBvaW50LnBvc2l0aW9ucztcclxuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kaXN0YW5jZXM7XHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXkudmFsdWUgPSBsaWdodHMucG9pbnQuZGVjYXlzO1xyXG5cclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnNwb3QuY29sb3JzO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0UG9zaXRpb24udmFsdWUgPSBsaWdodHMuc3BvdC5wb3NpdGlvbnM7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpc3RhbmNlcztcclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpcmVjdGlvbnM7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy52YWx1ZSA9IGxpZ2h0cy5zcG90LmFuZ2xlc0NvcztcclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50LnZhbHVlID0gbGlnaHRzLnNwb3QuZXhwb25lbnRzO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGVjYXkudmFsdWUgPSBsaWdodHMuc3BvdC5kZWNheXM7XHJcblxyXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IudmFsdWUgPSBsaWdodHMuaGVtaS5za3lDb2xvcnM7XHJcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycztcclxuXHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5oZW1pLnBvc2l0aW9ucztcclxuXHJcblx0fVxyXG5cclxuXHQvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXHJcblxyXG5cdGZ1bmN0aW9uIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlICggdW5pZm9ybXMsIHZhbHVlICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG5cdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0UG9zaXRpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTaGFkb3cgKCB1bmlmb3JtcywgbGlnaHRzLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCB1bmlmb3Jtcy5zaGFkb3dNYXRyaXggKSB7XHJcblxyXG5cdFx0XHR2YXIgaiA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbGlnaHQgPSBsaWdodHNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0IHx8IGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8IGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxyXG5cdFx0XHRcdFx0XHRcdC8vIGVxdWFsIHRvIGludmVyc2Ugb2YgdGhlIGxpZ2h0J3MgcG9zaXRpb25cclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCk7XHJcblx0XHRcdFx0XHRcdFx0c2hhZG93Lm1hdHJpeC5pZGVudGl0eSgpLnNldFBvc2l0aW9uKCBfdmVjdG9yMyApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBmb3IgcG9pbnQgbGlnaHRzIHdlIHNldCB0aGUgc2lnbiBvZiB0aGUgc2hhZG93RGFya25lc3MgdW5pZm9ybSB0byBiZSBuZWdhdGl2ZVxyXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBqIF0gPSAtIHNoYWRvdy5kYXJrbmVzcztcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBqIF0gPSBzaGFkb3cuZGFya25lc3M7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXRyaXgudmFsdWVbIGogXSA9IHNoYWRvdy5tYXRyaXg7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcC52YWx1ZVsgaiBdID0gc2hhZG93Lm1hcDtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZS52YWx1ZVsgaiBdID0gc2hhZG93Lm1hcFNpemU7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMudmFsdWVbIGogXSA9IHNoYWRvdy5iaWFzO1xyXG5cclxuXHRcdFx0XHRcdFx0aiArKztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gVW5pZm9ybXMgKGxvYWQgdG8gR1BVKVxyXG5cclxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNNYXRyaWNlcyAoIHVuaWZvcm1zLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIG9iamVjdC5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHRpZiAoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCApIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtTWF0cml4M2Z2KCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXgsIGZhbHNlLCBvYmplY3Qubm9ybWFsTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFRleHR1cmVVbml0KCkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlVW5pdCA9IF91c2VkVGV4dHVyZVVuaXRzO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZVVuaXQgPj0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF91c2VkVGV4dHVyZVVuaXRzICs9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmVVbml0O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc0dlbmVyaWMgKCB1bmlmb3JtcyApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSwgdGV4dHVyZVVuaXQ7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1sgaiBdWyAwIF07XHJcblxyXG5cdFx0XHQvLyBuZWVkc1VwZGF0ZSBwcm9wZXJ0eSBpcyBub3QgYWRkZWQgdG8gYWxsIHVuaWZvcm1zLlxyXG5cdFx0XHRpZiAoIHVuaWZvcm0ubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgY29udGludWU7XHJcblxyXG5cdFx0XHR2YXIgdHlwZSA9IHVuaWZvcm0udHlwZTtcclxuXHRcdFx0dmFyIHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcclxuXHRcdFx0dmFyIGxvY2F0aW9uID0gdW5pZm9ybXNbIGogXVsgMSBdO1xyXG5cclxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnMWknOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnMWYnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnMmYnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0gKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICczZic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzRmJzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdLCB2YWx1ZVsgMyBdICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnMWl2JzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICczaXYnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzFmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnMmZ2JzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICczZnYnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzRmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnTWF0cml4M2Z2JzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnTWF0cml4NGZ2JzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0Y2FzZSAnaSc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIGludGVnZXJcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdmJzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgZmxvYXRcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2Mic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLlZlY3RvcjJcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3YzJzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yM1xyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnogKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAndjQnOlxyXG5cclxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5WZWN0b3I0XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdjJzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuQ29sb3JcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS5yLCB2YWx1ZS5nLCB2YWx1ZS5iICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2l2MSc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2l2JzpcclxuXHJcblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2Z2MSc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBmbG9hdHMgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdmdic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBmbG9hdHMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAndjJ2JzpcclxuXHJcblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IyXHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAyICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaTIgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrLCBpMiArPSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkyICsgMCBdID0gdmFsdWVbIGkgXS54O1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTIgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAndjN2JzpcclxuXHJcblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAzICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaTMgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrLCBpMyArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkzICsgMCBdID0gdmFsdWVbIGkgXS54O1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTMgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMyArIDIgXSA9IHZhbHVlWyBpIF0uejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2NHYnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjRcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDQgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpNCA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGk0ICs9IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTQgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGk0ICsgMiBdID0gdmFsdWVbIGkgXS56O1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTQgKyAzIF0gPSB2YWx1ZVsgaSBdLnc7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbTMnOlxyXG5cclxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5NYXRyaXgzXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtM3YnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDNcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiA5ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ200JzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuTWF0cml4NFxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbTR2JzpcclxuXHJcblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXg0XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHZhbHVlLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDE2ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3QnOlxyXG5cclxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5UZXh0dXJlICgyZCBvciBjdWJlKVxyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgdGV4dHVyZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlIHx8XHJcblx0XHRcdFx0XHRcdCAoIEFycmF5LmlzQXJyYXkoIHRleHR1cmUuaW1hZ2UgKSAmJiB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gQ29tcHJlc3NlZFRleHR1cmUgY2FuIGhhdmUgQXJyYXkgaW4gaW1hZ2UgOi9cclxuXHJcblx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLnRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd0dic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpIF0gPSBnZXRUZXh0dXJlVW5pdCgpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gdW5pZm9ybS52YWx1ZVsgaSBdO1xyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlVW5pdCA9IHVuaWZvcm0uX2FycmF5WyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICEgdGV4dHVyZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVRleHR1cmUgfHxcclxuXHRcdFx0XHRcdFx0XHQgKCB0ZXh0dXJlLmltYWdlIGluc3RhbmNlb2YgQXJyYXkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gQ29tcHJlc3NlZFRleHR1cmUgY2FuIGhhdmUgQXJyYXkgaW4gaW1hZ2UgOi9cclxuXHJcblx0XHRcdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5rbm93biB1bmlmb3JtIHR5cGU6ICcgKyB0eXBlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldENvbG9yTGluZWFyKCBhcnJheSwgb2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICkge1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgKyAwIF0gPSBjb2xvci5yICogaW50ZW5zaXR5O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYiAqIGludGVuc2l0eTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXR1cExpZ2h0cyAoIGxpZ2h0cywgY2FtZXJhICkge1xyXG5cclxuXHRcdHZhciBsLCBsbCwgbGlnaHQsXHJcblx0XHRyID0gMCwgZyA9IDAsIGIgPSAwLFxyXG5cdFx0Y29sb3IsIHNreUNvbG9yLCBncm91bmRDb2xvcixcclxuXHRcdGludGVuc2l0eSxcclxuXHRcdGRpc3RhbmNlLFxyXG5cclxuXHRcdHpsaWdodHMgPSBfbGlnaHRzLFxyXG5cclxuXHRcdHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLFxyXG5cclxuXHRcdGRpckNvbG9ycyA9IHpsaWdodHMuZGlyZWN0aW9uYWwuY29sb3JzLFxyXG5cdFx0ZGlyUG9zaXRpb25zID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnMsXHJcblxyXG5cdFx0cG9pbnRDb2xvcnMgPSB6bGlnaHRzLnBvaW50LmNvbG9ycyxcclxuXHRcdHBvaW50UG9zaXRpb25zID0gemxpZ2h0cy5wb2ludC5wb3NpdGlvbnMsXHJcblx0XHRwb2ludERpc3RhbmNlcyA9IHpsaWdodHMucG9pbnQuZGlzdGFuY2VzLFxyXG5cdFx0cG9pbnREZWNheXMgPSB6bGlnaHRzLnBvaW50LmRlY2F5cyxcclxuXHJcblx0XHRzcG90Q29sb3JzID0gemxpZ2h0cy5zcG90LmNvbG9ycyxcclxuXHRcdHNwb3RQb3NpdGlvbnMgPSB6bGlnaHRzLnNwb3QucG9zaXRpb25zLFxyXG5cdFx0c3BvdERpc3RhbmNlcyA9IHpsaWdodHMuc3BvdC5kaXN0YW5jZXMsXHJcblx0XHRzcG90RGlyZWN0aW9ucyA9IHpsaWdodHMuc3BvdC5kaXJlY3Rpb25zLFxyXG5cdFx0c3BvdEFuZ2xlc0NvcyA9IHpsaWdodHMuc3BvdC5hbmdsZXNDb3MsXHJcblx0XHRzcG90RXhwb25lbnRzID0gemxpZ2h0cy5zcG90LmV4cG9uZW50cyxcclxuXHRcdHNwb3REZWNheXMgPSB6bGlnaHRzLnNwb3QuZGVjYXlzLFxyXG5cclxuXHRcdGhlbWlTa3lDb2xvcnMgPSB6bGlnaHRzLmhlbWkuc2t5Q29sb3JzLFxyXG5cdFx0aGVtaUdyb3VuZENvbG9ycyA9IHpsaWdodHMuaGVtaS5ncm91bmRDb2xvcnMsXHJcblx0XHRoZW1pUG9zaXRpb25zID0gemxpZ2h0cy5oZW1pLnBvc2l0aW9ucyxcclxuXHJcblx0XHRkaXJMZW5ndGggPSAwLFxyXG5cdFx0cG9pbnRMZW5ndGggPSAwLFxyXG5cdFx0c3BvdExlbmd0aCA9IDAsXHJcblx0XHRoZW1pTGVuZ3RoID0gMCxcclxuXHJcblx0XHRkaXJDb3VudCA9IDAsXHJcblx0XHRwb2ludENvdW50ID0gMCxcclxuXHRcdHNwb3RDb3VudCA9IDAsXHJcblx0XHRoZW1pQ291bnQgPSAwLFxyXG5cclxuXHRcdGRpck9mZnNldCA9IDAsXHJcblx0XHRwb2ludE9mZnNldCA9IDAsXHJcblx0XHRzcG90T2Zmc2V0ID0gMCxcclxuXHRcdGhlbWlPZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcblx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG5cdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG5cdFx0XHRpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XHJcblx0XHRcdGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRyICs9IGNvbG9yLnI7XHJcblx0XHRcdFx0ZyArPSBjb2xvci5nO1xyXG5cdFx0XHRcdGIgKz0gY29sb3IuYjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0ZGlyQ291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRkaXJPZmZzZXQgPSBkaXJMZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcclxuXHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcclxuXHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcclxuXHJcblx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIGRpckNvbG9ycywgZGlyT2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdGRpckxlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRwb2ludENvdW50ICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdHBvaW50T2Zmc2V0ID0gcG9pbnRMZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0XHRzZXRDb2xvckxpbmVhciggcG9pbnRDb2xvcnMsIHBvaW50T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfdmVjdG9yMy5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMCBdID0gX3ZlY3RvcjMueDtcclxuXHRcdFx0XHRwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xyXG5cdFx0XHRcdHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdC8vIGRpc3RhbmNlIGlzIDAgaWYgZGVjYXkgaXMgMCwgYmVjYXVzZSB0aGVyZSBpcyBubyBhdHRlbnVhdGlvbiBhdCBhbGwuXHJcblx0XHRcdFx0cG9pbnREaXN0YW5jZXNbIHBvaW50TGVuZ3RoIF0gPSBkaXN0YW5jZTtcclxuXHRcdFx0XHRwb2ludERlY2F5c1sgcG9pbnRMZW5ndGggXSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xyXG5cclxuXHRcdFx0XHRwb2ludExlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdHNwb3RDb3VudCArPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRzcG90T2Zmc2V0ID0gc3BvdExlbmd0aCAqIDM7XHJcblxyXG5cdFx0XHRcdHNldENvbG9yTGluZWFyKCBzcG90Q29sb3JzLCBzcG90T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdF92ZWN0b3IzLmNvcHkoIF9kaXJlY3Rpb24gKS5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDAgXSA9IF92ZWN0b3IzLng7XHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdHNwb3REaXN0YW5jZXNbIHNwb3RMZW5ndGggXSA9IGRpc3RhbmNlO1xyXG5cclxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xyXG5cdFx0XHRcdF9kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xyXG5cdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xyXG5cdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xyXG5cclxuXHRcdFx0XHRzcG90QW5nbGVzQ29zWyBzcG90TGVuZ3RoIF0gPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcclxuXHRcdFx0XHRzcG90RXhwb25lbnRzWyBzcG90TGVuZ3RoIF0gPSBsaWdodC5leHBvbmVudDtcclxuXHRcdFx0XHRzcG90RGVjYXlzWyBzcG90TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcblx0XHRcdFx0c3BvdExlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdGhlbWlDb3VudCArPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRoZW1pT2Zmc2V0ID0gaGVtaUxlbmd0aCAqIDM7XHJcblxyXG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XHJcblx0XHRcdFx0aGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcclxuXHRcdFx0XHRoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xyXG5cclxuXHRcdFx0XHRza3lDb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG5cdFx0XHRcdGdyb3VuZENvbG9yID0gbGlnaHQuZ3JvdW5kQ29sb3I7XHJcblxyXG5cdFx0XHRcdHNldENvbG9yTGluZWFyKCBoZW1pU2t5Q29sb3JzLCBoZW1pT2Zmc2V0LCBza3lDb2xvciwgaW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIGhlbWlHcm91bmRDb2xvcnMsIGhlbWlPZmZzZXQsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0aGVtaUxlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBudWxsIGV2ZW50dWFsIHJlbWFpbnMgZnJvbSByZW1vdmVkIGxpZ2h0c1xyXG5cdFx0Ly8gKHRoaXMgaXMgdG8gYXZvaWQgaWYgaW4gc2hhZGVyKVxyXG5cclxuXHRcdGZvciAoIGwgPSBkaXJMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBkaXJDb2xvcnMubGVuZ3RoLCBkaXJDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgZGlyQ29sb3JzWyBsIF0gPSAwLjA7XHJcblx0XHRmb3IgKCBsID0gcG9pbnRMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBwb2ludENvbG9ycy5sZW5ndGgsIHBvaW50Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHBvaW50Q29sb3JzWyBsIF0gPSAwLjA7XHJcblx0XHRmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcclxuXHRcdGZvciAoIGwgPSBoZW1pTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggaGVtaVNreUNvbG9ycy5sZW5ndGgsIGhlbWlDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgaGVtaVNreUNvbG9yc1sgbCBdID0gMC4wO1xyXG5cdFx0Zm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pR3JvdW5kQ29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBoZW1pR3JvdW5kQ29sb3JzWyBsIF0gPSAwLjA7XHJcblxyXG5cdFx0emxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJMZW5ndGg7XHJcblx0XHR6bGlnaHRzLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xyXG5cdFx0emxpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XHJcblx0XHR6bGlnaHRzLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcclxuXHJcblx0XHR6bGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XHJcblx0XHR6bGlnaHRzLmFtYmllbnRbIDEgXSA9IGc7XHJcblx0XHR6bGlnaHRzLmFtYmllbnRbIDIgXSA9IGI7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gR0wgc3RhdGUgc2V0dGluZ1xyXG5cclxuXHR0aGlzLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24gKCBjdWxsRmFjZSwgZnJvbnRGYWNlRGlyZWN0aW9uICkge1xyXG5cclxuXHRcdGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlTm9uZSApIHtcclxuXHJcblx0XHRcdHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBmcm9udEZhY2VEaXJlY3Rpb24gPT09IFRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlQmFjayApIHtcclxuXHJcblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVF9BTkRfQkFDSyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBUZXh0dXJlc1xyXG5cclxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyAoIHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHR2YXIgZXh0ZW5zaW9uO1xyXG5cclxuXHRcdGlmICggaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFMgKSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS53cmFwUyAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicsIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJywgdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiApIHtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5GbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XHJcblx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyZiggdGV4dHVyZVR5cGUsIGV4dGVuc2lvbi5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oIHRleHR1cmUuYW5pc290cm9weSwgX3RoaXMuZ2V0TWF4QW5pc290cm9weSgpICkgKTtcclxuXHRcdFx0XHRwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcclxuXHJcblx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcclxuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XHJcblx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xyXG5cclxuXHRcdHRleHR1cmUuaW1hZ2UgPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkgJiYgaXNQb3dlck9mVHdvKCB0ZXh0dXJlLmltYWdlICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZS5pbWFnZSA9IG1ha2VQb3dlck9mVHdvKCB0ZXh0dXJlLmltYWdlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2UsXHJcblx0XHRpc0ltYWdlUG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcclxuXHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXHJcblx0XHRnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XHJcblxyXG5cdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xyXG5cclxuXHRcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxyXG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcclxuXHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXHJcblxyXG5cdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpXCIgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcclxuXHJcblx0XHRcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXHJcblx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xyXG5cdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcclxuXHJcblx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuaW1hZ2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XHJcblxyXG5cdFx0XHRpZiAoIGltYWdlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcsIHRleHR1cmUgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGltYWdlLmNvbXBsZXRlID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScsIHRleHR1cmUgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNsYW1wVG9NYXhTaXplICggaW1hZ2UsIG1heFNpemUgKSB7XHJcblxyXG5cdFx0aWYgKCBpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSApIHtcclxuXHJcblx0XHRcdC8vIFdhcm5pbmc6IFNjYWxpbmcgdGhyb3VnaCB0aGUgY2FudmFzIHdpbGwgb25seSB3b3JrIHdpdGggaW1hZ2VzIHRoYXQgdXNlXHJcblx0XHRcdC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXHJcblxyXG5cdFx0XHR2YXIgc2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdFx0XHRjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIHNjYWxlICk7XHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBzY2FsZSApO1xyXG5cclxuXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgdG9vIGJpZyAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIGNhbnZhcy53aWR0aCArICd4JyArIGNhbnZhcy5oZWlnaHQsIGltYWdlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FudmFzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW1hZ2U7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaXNQb3dlck9mVHdvKCBpbWFnZSApIHtcclxuXHJcblx0XHRyZXR1cm4gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28oIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLndyYXBTICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gdHJ1ZTtcclxuXHRcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHJldHVybiB0cnVlO1xyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBtYWtlUG93ZXJPZlR3byggaW1hZ2UgKSB7XHJcblxyXG5cdFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHtcclxuXHJcblx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdFx0XHRjYW52YXMud2lkdGggPSBUSFJFRS5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApO1xyXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gVEhSRUUuTWF0aC5uZWFyZXN0UG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyBub3QgcG93ZXIgb2YgdHdvICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcclxuXHJcblx0XHRcdHJldHVybiBjYW52YXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZSAoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0XHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcblx0XHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xyXG5cclxuXHRcdFx0XHR2YXIgaXNDb21wcmVzc2VkID0gdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xyXG5cdFx0XHRcdHZhciBpc0RhdGFUZXh0dXJlID0gdGV4dHVyZS5pbWFnZVsgMCBdIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmU7XHJcblxyXG5cdFx0XHRcdHZhciBjdWJlSW1hZ2UgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIF90aGlzLmF1dG9TY2FsZUN1YmVtYXBzICYmICEgaXNDb21wcmVzc2VkICYmICEgaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGN1YmVJbWFnZVsgaSBdID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2VbIGkgXSwgY2FwYWJpbGl0aWVzLm1heEN1YmVtYXBTaXplICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGN1YmVJbWFnZVsgaSBdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbIGkgXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGltYWdlID0gY3ViZUltYWdlWyAwIF0sXHJcblx0XHRcdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXHJcblx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcclxuXHRcdFx0XHRnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XHJcblxyXG5cdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgaXNDb21wcmVzc2VkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpc0RhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGN1YmVJbWFnZVsgaSBdLndpZHRoLCBjdWJlSW1hZ2VbIGkgXS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbWlwbWFwcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldEN1YmVUZXh0dXJlKClcIiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmVEeW5hbWljICggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBSZW5kZXIgdGFyZ2V0c1xyXG5cclxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyICggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZVRhcmdldCApIHtcclxuXHJcblx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSwgMCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHQvKiBGb3Igc29tZSByZWFzb24gdGhpcyBpcyBub3Qgd29ya2luZy4gRGVmYXVsdGluZyB0byBSR0JBNC5cclxuXHRcdH0gZWxzZSBpZiAoICEgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5TVEVOQ0lMX0lOREVYOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHRcdCovXHJcblxyXG5cdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCAmJiBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPSB0cnVlO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcblx0XHRcdC8vIFNldHVwIHRleHR1cmUsIGNyZWF0ZSByZW5kZXIgYW5kIGZyYW1lIGJ1ZmZlcnNcclxuXHJcblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApLFxyXG5cdFx0XHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCApLFxyXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICk7XHJcblxyXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcclxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xyXG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xyXG5cclxuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFJlbGVhc2UgZXZlcnl0aGluZ1xyXG5cclxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xyXG5cdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcclxuXHRcdFx0aGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcclxuXHJcblx0XHRcdHZ4ID0gMDtcclxuXHRcdFx0dnkgPSAwO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmcmFtZWJ1ZmZlciA9IG51bGw7XHJcblxyXG5cdFx0XHR3aWR0aCA9IF92aWV3cG9ydFdpZHRoO1xyXG5cdFx0XHRoZWlnaHQgPSBfdmlld3BvcnRIZWlnaHQ7XHJcblxyXG5cdFx0XHR2eCA9IF92aWV3cG9ydFg7XHJcblx0XHRcdHZ5ID0gX3ZpZXdwb3J0WTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcclxuXHRcdFx0X2dsLnZpZXdwb3J0KCB2eCwgdnksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHRcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2N1cnJlbnRXaWR0aCA9IHdpZHRoO1xyXG5cdFx0X2N1cnJlbnRIZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIgKSB7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdGlmICggZnJhbWVidWZmZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdG9yZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHRyZXN0b3JlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRyeSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXRcclxuXHRcdFx0XHRcdCYmIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS50eXBlICE9PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlXHJcblx0XHRcdFx0XHQmJiBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUgKVxyXG5cdFx0XHRcdFx0JiYgISAoIHRleHR1cmUudHlwZSA9PT0gVEhSRUUuRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyApIClcclxuXHRcdFx0XHRcdCYmICEgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnICkgKSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLicgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIF9nbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKCBfZ2wuRlJBTUVCVUZGRVIgKSA9PT0gX2dsLkZSQU1FQlVGRkVSX0NPTVBMRVRFICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApLCBidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBmaW5hbGx5IHtcclxuXHJcblx0XHRcdFx0aWYgKCByZXN0b3JlICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2N1cnJlbnRGcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcclxuXHRcdHZhciB0ZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICkuX193ZWJnbFRleHR1cmU7XHJcblxyXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgdGV4dHVyZSApO1xyXG5cdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCB0YXJnZXQgKTtcclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCB0YXJnZXQsIG51bGwgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xyXG5cclxuXHRmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayAoIGYgKSB7XHJcblxyXG5cdFx0aWYgKCBmID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gX2dsLk5FQVJFU1Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfZ2wuTElORUFSO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIE1hcCB0aHJlZS5qcyBjb25zdGFudHMgdG8gV2ViR0wgY29uc3RhbnRzXHJcblxyXG5cdGZ1bmN0aW9uIHBhcmFtVGhyZWVUb0dMICggcCApIHtcclxuXHJcblx0XHR2YXIgZXh0ZW5zaW9uO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLlJFUEVBVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiBfZ2wuQ0xBTVBfVE9fRURHRTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuTUlSUk9SRURfUkVQRUFUO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9CWVRFO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuQnl0ZVR5cGUgKSByZXR1cm4gX2dsLkJZVEU7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNob3J0VHlwZSApIHJldHVybiBfZ2wuU0hPUlQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuSW50VHlwZSApIHJldHVybiBfZ2wuSU5UO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEludFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0lOVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuRmxvYXRUeXBlICkgcmV0dXJuIF9nbC5GTE9BVDtcclxuXHJcblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgKSByZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFGb3JtYXQgKSByZXR1cm4gX2dsLlJHQkE7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuQWRkRXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfQUREO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5TdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1NVQlRSQUNUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuWmVyb0ZhY3RvciApIHJldHVybiBfZ2wuWkVSTztcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lRmFjdG9yICkgcmV0dXJuIF9nbC5PTkU7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQ09MT1I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQ09MT1I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEE7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQUxQSEE7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkRzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQUxQSEE7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQUxQSEE7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5Ec3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuRFNUX0NPTE9SO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0NPTE9SO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEFfU0FUVVJBVEU7XHJcblxyXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuTWF4RXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1BWF9FWFQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAwO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIERFUFJFQ0FURURcclxuXHJcblx0dGhpcy5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnICkuJyApO1xyXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRcXCcgKS4nICk7XHJcblx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFwnICkuJyApO1xyXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFwnICkuJyApO1xyXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcXCcgKS4nICk7XHJcblx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VwcG9ydHNCbGVuZE1pbk1heCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0VYVF9ibGVuZF9taW5tYXhcXCcgKS4nICk7XHJcblx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zdXBwb3J0c0luc3RhbmNlZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyApO1xyXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5pbml0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmluaXRNYXRlcmlhbCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmFkZFByZVBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuYWRkUG9zdFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUG9zdFBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVwZGF0ZVNoYWRvd01hcCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudXBkYXRlU2hhZG93TWFwKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdH07XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XHJcblx0XHRzaGFkb3dNYXBFbmFibGVkOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gc2hhZG93TWFwLmVuYWJsZWQ7XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBFbmFibGVkIGlzIG5vdyAuc2hhZG93TWFwLmVuYWJsZWQuJyApO1xyXG5cdFx0XHRcdHNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0c2hhZG93TWFwVHlwZToge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHNoYWRvd01hcC50eXBlO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcclxuXHRcdFx0XHRzaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHNoYWRvd01hcEN1bGxGYWNlOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gc2hhZG93TWFwLmN1bGxGYWNlO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaXMgbm93IC5zaGFkb3dNYXAuY3VsbEZhY2UuJyApO1xyXG5cdFx0XHRcdHNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHNoYWRvd01hcERlYnVnOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gc2hhZG93TWFwLmRlYnVnO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRGVidWcgaXMgbm93IC5zaGFkb3dNYXAuZGVidWcuJyApO1xyXG5cdFx0XHRcdHNoYWRvd01hcC5kZWJ1ZyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0gKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdGlmICggb3B0aW9ucy5taW5GaWx0ZXIgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cclxuXHR0aGlzLnRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5ICk7XHJcblxyXG5cdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcclxuXHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XHJcblxyXG5cdHRoaXMuc2hhcmVEZXB0aEZyb20gPSBvcHRpb25zLnNoYXJlRGVwdGhGcm9tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNoYXJlRGVwdGhGcm9tIDogbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCxcclxuXHJcblx0Z2V0IHdyYXBTKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgd3JhcFMoIHZhbHVlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUud3JhcFMgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHdyYXBUKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBUO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgd3JhcFQoIHZhbHVlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUud3JhcFQgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IG1hZ0ZpbHRlcigpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG1hZ0ZpbHRlciggdmFsdWUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgbWluRmlsdGVyKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRleHR1cmUubWluRmlsdGVyO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgbWluRmlsdGVyKCB2YWx1ZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCBhbmlzb3Ryb3B5KCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgYW5pc290cm9weSggdmFsdWUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUuYW5pc290cm9weSA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgb2Zmc2V0KCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRleHR1cmUub2Zmc2V0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgb2Zmc2V0KCB2YWx1ZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LicgKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUub2Zmc2V0ID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCByZXBlYXQoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5yZXBlYXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCByZXBlYXQoIHZhbHVlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZS5yZXBlYXQgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IGZvcm1hdCgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmZvcm1hdDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IGZvcm1hdCggdmFsdWUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlLmZvcm1hdCA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRleHR1cmUudHlwZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHR5cGUoIHZhbHVlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IGdlbmVyYXRlTWlwbWFwcygpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IGdlbmVyYXRlTWlwbWFwcyggdmFsdWUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvL1xyXG5cclxuXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xyXG5cclxuXHRcdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XHJcblx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlID0gc291cmNlLnRleHR1cmUuY2xvbmUoKTtcclxuXHJcblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xyXG5cdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XHJcblxyXG5cdFx0dGhpcy5zaGFyZURlcHRoRnJvbSA9IHNvdXJjZS5zaGFyZURlcHRoRnJvbTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXRDdWJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcclxuXHJcblx0VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xyXG5cclxuXHR0aGlzLmFjdGl2ZUN1YmVGYWNlID0gMDsgLy8gUFggMCwgTlggMSwgUFkgMiwgTlkgMywgUFogNCwgTlogNVxyXG5cclxufTtcclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEJ1ZmZlclJlbmRlcmVyLmpzXHJcblxyXG4vKipcclxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4qL1xyXG5cclxuVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uICggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcclxuXHJcblx0dmFyIG1vZGU7XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xyXG5cclxuXHRcdG1vZGUgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcblx0XHRfZ2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XHJcblxyXG5cdFx0X2luZm9SZW5kZXIuY2FsbHMgKys7XHJcblx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcclxuXHRcdGlmICggbW9kZSA9PT0gX2dsLlRSSUFOR0xFUyApIF9pbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uZGF0YS5jb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XHJcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XHJcblx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyLmpzXHJcblxyXG4vKipcclxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4qL1xyXG5cclxuVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XHJcblxyXG5cdHZhciBtb2RlO1xyXG5cclxuXHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRtb2RlID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHR5cGUsIHNpemU7XHJcblxyXG5cdGZ1bmN0aW9uIHNldEluZGV4KCBpbmRleCApIHtcclxuXHJcblx0XHRpZiAoIGluZGV4LmFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xyXG5cclxuXHRcdFx0dHlwZSA9IF9nbC5VTlNJR05FRF9JTlQ7XHJcblx0XHRcdHNpemUgPSA0O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xyXG5cdFx0XHRzaXplID0gMjtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSApO1xyXG5cclxuXHRcdF9pbmZvUmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0X2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XHJcblx0XHRpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHJcblx0XHRleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIGluZGV4LmFycmF5Lmxlbmd0aCwgdHlwZSwgMCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xyXG5cdHRoaXMuc2V0SW5kZXggPSBzZXRJbmRleDtcclxuXHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcclxuXHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xFeHRlbnNpb25zLmpzXHJcblxyXG4vKipcclxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4qL1xyXG5cclxuVEhSRUUuV2ViR0xFeHRlbnNpb25zID0gZnVuY3Rpb24gKCBnbCApIHtcclxuXHJcblx0dmFyIGV4dGVuc2lvbnMgPSB7fTtcclxuXHJcblx0dGhpcy5nZXQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBleHRlbnNpb247XHJcblxyXG5cdFx0c3dpdGNoICggbmFtZSApIHtcclxuXHJcblx0XHRcdGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcclxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcclxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xyXG5cclxuXHRcdHJldHVybiBleHRlbnNpb247XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMQ2FwYWJpbGl0aWVzLmpzXHJcblxyXG5USFJFRS5XZWJHTENhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdGZ1bmN0aW9uIGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICkge1xyXG5cclxuXHRcdGlmICggcHJlY2lzaW9uID09PSAnaGlnaHAnICkge1xyXG5cclxuXHRcdFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXHJcblx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gJ2hpZ2hwJztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHByZWNpc2lvbiA9ICdtZWRpdW1wJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcclxuXHJcblx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXHJcblx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiAnbWVkaXVtcCc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAnbG93cCc7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5nZXRNYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb247XHJcblxyXG5cdHRoaXMucHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJyxcclxuXHR0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA6IGZhbHNlO1xyXG5cclxuXHR0aGlzLm1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xyXG5cdHRoaXMubWF4VmVydGV4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xyXG5cdHRoaXMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX1NJWkUgKTtcclxuXHR0aGlzLm1heEN1YmVtYXBTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFICk7XHJcblxyXG5cdHRoaXMubWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XHJcblx0dGhpcy5tYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcclxuXHR0aGlzLm1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XHJcblx0dGhpcy5tYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XHJcblxyXG5cdHRoaXMudmVydGV4VGV4dHVyZXMgPSB0aGlzLm1heFZlcnRleFRleHR1cmVzID4gMDtcclxuXHR0aGlzLmZsb2F0RnJhZ21lbnRUZXh0dXJlcyA9ICEhIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XHJcblx0dGhpcy5mbG9hdFZlcnRleFRleHR1cmVzID0gdGhpcy52ZXJ0ZXhUZXh0dXJlcyAmJiB0aGlzLmZsb2F0RnJhZ21lbnRUZXh0dXJlcztcclxuXHJcblx0dmFyIF9tYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb24oIHRoaXMucHJlY2lzaW9uICk7XHJcblxyXG5cdGlmICggX21heFByZWNpc2lvbiAhPT0gdGhpcy5wcmVjaXNpb24gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjonLCB0aGlzLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgX21heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBfbWF4UHJlY2lzaW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggdGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xyXG5cclxuXHRcdHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9ICEhIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xHZW9tZXRyaWVzLmpzXHJcblxyXG4vKipcclxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4qL1xyXG5cclxuVEhSRUUuV2ViR0xHZW9tZXRyaWVzID0gZnVuY3Rpb24gKCBnbCwgcHJvcGVydGllcywgaW5mbyApIHtcclxuXHJcblx0dmFyIGdlb21ldHJpZXMgPSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0KCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcclxuXHJcblx0XHR2YXIgYnVmZmVyZ2VvbWV0cnk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuXHRcdGluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XHJcblxyXG5cdFx0cmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XHJcblx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdGRlbGV0ZUF0dHJpYnV0ZXMoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XHJcblxyXG5cdFx0ZGVsZXRlIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XHJcblxyXG5cdFx0dmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XHJcblx0XHRpZiAoIHByb3BlcnR5LndpcmVmcmFtZSApIGRlbGV0ZUF0dHJpYnV0ZSggcHJvcGVydHkud2lyZWZyYW1lICk7XHJcblxyXG5cdFx0aW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApLl9fd2ViZ2xCdWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHR2YXIgYnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRpZiAoIGJ1ZmZlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Z2wuZGVsZXRlQnVmZmVyKCBidWZmZXIgKTtcclxuXHRcdFx0cmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlcyggYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0aWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUuZGF0YSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZ2V0ID0gZ2V0O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTE9iamVjdHMuanNcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiovXHJcblxyXG5USFJFRS5XZWJHTE9iamVjdHMgPSBmdW5jdGlvbiAoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cmllcyA9IG5ldyBUSFJFRS5XZWJHTEdlb21ldHJpZXMoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xyXG5cclxuXHRcdC8vIFRPRE86IEF2b2lkIHVwZGF0aW5nIHR3aWNlICh3aGVuIHVzaW5nIHNoYWRvd01hcCkuIE1heWJlIGFkZCBmcmFtZSBjb3VudGVyLlxyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkudXBkYXRlRnJvbU9iamVjdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVBdHRyaWJ1dGUoIGluZGV4LCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtb3JwaCB0YXJnZXRzXHJcblxyXG5cdFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcclxuXHJcblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZW9tZXRyeTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9ICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIGRhdGEgKTtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uICE9PSBkYXRhLnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICkge1xyXG5cclxuXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyICk7XHJcblxyXG5cdFx0dmFyIHVzYWdlID0gZGF0YS5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XHJcblxyXG5cdFx0Z2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgZGF0YS5hcnJheSwgdXNhZ2UgKTtcclxuXHJcblx0XHRhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICkge1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggZGF0YS5keW5hbWljID09PSBmYWxzZSB8fCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHQvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xyXG5cclxuXHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgZGF0YS5hcnJheSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xPYmplY3RzLnVwZGF0ZUJ1ZmZlcjogZHluYW1pYyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCB1cGRhdGVSYW5nZS5jb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS4nICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuXHRcdFx0XHRcdFx0XHQgIGRhdGEuYXJyYXkuc3ViYXJyYXkoIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0LCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCArIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgKSApO1xyXG5cclxuXHRcdFx0ZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9IDA7IC8vIHJlc2V0IHJhbmdlXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApLl9fd2ViZ2xCdWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdGlmICggcHJvcGVydHkud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvcGVydHkud2lyZWZyYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cclxuXHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cdFx0dmFyIHBvc2l0aW9uID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHQvLyBjb25zb2xlLnRpbWUoICd3aXJlZnJhbWUnICk7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHZhciBlZGdlcyA9IHt9O1xyXG5cdFx0XHR2YXIgYXJyYXkgPSBpbmRleC5hcnJheTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGEgPSBhcnJheVsgaSArIDAgXTtcclxuXHRcdFx0XHR2YXIgYiA9IGFycmF5WyBpICsgMSBdO1xyXG5cdFx0XHRcdHZhciBjID0gYXJyYXlbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdGlmICggY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApICkgaW5kaWNlcy5wdXNoKCBhLCBiICk7XHJcblx0XHRcdFx0aWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBiLCBjICkgKSBpbmRpY2VzLnB1c2goIGIsIGMgKTtcclxuXHRcdFx0XHRpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGMsIGEgKSApIGluZGljZXMucHVzaCggYywgYSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gKCBhcnJheS5sZW5ndGggLyAzICkgLSAxOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGkgKyAwO1xyXG5cdFx0XHRcdHZhciBiID0gaSArIDE7XHJcblx0XHRcdFx0dmFyIGMgPSBpICsgMjtcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbnNvbGUudGltZUVuZCggJ3dpcmVmcmFtZScgKTtcclxuXHJcblx0XHR2YXIgVHlwZUFycmF5ID0gcG9zaXRpb24uY291bnQgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XHJcblx0XHR2YXIgYXR0cmlidXRlID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFR5cGVBcnJheSggaW5kaWNlcyApLCAxICk7XHJcblxyXG5cdFx0dXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0cHJvcGVydHkud2lyZWZyYW1lID0gYXR0cmlidXRlO1xyXG5cclxuXHRcdHJldHVybiBhdHRyaWJ1dGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApIHtcclxuXHJcblx0XHRpZiAoIGEgPiBiICkge1xyXG5cclxuXHRcdFx0dmFyIHRtcCA9IGE7XHJcblx0XHRcdGEgPSBiO1xyXG5cdFx0XHRiID0gdG1wO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGlzdCA9IGVkZ2VzWyBhIF07XHJcblxyXG5cdFx0aWYgKCBsaXN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRlZGdlc1sgYSBdID0gWyBiIF07XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGxpc3QuaW5kZXhPZiggYiApID09PSAtMSApIHtcclxuXHJcblx0XHRcdGxpc3QucHVzaCggYiApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyO1xyXG5cdHRoaXMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlID0gZ2V0V2lyZWZyYW1lQXR0cmlidXRlO1xyXG5cclxuXHR0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtLmpzXHJcblxyXG5USFJFRS5XZWJHTFByb2dyYW0gPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHByb2dyYW1JZENvdW50ID0gMDtcclxuXHJcblx0ZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICkge1xyXG5cclxuXHRcdHZhciBjaHVua3MgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBkZWZpbmVzICkge1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlID0gZGVmaW5lc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjaHVua3Muam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmZXRjaFVuaWZvcm1Mb2NhdGlvbnMoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcclxuXHJcblx0XHR2YXIgdW5pZm9ybXMgPSB7fTtcclxuXHJcblx0XHR2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0sIGkgKTtcclxuXHRcdFx0dmFyIG5hbWUgPSBpbmZvLm5hbWU7XHJcblx0XHRcdHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xyXG5cclxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBVTklGT1JNOlwiLCBuYW1lKTtcclxuXHJcblx0XHRcdHZhciBzdWZmaXhQb3MgPSBuYW1lLmxhc3RJbmRleE9mKCAnWzBdJyApO1xyXG5cdFx0XHRpZiAoIHN1ZmZpeFBvcyAhPT0gLSAxICYmIHN1ZmZpeFBvcyA9PT0gbmFtZS5sZW5ndGggLSAzICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgbmFtZS5zdWJzdHIoIDAsIHN1ZmZpeFBvcyApIF0gPSBsb2NhdGlvbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVuaWZvcm1zWyBuYW1lIF0gPSBsb2NhdGlvbjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuaWZvcm1zO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcblx0XHR2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKCBwcm9ncmFtLCBpICk7XHJcblx0XHRcdHZhciBuYW1lID0gaW5mby5uYW1lO1xyXG5cclxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOlwiLCBuYW1lLCBpICk7XHJcblxyXG5cdFx0XHRhdHRyaWJ1dGVzWyBuYW1lIF0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXR0cmlidXRlcztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcclxuXHJcblx0XHRyZXR1cm4gc3RyaW5nICE9PSAnJztcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHJcblx0XHR2YXIgZGVmaW5lcyA9IG1hdGVyaWFsLmRlZmluZXM7XHJcblxyXG5cdFx0dmFyIHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIudmVydGV4U2hhZGVyO1xyXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5mcmFnbWVudFNoYWRlcjtcclxuXHJcblx0XHR2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XHJcblx0XHR2YXIgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZMRUNUSU9OJztcclxuXHRcdHZhciBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc6XHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XHJcblx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6XHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfRVFVSVJFQyc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfU1BIRVJFJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XHJcblx0XHRcdFx0XHRlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRlJBQ1RJT04nO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5jb21iaW5lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uOlxyXG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLk1peE9wZXJhdGlvbjpcclxuXHRcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NSVgnO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuQWRkT3BlcmF0aW9uOlxyXG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX0FERCc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGdhbW1hRmFjdG9yRGVmaW5lID0gKCByZW5kZXJlci5nYW1tYUZhY3RvciA+IDAgKSA/IHJlbmRlcmVyLmdhbW1hRmFjdG9yIDogMS4wO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnYnVpbGRpbmcgbmV3IHByb2dyYW0gJyApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIGN1c3RvbURlZmluZXMgPSBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciBwcmVmaXhWZXJ0ZXgsIHByZWZpeEZyYWdtZW50O1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHByZWZpeFZlcnRleCA9ICcnO1xyXG5cdFx0XHRwcmVmaXhGcmFnbWVudCA9ICcnO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRwcmVmaXhWZXJ0ZXggPSBbXHJcblxyXG5cdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxyXG5cdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcclxuXHJcblx0XHRcdFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcclxuXHJcblx0XHRcdFx0Y3VzdG9tRGVmaW5lcyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXHJcblx0XHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcclxuXHJcblx0XHRcdFx0JyNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxyXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXHJcblx0XHRcdFx0JyNkZWZpbmUgTUFYX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFNwb3RMaWdodHMsXHJcblx0XHRcdFx0JyNkZWZpbmUgTUFYX0hFTUlfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heEhlbWlMaWdodHMsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gJyNkZWZpbmUgQk9ORV9URVhUVVJFJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/ICcjZGVmaW5lIFNIQURPV01BUF9ERUJVRycgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnBvaW50TGlnaHRTaGFkb3dzID4gMCA/ICcjZGVmaW5lIFBPSU5UX0xJR0hUX1NIQURPV1MnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcclxuXHJcblxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcclxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXHJcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzMgcG9zaXRpb247JyxcclxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXHJcblx0XHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX0NPTE9SJyxcclxuXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcclxuXHJcblx0XHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX01PUlBIVEFSR0VUUycsXHJcblxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxyXG5cclxuXHRcdFx0XHQnXHQjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXHJcblxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOycsXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7JyxcclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLFxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOycsXHJcblxyXG5cdFx0XHRcdCdcdCNlbHNlJyxcclxuXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcclxuXHJcblx0XHRcdFx0J1x0I2VuZGlmJyxcclxuXHJcblx0XHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcclxuXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxyXG5cclxuXHRcdFx0XHQnI2VuZGlmJyxcclxuXHJcblx0XHRcdFx0J1xcbidcclxuXHJcblx0XHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xyXG5cclxuXHRcdFx0cHJlZml4RnJhZ21lbnQgPSBbXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nIHx8IG1hdGVyaWFsLmRlcml2YXRpdmVzID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsXHJcblxyXG5cdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxyXG5cdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcclxuXHJcblx0XHRcdFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcclxuXHJcblx0XHRcdFx0Y3VzdG9tRGVmaW5lcyxcclxuXHJcblx0XHRcdFx0JyNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxyXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXHJcblx0XHRcdFx0JyNkZWZpbmUgTUFYX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFNwb3RMaWdodHMsXHJcblx0XHRcdFx0JyNkZWZpbmUgTUFYX0hFTUlfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heEhlbWlMaWdodHMsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXHJcblx0XHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcclxuXHJcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcclxuXHRcdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1ldGFsID8gJyNkZWZpbmUgTUVUQUwnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gJyNkZWZpbmUgU0hBRE9XTUFQX0RFQlVHJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMucG9pbnRMaWdodFNoYWRvd3MgPiAwID8gJyNkZWZpbmUgUE9JTlRfTElHSFRfU0hBRE9XUycgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcclxuXHJcblx0XHRcdFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXHJcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0XHQnXFxuJ1xyXG5cclxuXHRcdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB2ZXJ0ZXhHbHNsID0gcHJlZml4VmVydGV4ICsgdmVydGV4U2hhZGVyO1xyXG5cdFx0dmFyIGZyYWdtZW50R2xzbCA9IHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XHJcblxyXG5cdFx0dmFyIGdsVmVydGV4U2hhZGVyID0gVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XHJcblx0XHR2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcclxuXHJcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XHJcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHQvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdC8vIHByb2dyYW1zIHdpdGggbW9ycGhUYXJnZXRzIGRpc3BsYWNlIHBvc2l0aW9uIG91dCBvZiBhdHRyaWJ1dGUgMFxyXG5cdFx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICk7XHJcblx0XHR2YXIgdmVydGV4TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuXHRcdHZhciBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHR2YXIgcnVubmFibGUgPSB0cnVlO1xyXG5cdFx0dmFyIGhhdmVEaWFnbm9zdGljcyA9IHRydWU7XHJcblxyXG5cdFx0aWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHJ1bm5hYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBzaGFkZXIgZXJyb3I6ICcsIGdsLmdldEVycm9yKCksICdnbC5WQUxJREFURV9TVEFUVVMnLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMgKSwgJ2dsLmdldFByb2dyYW1JbmZvTG9nJywgcHJvZ3JhbUxvZywgdmVydGV4TG9nLCBmcmFnbWVudExvZyApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHByb2dyYW1Mb2cgIT09ICcnICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgcHJvZ3JhbUxvZyApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHZlcnRleExvZyA9PT0gJycgfHwgZnJhZ21lbnRMb2cgPT09ICcnICkge1xyXG5cclxuXHRcdFx0aGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaGF2ZURpYWdub3N0aWNzICkge1xyXG5cclxuXHRcdFx0dGhpcy5kaWFnbm9zdGljcyA9IHtcclxuXHJcblx0XHRcdFx0cnVubmFibGU6IHJ1bm5hYmxlLFxyXG5cdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcclxuXHJcblx0XHRcdFx0cHJvZ3JhbUxvZzogcHJvZ3JhbUxvZyxcclxuXHJcblx0XHRcdFx0dmVydGV4U2hhZGVyOiB7XHJcblxyXG5cdFx0XHRcdFx0bG9nOiB2ZXJ0ZXhMb2csXHJcblx0XHRcdFx0XHRwcmVmaXg6IHByZWZpeFZlcnRleFxyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjoge1xyXG5cclxuXHRcdFx0XHRcdGxvZzogZnJhZ21lbnRMb2csXHJcblx0XHRcdFx0XHRwcmVmaXg6IHByZWZpeEZyYWdtZW50XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNsZWFuIHVwXHJcblxyXG5cdFx0Z2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xyXG5cdFx0Z2wuZGVsZXRlU2hhZGVyKCBnbEZyYWdtZW50U2hhZGVyICk7XHJcblxyXG5cdFx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXHJcblxyXG5cdFx0dmFyIGNhY2hlZFVuaWZvcm1zO1xyXG5cclxuXHRcdHRoaXMuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y2FjaGVkVW5pZm9ybXMgPSBmZXRjaFVuaWZvcm1Mb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FjaGVkVW5pZm9ybXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xyXG5cclxuXHRcdHZhciBjYWNoZWRBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0aWYgKCBjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNhY2hlZEF0dHJpYnV0ZXMgPSBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjYWNoZWRBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gZnJlZSByZXNvdXJjZVxyXG5cclxuXHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0Z2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cdFx0XHR0aGlzLnByb2dyYW0gPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBERVBSRUNBVEVEXHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC51bmlmb3JtcyBpcyBub3cgLmdldFVuaWZvcm1zKCkuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VW5pZm9ybXMoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0YXR0cmlidXRlczoge1xyXG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAuYXR0cmlidXRlcyBpcyBub3cgLmdldEF0dHJpYnV0ZXMoKS4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gKTtcclxuXHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQgKys7XHJcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xyXG5cdFx0dGhpcy51c2VkVGltZXMgPSAxO1xyXG5cdFx0dGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XHJcblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gZ2xGcmFnbWVudFNoYWRlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcbn0gKSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvZ3JhbXMuanNcclxuXHJcblRIUkVFLldlYkdMUHJvZ3JhbXMgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBjYXBhYmlsaXRpZXMgKSB7XHJcblxyXG5cdHZhciBwcm9ncmFtcyA9IFtdO1xyXG5cclxuXHR2YXIgc2hhZGVySURzID0ge1xyXG5cdFx0TWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXHJcblx0XHRNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxyXG5cdFx0TWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXHJcblx0XHRNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXHJcblx0XHRNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcclxuXHRcdExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxyXG5cdFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcclxuXHRcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJ1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJhbWV0ZXJOYW1lcyA9IFtcclxuXHRcdFwicHJlY2lzaW9uXCIsIFwic3VwcG9ydHNWZXJ0ZXhUZXh0dXJlc1wiLCBcIm1hcFwiLCBcImVudk1hcFwiLCBcImVudk1hcE1vZGVcIixcclxuXHRcdFwibGlnaHRNYXBcIiwgXCJhb01hcFwiLCBcImVtaXNzaXZlTWFwXCIsIFwiYnVtcE1hcFwiLCBcIm5vcm1hbE1hcFwiLCBcImRpc3BsYWNlbWVudE1hcFwiLCBcInNwZWN1bGFyTWFwXCIsXHJcblx0XHRcImFscGhhTWFwXCIsIFwiY29tYmluZVwiLCBcInZlcnRleENvbG9yc1wiLCBcImZvZ1wiLCBcInVzZUZvZ1wiLCBcImZvZ0V4cFwiLFxyXG5cdFx0XCJmbGF0U2hhZGluZ1wiLCBcInNpemVBdHRlbnVhdGlvblwiLCBcImxvZ2FyaXRobWljRGVwdGhCdWZmZXJcIiwgXCJza2lubmluZ1wiLFxyXG5cdFx0XCJtYXhCb25lc1wiLCBcInVzZVZlcnRleFRleHR1cmVcIiwgXCJtb3JwaFRhcmdldHNcIiwgXCJtb3JwaE5vcm1hbHNcIixcclxuXHRcdFwibWF4TW9ycGhUYXJnZXRzXCIsIFwibWF4TW9ycGhOb3JtYWxzXCIsIFwibWF4RGlyTGlnaHRzXCIsIFwibWF4UG9pbnRMaWdodHNcIixcclxuXHRcdFwibWF4U3BvdExpZ2h0c1wiLCBcIm1heEhlbWlMaWdodHNcIiwgXCJtYXhTaGFkb3dzXCIsIFwic2hhZG93TWFwRW5hYmxlZFwiLCBcInBvaW50TGlnaHRTaGFkb3dzXCIsXHJcblx0XHRcInNoYWRvd01hcFR5cGVcIiwgXCJzaGFkb3dNYXBEZWJ1Z1wiLCBcImFscGhhVGVzdFwiLCBcIm1ldGFsXCIsIFwiZG91YmxlU2lkZWRcIixcclxuXHRcdFwiZmxpcFNpZGVkXCJcclxuXHRdO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gYWxsb2NhdGVCb25lcyAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gMTAyNDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxyXG5cdFx0XHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcclxuXHRcdFx0Ly9cclxuXHRcdFx0Ly8gIC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcclxuXHRcdFx0Ly8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXHJcblx0XHRcdC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcclxuXHJcblx0XHRcdHZhciBuVmVydGV4VW5pZm9ybXMgPSBjYXBhYmlsaXRpZXMubWF4VmVydGV4VW5pZm9ybXM7XHJcblx0XHRcdHZhciBuVmVydGV4TWF0cmljZXMgPSBNYXRoLmZsb29yKCAoIG5WZXJ0ZXhVbmlmb3JtcyAtIDIwICkgLyA0ICk7XHJcblxyXG5cdFx0XHR2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xyXG5cclxuXHRcdFx0XHRtYXhCb25lcyA9IE1hdGgubWluKCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoLCBtYXhCb25lcyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtICcgKyBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICsgJywgdGhpcyBHUFUgc3VwcG9ydHMganVzdCAnICsgbWF4Qm9uZXMgKyAnICh0cnkgT3BlbkdMIGluc3RlYWQgb2YgQU5HTEUpJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWF4Qm9uZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKSB7XHJcblxyXG5cdFx0dmFyIGRpckxpZ2h0cyA9IDA7XHJcblx0XHR2YXIgcG9pbnRMaWdodHMgPSAwO1xyXG5cdFx0dmFyIHNwb3RMaWdodHMgPSAwO1xyXG5cdFx0dmFyIGhlbWlMaWdodHMgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGlnaHQgPSBsaWdodHNbIGwgXTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgZGlyTGlnaHRzICsrO1xyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHBvaW50TGlnaHRzICsrO1xyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkgc3BvdExpZ2h0cyArKztcclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIGhlbWlMaWdodHMgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7ICdkaXJlY3Rpb25hbCc6IGRpckxpZ2h0cywgJ3BvaW50JzogcG9pbnRMaWdodHMsICdzcG90Jzogc3BvdExpZ2h0cywgJ2hlbWknOiBoZW1pTGlnaHRzIH07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKSB7XHJcblxyXG5cdFx0dmFyIG1heFNoYWRvd3MgPSAwO1xyXG5cdFx0dmFyIHBvaW50TGlnaHRTaGFkb3dzID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG5cdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCB8fCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBtYXhTaGFkb3dzICsrO1xyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0bWF4U2hhZG93cyArKztcclxuXHRcdFx0XHRwb2ludExpZ2h0U2hhZG93cyArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHsgJ21heFNoYWRvd3MnOiBtYXhTaGFkb3dzLCAncG9pbnRMaWdodFNoYWRvd3MnOiBwb2ludExpZ2h0U2hhZG93cyB9O1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZ2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIHNoYWRlcklEID0gc2hhZGVySURzWyBtYXRlcmlhbC50eXBlIF07XHJcblx0XHQvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxyXG5cdFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcclxuXHJcblx0XHR2YXIgbWF4TGlnaHRDb3VudCA9IGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKTtcclxuXHRcdHZhciBhbGxvY2F0ZWRTaGFkb3dzID0gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKTtcclxuXHRcdHZhciBtYXhCb25lcyA9IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApO1xyXG5cdFx0dmFyIHByZWNpc2lvbiA9IHJlbmRlcmVyLmdldFByZWNpc2lvbigpO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XHJcblxyXG5cdFx0XHRpZiAoIHByZWNpc2lvbiAhPT0gbWF0ZXJpYWwucHJlY2lzaW9uICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyLmluaXRNYXRlcmlhbDonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFyYW1ldGVycyA9IHtcclxuXHJcblx0XHRcdHNoYWRlcklEOiBzaGFkZXJJRCxcclxuXHJcblx0XHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxyXG5cdFx0XHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBjYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXMsXHJcblxyXG5cdFx0XHRtYXA6ICEhIG1hdGVyaWFsLm1hcCxcclxuXHRcdFx0ZW52TWFwOiAhISBtYXRlcmlhbC5lbnZNYXAsXHJcblx0XHRcdGVudk1hcE1vZGU6IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyxcclxuXHRcdFx0bGlnaHRNYXA6ICEhIG1hdGVyaWFsLmxpZ2h0TWFwLFxyXG5cdFx0XHRhb01hcDogISEgbWF0ZXJpYWwuYW9NYXAsXHJcblx0XHRcdGVtaXNzaXZlTWFwOiAhISBtYXRlcmlhbC5lbWlzc2l2ZU1hcCxcclxuXHRcdFx0YnVtcE1hcDogISEgbWF0ZXJpYWwuYnVtcE1hcCxcclxuXHRcdFx0bm9ybWFsTWFwOiAhISBtYXRlcmlhbC5ub3JtYWxNYXAsXHJcblx0XHRcdGRpc3BsYWNlbWVudE1hcDogISEgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxyXG5cdFx0XHRzcGVjdWxhck1hcDogISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXHJcblx0XHRcdGFscGhhTWFwOiAhISBtYXRlcmlhbC5hbHBoYU1hcCxcclxuXHJcblx0XHRcdGNvbWJpbmU6IG1hdGVyaWFsLmNvbWJpbmUsXHJcblxyXG5cdFx0XHR2ZXJ0ZXhDb2xvcnM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyxcclxuXHJcblx0XHRcdGZvZzogZm9nLFxyXG5cdFx0XHR1c2VGb2c6IG1hdGVyaWFsLmZvZyxcclxuXHRcdFx0Zm9nRXhwOiBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyLFxyXG5cclxuXHRcdFx0ZmxhdFNoYWRpbmc6IG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nLFxyXG5cclxuXHRcdFx0c2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXHJcblx0XHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxyXG5cclxuXHRcdFx0c2tpbm5pbmc6IG1hdGVyaWFsLnNraW5uaW5nLFxyXG5cdFx0XHRtYXhCb25lczogbWF4Qm9uZXMsXHJcblx0XHRcdHVzZVZlcnRleFRleHR1cmU6IGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUsXHJcblxyXG5cdFx0XHRtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcclxuXHRcdFx0bW9ycGhOb3JtYWxzOiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMsXHJcblx0XHRcdG1heE1vcnBoVGFyZ2V0czogcmVuZGVyZXIubWF4TW9ycGhUYXJnZXRzLFxyXG5cdFx0XHRtYXhNb3JwaE5vcm1hbHM6IHJlbmRlcmVyLm1heE1vcnBoTm9ybWFscyxcclxuXHJcblx0XHRcdG1heERpckxpZ2h0czogbWF4TGlnaHRDb3VudC5kaXJlY3Rpb25hbCxcclxuXHRcdFx0bWF4UG9pbnRMaWdodHM6IG1heExpZ2h0Q291bnQucG9pbnQsXHJcblx0XHRcdG1heFNwb3RMaWdodHM6IG1heExpZ2h0Q291bnQuc3BvdCxcclxuXHRcdFx0bWF4SGVtaUxpZ2h0czogbWF4TGlnaHRDb3VudC5oZW1pLFxyXG5cclxuXHRcdFx0bWF4U2hhZG93czogYWxsb2NhdGVkU2hhZG93cy5tYXhTaGFkb3dzLFxyXG5cdFx0XHRwb2ludExpZ2h0U2hhZG93czogYWxsb2NhdGVkU2hhZG93cy5wb2ludExpZ2h0U2hhZG93cyxcclxuXHRcdFx0c2hhZG93TWFwRW5hYmxlZDogcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgJiYgb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgYWxsb2NhdGVkU2hhZG93cy5tYXhTaGFkb3dzID4gMCxcclxuXHRcdFx0c2hhZG93TWFwVHlwZTogcmVuZGVyZXIuc2hhZG93TWFwLnR5cGUsXHJcblx0XHRcdHNoYWRvd01hcERlYnVnOiByZW5kZXJlci5zaGFkb3dNYXAuZGVidWcsXHJcblxyXG5cdFx0XHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcclxuXHRcdFx0bWV0YWw6IG1hdGVyaWFsLm1ldGFsLFxyXG5cdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcclxuXHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIHBhcmFtZXRlcnM7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0UHJvZ3JhbUNvZGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHZhciBjaHVua3MgPSBbXTtcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XHJcblxyXG5cdFx0XHRjaHVua3MucHVzaCggcGFyYW1ldGVycy5zaGFkZXJJRCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjaHVua3MucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XHJcblxyXG5cdFx0XHRcdGNodW5rcy5wdXNoKCBuYW1lICk7XHJcblx0XHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJOYW1lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlck5hbWVzWyBpIF07XHJcblx0XHRcdGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJOYW1lICk7XHJcblx0XHRcdGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJzWyBwYXJhbWV0ZXJOYW1lIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuYWNxdWlyZVByb2dyYW0gPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtO1xyXG5cclxuXHRcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxyXG5cdFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcclxuXHJcblx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xyXG5cdFx0XHRcdCsrIHByb2dyYW0udXNlZFRpbWVzO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwcm9ncmFtID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XHJcblx0XHRcdHByb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVsZWFzZVByb2dyYW0gPSBmdW5jdGlvbiggcHJvZ3JhbSApIHtcclxuXHJcblx0XHRpZiAoIC0tIHByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxyXG5cdFx0XHR2YXIgaSA9IHByb2dyYW1zLmluZGV4T2YoIHByb2dyYW0gKTtcclxuXHRcdFx0cHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XHJcblx0XHRcdHByb2dyYW1zLnBvcCgpO1xyXG5cclxuXHRcdFx0Ly8gRnJlZSBXZWJHTCByZXNvdXJjZXNcclxuXHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XHJcblx0dGhpcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb3BlcnRpZXMuanNcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXHJcbiovXHJcblxyXG5USFJFRS5XZWJHTFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBwcm9wZXJ0aWVzID0ge307XHJcblxyXG5cdHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcclxuXHRcdHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XHJcblxyXG5cdFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hcCA9IHt9O1xyXG5cdFx0XHRwcm9wZXJ0aWVzWyB1dWlkIF0gPSBtYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXA7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZGVsZXRlID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0ZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cHJvcGVydGllcyA9IHt9O1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRlci5qc1xyXG5cclxuVEhSRUUuV2ViR0xTaGFkZXIgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0ZnVuY3Rpb24gYWRkTGluZU51bWJlcnMoIHN0cmluZyApIHtcclxuXHJcblx0XHR2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0bGluZXNbIGkgXSA9ICggaSArIDEgKSArICc6ICcgKyBsaW5lc1sgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGluZXMuam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0dmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xyXG5cclxuXHRcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xyXG5cclxuXHRcdGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxyXG5cdFx0Ly8gY29uc29sZS5sb2coIHR5cGUsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggc2hhZGVyICkgKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkb3dNYXAuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMU2hhZG93TWFwID0gZnVuY3Rpb24gKCBfcmVuZGVyZXIsIF9saWdodHMsIF9vYmplY3RzICkge1xyXG5cclxuXHR2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQsXHJcblx0X3N0YXRlID0gX3JlbmRlcmVyLnN0YXRlLFxyXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcclxuXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG5cdF9taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdF9tYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRfbG9va1RhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0X2xpZ2h0UG9zaXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdF9yZW5kZXJMaXN0ID0gW10sXHJcblxyXG5cdF9Nb3JwaGluZ0ZsYWcgPSAxLFxyXG5cdF9Ta2lubmluZ0ZsYWcgPSAyLFxyXG5cclxuXHRfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzID0gKCBfTW9ycGhpbmdGbGFnIHwgX1NraW5uaW5nRmxhZyApICsgMSxcclxuXHJcblx0X2RlcHRoTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICksXHJcblx0X2Rpc3RhbmNlTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICk7XHJcblxyXG5cdHZhciBjdWJlRGlyZWN0aW9ucyA9IFtcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApXHJcblx0XTtcclxuXHJcblx0dmFyIGN1YmVVcHMgPSBbXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSxcdG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEgKVxyXG5cdF07XHJcblxyXG5cdHZhciBjdWJlMkRWaWV3UG9ydHMgPSBbXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjQoKSwgbmV3IFRIUkVFLlZlY3RvcjQoKSwgbmV3IFRIUkVFLlZlY3RvcjQoKVxyXG5cdF07XHJcblxyXG5cdHZhciBfdmVjdG9yNCA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblxyXG5cdC8vIGluaXRcclxuXHJcblx0dmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XHJcblx0dmFyIGRlcHRoVW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBkZXB0aFNoYWRlci51bmlmb3JtcyApO1xyXG5cclxuXHR2YXIgZGlzdGFuY2VTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGlzdGFuY2VSR0JBXCIgXTtcclxuXHR2YXIgZGlzdGFuY2VVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRpc3RhbmNlU2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSAhPT0gX051bWJlck9mTWF0ZXJpYWxWYXJpYW50czsgKysgaSApIHtcclxuXHJcblx0XHR2YXIgdXNlTW9ycGhpbmcgPSAoIGkgJiBfTW9ycGhpbmdGbGFnICkgIT09IDA7XHJcblx0XHR2YXIgdXNlU2tpbm5pbmcgPSAoIGkgJiBfU2tpbm5pbmdGbGFnICkgIT09IDA7XHJcblxyXG5cdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcclxuXHRcdFx0dW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXHJcblx0XHRcdG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXHJcblx0XHRcdHNraW5uaW5nOiB1c2VTa2lubmluZ1xyXG5cdFx0fSApO1xyXG5cclxuXHRcdGRlcHRoTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xyXG5cclxuXHRcdF9kZXB0aE1hdGVyaWFsc1sgaSBdID0gZGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xyXG5cdFx0XHR1bmlmb3JtczogZGlzdGFuY2VVbmlmb3JtcyxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiBkaXN0YW5jZVNoYWRlci52ZXJ0ZXhTaGFkZXIsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBkaXN0YW5jZVNoYWRlci5mcmFnbWVudFNoYWRlcixcclxuXHRcdFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcclxuXHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0ZGlzdGFuY2VNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XHJcblxyXG5cdFx0X2Rpc3RhbmNlTWF0ZXJpYWxzWyBpIF0gPSBkaXN0YW5jZU1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy50eXBlID0gVEhSRUUuUENGU2hhZG93TWFwO1xyXG5cdHRoaXMuY3VsbEZhY2UgPSBUSFJFRS5DdWxsRmFjZUZyb250O1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUgKSB7XHJcblxyXG5cdFx0dmFyIGZhY2VDb3VudCwgaXNQb2ludExpZ2h0O1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblx0XHRpZiAoIHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHQvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cclxuXHRcdF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XHJcblx0XHRfc3RhdGUuZGlzYWJsZSggX2dsLkJMRU5EICk7XHJcblx0XHRfc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XHJcblx0XHRfZ2wuY3VsbEZhY2UoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ID8gX2dsLkZST05UIDogX2dsLkJBQ0sgKTtcclxuXHRcdF9zdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcclxuXHJcblx0XHQvLyBzYXZlIHRoZSBleGlzdGluZyB2aWV3cG9ydCBzbyBpdCBjYW4gYmUgcmVzdG9yZWQgbGF0ZXJcclxuXHRcdF9yZW5kZXJlci5nZXRWaWV3cG9ydCggX3ZlY3RvcjQgKTtcclxuXHJcblx0XHQvLyByZW5kZXIgZGVwdGggbWFwXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IF9saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGlnaHQgPSBfbGlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XHJcblx0XHRcdFx0dmFyIHNoYWRvd0NhbWVyYSA9IHNoYWRvdy5jYW1lcmE7XHJcblx0XHRcdFx0dmFyIHNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZUNvdW50ID0gNjtcclxuXHRcdFx0XHRcdGlzUG9pbnRMaWdodCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZwV2lkdGggPSBzaGFkb3dNYXBTaXplLnggLyA0LjA7XHJcblx0XHRcdFx0XHR2YXIgdnBIZWlnaHQgPSBzaGFkb3dNYXBTaXplLnkgLyAyLjA7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhlc2Ugdmlld3BvcnRzIG1hcCBhIGN1YmUtbWFwIG9udG8gYSAyRCB0ZXh0dXJlIHdpdGggdGhlXHJcblx0XHRcdFx0XHQvLyBmb2xsb3dpbmcgb3JpZW50YXRpb246XHJcblx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0Ly8gIHh6WFpcclxuXHRcdFx0XHRcdC8vICAgeSBZXHJcblx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0Ly8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXHJcblx0XHRcdFx0XHQvLyB4IC0gTmVnYXRpdmUgeCBkaXJlY3Rpb25cclxuXHRcdFx0XHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxyXG5cdFx0XHRcdFx0Ly8geSAtIE5lZ2F0aXZlIHkgZGlyZWN0aW9uXHJcblx0XHRcdFx0XHQvLyBaIC0gUG9zaXRpdmUgeiBkaXJlY3Rpb25cclxuXHRcdFx0XHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxyXG5cclxuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIFhcclxuXHRcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMCBdLnNldCggdnBXaWR0aCAqIDIsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdFx0Ly8gbmVnYXRpdmUgWFxyXG5cdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAxIF0uc2V0KCAwLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcclxuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIFpcclxuXHRcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMiBdLnNldCggdnBXaWR0aCAqIDMsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdFx0Ly8gbmVnYXRpdmUgWlxyXG5cdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAzIF0uc2V0KCB2cFdpZHRoLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcclxuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIFlcclxuXHRcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgNCBdLnNldCggdnBXaWR0aCAqIDMsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblx0XHRcdFx0XHQvLyBuZWdhdGl2ZSBZXHJcblx0XHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDUgXS5zZXQoIHZwV2lkdGgsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZUNvdW50ID0gMTtcclxuXHRcdFx0XHRcdGlzUG9pbnRMaWdodCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggc2hhZG93Lm1hcCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cclxuXHRcdFx0XHRcdGlmICggc2NvcGUudHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNoYWRvd0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IHNoYWRvd0ZpbHRlciwgbWFnRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCQUZvcm1hdCB9O1xyXG5cclxuXHRcdFx0XHRcdHNoYWRvdy5tYXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHNoYWRvd01hcFNpemUueCwgc2hhZG93TWFwU2l6ZS55LCBwYXJzICk7XHJcblx0XHRcdFx0XHRzaGFkb3cubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEuYXNwZWN0ID0gc2hhZG93TWFwU2l6ZS54IC8gc2hhZG93TWFwU2l6ZS55O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBzaGFkb3dNYXAgPSBzaGFkb3cubWFwO1xyXG5cdFx0XHRcdHZhciBzaGFkb3dNYXRyaXggPSBzaGFkb3cubWF0cml4O1xyXG5cclxuXHRcdFx0XHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRzaGFkb3dDYW1lcmEucG9zaXRpb24uY29weSggX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xyXG5cclxuXHRcdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcclxuXHRcdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIHNoYWRvdyBtYXAgZm9yIGVhY2ggY3ViZSBmYWNlIChpZiBvbW5pLWRpcmVjdGlvbmFsKSBvclxyXG5cdFx0XHRcdC8vIHJ1biBhIHNpbmdsZSBwYXNzIGlmIG5vdFxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgZmFjZSA9IDA7IGZhY2UgPCBmYWNlQ291bnQ7IGZhY2UgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfbG9va1RhcmdldC5jb3B5KCBzaGFkb3dDYW1lcmEucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdFx0X2xvb2tUYXJnZXQuYWRkKCBjdWJlRGlyZWN0aW9uc1sgZmFjZSBdICk7XHJcblx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYS51cC5jb3B5KCBjdWJlVXBzWyBmYWNlIF0gKTtcclxuXHRcdFx0XHRcdFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX2xvb2tUYXJnZXQgKTtcclxuXHRcdFx0XHRcdFx0dmFyIHZwRGltZW5zaW9ucyA9IGN1YmUyRFZpZXdQb3J0c1sgZmFjZSBdO1xyXG5cdFx0XHRcdFx0XHRfcmVuZGVyZXIuc2V0Vmlld3BvcnQoIHZwRGltZW5zaW9ucy54LCB2cERpbWVuc2lvbnMueSwgdnBEaW1lbnNpb25zLnosIHZwRGltZW5zaW9ucy53ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdF9sb29rVGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cdFx0XHRcdFx0c2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcclxuXHJcblx0XHRcdFx0XHRzaGFkb3dNYXRyaXguc2V0KFxyXG5cdFx0XHRcdFx0XHQwLjUsIDAuMCwgMC4wLCAwLjUsXHJcblx0XHRcdFx0XHRcdDAuMCwgMC41LCAwLjAsIDAuNSxcclxuXHRcdFx0XHRcdFx0MC4wLCAwLjAsIDAuNSwgMC41LFxyXG5cdFx0XHRcdFx0XHQwLjAsIDAuMCwgMC4wLCAxLjBcclxuXHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxyXG5cclxuXHRcdFx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRcdFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcclxuXHJcblx0XHRcdFx0XHRfcmVuZGVyTGlzdC5sZW5ndGggPSAwO1xyXG5cclxuXHRcdFx0XHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBzaGFkb3dDYW1lcmEgKTtcclxuXHJcblx0XHRcdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcFxyXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIHJlZ3VsYXIgb2JqZWN0c1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBfcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBvYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xyXG5cdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDAsIGtsID0gZ3JvdXBzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgayBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBncm91cE1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBfbGlnaHRzLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIF9saWdodHMsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIG51bGwgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gV2UgbXVzdCBjYWxsIF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKSBhdCB0aGUgZW5kIG9mIGVhY2ggaXRlcmF0aW9uIG9mXHJcblx0XHRcdFx0Ly8gdGhlIGxpZ2h0IGxvb3AgaW4gb3JkZXIgdG8gZm9yY2UgbWF0ZXJpYWwgdXBkYXRlcyBmb3IgZWFjaCBsaWdodC5cclxuXHRcdFx0XHRfcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9yZW5kZXJlci5zZXRWaWV3cG9ydCggX3ZlY3RvcjQueCwgX3ZlY3RvcjQueSwgX3ZlY3RvcjQueiwgX3ZlY3RvcjQudyApO1xyXG5cclxuXHRcdC8vIFJlc3RvcmUgR0wgc3RhdGUuXHJcblx0XHR2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXHJcblx0XHRjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcclxuXHRcdF9yZW5kZXJlci5zZXRDbGVhckNvbG9yKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XHJcblx0XHRfc3RhdGUuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xyXG5cclxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XHJcblxyXG5cdFx0c2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBsaWdodFBvc2l0aW9uV29ybGQgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdHZhciBuZXdNYXRlcmlhbCA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsVmFyaWFudHMgPSBfZGVwdGhNYXRlcmlhbHM7XHJcblx0XHR2YXIgY3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsVmFyaWFudHMgPSBfZGlzdGFuY2VNYXRlcmlhbHM7XHJcblx0XHRcdGN1c3RvbU1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURpc3RhbmNlTWF0ZXJpYWw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggISBjdXN0b21NYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHZhciB1c2VNb3JwaGluZyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCAmJiBtYXRlcmlhbC5tb3JwaFRhcmdldHM7XHJcblxyXG5cdFx0XHR2YXIgdXNlU2tpbm5pbmcgPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCAmJiBtYXRlcmlhbC5za2lubmluZztcclxuXHJcblx0XHRcdHZhciB2YXJpYW50SW5kZXggPSAwO1xyXG5cclxuXHRcdFx0aWYgKCB1c2VNb3JwaGluZyApIHZhcmlhbnRJbmRleCB8PSBfTW9ycGhpbmdGbGFnO1xyXG5cdFx0XHRpZiAoIHVzZVNraW5uaW5nICkgdmFyaWFudEluZGV4IHw9IF9Ta2lubmluZ0ZsYWc7XHJcblxyXG5cdFx0XHRuZXdNYXRlcmlhbCA9IG1hdGVyaWFsVmFyaWFudHNbIHZhcmlhbnRJbmRleCBdO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRuZXdNYXRlcmlhbCA9IGN1c3RvbU1hdGVyaWFsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRuZXdNYXRlcmlhbC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcclxuXHRcdG5ld01hdGVyaWFsLndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcclxuXHRcdG5ld01hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0XHRpZiAoIGlzUG9pbnRMaWdodCAmJiBuZXdNYXRlcmlhbC51bmlmb3Jtcy5saWdodFBvcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bmV3TWF0ZXJpYWwudW5pZm9ybXMubGlnaHRQb3MudmFsdWUuY29weSggbGlnaHRQb3NpdGlvbldvcmxkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdNYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICYmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRfcmVuZGVyTGlzdC5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFN0YXRlLmpzXHJcblxyXG4vKipcclxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4qL1xyXG5cclxuVEhSRUUuV2ViR0xTdGF0ZSA9IGZ1bmN0aW9uICggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICkge1xyXG5cclxuXHR2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuXHR2YXIgbmV3QXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xyXG5cdHZhciBlbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xyXG5cdHZhciBhdHRyaWJ1dGVEaXZpc29ycyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xyXG5cclxuXHR2YXIgY2FwYWJpbGl0aWVzID0ge307XHJcblxyXG5cdHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xyXG5cclxuXHR2YXIgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xyXG5cdHZhciBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XHJcblxyXG5cdHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcclxuXHR2YXIgY3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xyXG5cclxuXHR2YXIgY3VycmVudENvbG9yV3JpdGUgPSBudWxsO1xyXG5cclxuXHR2YXIgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XHJcblxyXG5cdHZhciBjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcclxuXHR2YXIgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XHJcblxyXG5cdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHJcblx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHVuZGVmaW5lZDtcclxuXHR2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGdsLmNsZWFyQ29sb3IoIDAsIDAsIDAsIDEgKTtcclxuXHRcdGdsLmNsZWFyRGVwdGgoIDEgKTtcclxuXHRcdGdsLmNsZWFyU3RlbmNpbCggMCApO1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xyXG5cclxuXHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XHJcblx0XHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xyXG5cdFx0dGhpcy5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcclxuXHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuaW5pdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5hYmxlQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0XHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIDAgKTtcclxuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciA9IGZ1bmN0aW9uICggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKSB7XHJcblxyXG5cdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xyXG5cdFx0XHRhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gPSBtZXNoUGVyQXR0cmlidXRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xyXG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoIGlkICkge1xyXG5cclxuXHRcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlKCBpZCApO1xyXG5cdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcblx0XHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRnbC5kaXNhYmxlKCBpZCApO1xyXG5cdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gW107XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XHJcblx0XHRcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldEJsZW5kaW5nID0gZnVuY3Rpb24gKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEgKSB7XHJcblxyXG5cdFx0aWYgKCBibGVuZGluZyAhPT0gY3VycmVudEJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTm9CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cclxuXHRcdFx0XHR0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cclxuXHRcdFx0XHR0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XHJcblx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcclxuXHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xyXG5cdFx0XHRibGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYSB8fCBibGVuZFNyYztcclxuXHRcdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XHJcblxyXG5cdFx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSApIHtcclxuXHJcblx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcclxuXHJcblx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGJsZW5kU3JjICE9PSBjdXJyZW50QmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IGN1cnJlbnRCbGVuZERzdCB8fCBibGVuZFNyY0FscGhhICE9PSBjdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSBjdXJyZW50QmxlbmREc3RBbHBoYSApIHtcclxuXHJcblx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjQWxwaGEgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0QWxwaGEgKSApO1xyXG5cclxuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcclxuXHRcdFx0XHRjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcclxuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGE7XHJcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XHJcblx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XHJcblx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XHJcblx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xyXG5cdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcblx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0RGVwdGhGdW5jID0gZnVuY3Rpb24gKCBkZXB0aEZ1bmMgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGRlcHRoRnVuYyApIHtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuTmV2ZXJEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5BbHdheXNEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuQUxXQVlTICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuTGVzc0RlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuTGVzc0VxdWFsRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFRIUkVFLkVxdWFsRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkVRVUFMICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuR3JlYXRlckVxdWFsRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkdFUVVBTCApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFRIUkVFLkdyZWF0ZXJEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFRIUkVFLk5vdEVxdWFsRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLk5PVEVRVUFMICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3VycmVudERlcHRoRnVuYyA9IGRlcHRoRnVuYztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0RGVwdGhUZXN0ID0gZnVuY3Rpb24gKCBkZXB0aFRlc3QgKSB7XHJcblxyXG5cdFx0aWYgKCBkZXB0aFRlc3QgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICggZGVwdGhXcml0ZSApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnREZXB0aFdyaXRlICE9PSBkZXB0aFdyaXRlICkge1xyXG5cclxuXHRcdFx0Z2wuZGVwdGhNYXNrKCBkZXB0aFdyaXRlICk7XHJcblx0XHRcdGN1cnJlbnREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q29sb3JXcml0ZSA9IGZ1bmN0aW9uICggY29sb3JXcml0ZSApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRDb2xvcldyaXRlICE9PSBjb2xvcldyaXRlICkge1xyXG5cclxuXHRcdFx0Z2wuY29sb3JNYXNrKCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlICk7XHJcblx0XHRcdGN1cnJlbnRDb2xvcldyaXRlID0gY29sb3JXcml0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0RmxpcFNpZGVkID0gZnVuY3Rpb24gKCBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcclxuXHJcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldExpbmVXaWR0aCA9IGZ1bmN0aW9uICggd2lkdGggKSB7XHJcblxyXG5cdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcclxuXHJcblx0XHRcdGdsLmxpbmVXaWR0aCggd2lkdGggKTtcclxuXHJcblx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0UG9seWdvbk9mZnNldCA9IGZ1bmN0aW9uICggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcclxuXHJcblx0XHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwb2x5Z29uT2Zmc2V0ICYmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApICkge1xyXG5cclxuXHRcdFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xyXG5cclxuXHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XHJcblx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIHNjaXNzb3JUZXN0ICkge1xyXG5cclxuXHRcdGlmICggc2Npc3NvclRlc3QgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyB0ZXh0dXJlXHJcblxyXG5cdHRoaXMuYWN0aXZlVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xTbG90ICkge1xyXG5cclxuXHRcdGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB3ZWJnbFNsb3QgPSBnbC5URVhUVVJFMCArIG1heFRleHR1cmVzIC0gMTtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90ICkge1xyXG5cclxuXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XHJcblx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5iaW5kVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF90aGlzLmFjdGl2ZVRleHR1cmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcclxuXHJcblx0XHRpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xyXG5cdFx0XHRjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF0gPSBib3VuZFRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Z2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcclxuXHRcdFx0Ym91bmRUZXh0dXJlLnRleHR1cmUgPSB3ZWJnbFRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNvbXByZXNzZWRUZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRyeSB7XHJcblxyXG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnRleEltYWdlMkQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGdsLnRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xyXG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjYXBhYmlsaXRpZXMgPSB7fTtcclxuXHJcblx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xyXG5cclxuXHRcdGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XHJcblxyXG5cdFx0Y3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xyXG5cdFx0Y3VycmVudENvbG9yV3JpdGUgPSBudWxsO1xyXG5cclxuXHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL0xlbnNGbGFyZVBsdWdpbi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgZmxhcmVzICkge1xyXG5cclxuXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cdHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xyXG5cclxuXHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xyXG5cdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcclxuXHR2YXIgaGFzVmVydGV4VGV4dHVyZTtcclxuXHJcblx0dmFyIHRlbXBUZXh0dXJlLCBvY2NsdXNpb25UZXh0dXJlO1xyXG5cclxuXHRmdW5jdGlvbiBpbml0KCkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHRcdFx0LSAxLCAtIDEsICAwLCAwLFxyXG5cdFx0XHQgMSwgLSAxLCAgMSwgMCxcclxuXHRcdFx0IDEsICAxLCAgMSwgMSxcclxuXHRcdFx0LSAxLCAgMSwgIDAsIDFcclxuXHRcdF0gKTtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcclxuXHRcdFx0MCwgMSwgMixcclxuXHRcdFx0MCwgMiwgM1xyXG5cdFx0XSApO1xyXG5cclxuXHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHR2ZXJ0ZXhCdWZmZXIgICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRlbGVtZW50QnVmZmVyICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcblx0XHQvLyB0ZXh0dXJlc1xyXG5cclxuXHRcdHRlbXBUZXh0dXJlICAgICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcblx0XHRvY2NsdXNpb25UZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xyXG5cdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCAxNiwgMTYsIDAsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG5cclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XHJcblx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxNiwgMTYsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcclxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHJcblx0XHRoYXNWZXJ0ZXhUZXh0dXJlID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKSA+IDA7XHJcblxyXG5cdFx0dmFyIHNoYWRlcjtcclxuXHJcblx0XHRpZiAoIGhhc1ZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXIgPSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2VVYgPSB1djtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSA9ICAgICAgICB2aXNpYmlsaXR5LnIgLyA5LjA7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmEgLyA5LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCJcclxuXHJcblx0XHRcdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHRcdFx0XHRcdFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXHJcblxyXG5cdFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVzdG9yZVxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9IGVsc2UgaWYgKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZmxhcmVcclxuXHJcblx0XHRcdFx0XHRcdFwifSBlbHNlIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIlxyXG5cclxuXHRcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c2hhZGVyID0ge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcclxuXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHJcblx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidlVWID0gdXY7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiXHJcblxyXG5cdFx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XHRcdFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcGluayBzcXVhcmVcclxuXHJcblx0XHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEKCBtYXAsIHZVViApLnJnYiwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZXN0b3JlXHJcblxyXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSBpZiAoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBmbGFyZVxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApLmE7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICkuYTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKS5hO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApLmE7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ID0gKCAxLjAgLSB2aXNpYmlsaXR5IC8gNC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2aXNpYmlsaXR5O1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIlxyXG5cclxuXHRcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oIHNoYWRlciApO1xyXG5cclxuXHRcdGF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdHZlcnRleDogZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCBcInBvc2l0aW9uXCIgKSxcclxuXHRcdFx0dXY6ICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwidXZcIiApXHJcblx0XHR9O1xyXG5cclxuXHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRyZW5kZXJUeXBlOiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJlbmRlclR5cGVcIiApLFxyXG5cdFx0XHRtYXA6ICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm1hcFwiICksXHJcblx0XHRcdG9jY2x1c2lvbk1hcDogICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib2NjbHVzaW9uTWFwXCIgKSxcclxuXHRcdFx0b3BhY2l0eTogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvcGFjaXR5XCIgKSxcclxuXHRcdFx0Y29sb3I6ICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJjb2xvclwiICksXHJcblx0XHRcdHNjYWxlOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NhbGVcIiApLFxyXG5cdFx0XHRyb3RhdGlvbjogICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJvdGF0aW9uXCIgKSxcclxuXHRcdFx0c2NyZWVuUG9zaXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJzY3JlZW5Qb3NpdGlvblwiIClcclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0LypcclxuXHQgKiBSZW5kZXIgbGVucyBmbGFyZXNcclxuXHQgKiBNZXRob2Q6IHJlbmRlcnMgMTZ4MTYgMHhmZjAwZmYtY29sb3JlZCBwb2ludHMgc2NhdHRlcmVkIG92ZXIgdGhlIGxpZ2h0IHNvdXJjZSBhcmVhLFxyXG5cdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXHJcblx0ICovXHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCApIHtcclxuXHJcblx0XHRpZiAoIGZsYXJlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0SGVpZ2h0IC8gdmlld3BvcnRXaWR0aCxcclxuXHRcdFx0aGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoICogMC41LFxyXG5cdFx0XHRoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodCAqIDAuNTtcclxuXHJcblx0XHR2YXIgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQsXHJcblx0XHRcdHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcclxuXHJcblx0XHR2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMCApLFxyXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpbml0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xyXG5cdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnZlcnRleCApO1xyXG5cdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XHJcblx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xyXG5cclxuXHRcdC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXHJcblx0XHQvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmlmb3Jtc1xyXG5cclxuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XHJcblx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMSApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnZlcnRleCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcblxyXG5cdFx0c3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblx0XHRnbC5kZXB0aE1hc2soIGZhbHNlICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodDtcclxuXHRcdFx0c2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XHJcblxyXG5cdFx0XHQvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cclxuXHJcblx0XHRcdHZhciBmbGFyZSA9IGZsYXJlc1sgaSBdO1xyXG5cclxuXHRcdFx0dGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEyIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMyBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTQgXSApO1xyXG5cclxuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlQcm9qZWN0aW9uKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0Ly8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xyXG5cclxuXHRcdFx0c2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICsgaGFsZlZpZXdwb3J0V2lkdGg7XHJcblx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPSBzY3JlZW5Qb3NpdGlvbi55ICogaGFsZlZpZXdwb3J0SGVpZ2h0ICsgaGFsZlZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuXHRcdFx0Ly8gc2NyZWVuIGN1bGxcclxuXHJcblx0XHRcdGlmICggaGFzVmVydGV4VGV4dHVyZSB8fCAoXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54IDwgdmlld3BvcnRXaWR0aCAmJlxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPiAwICYmXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0SGVpZ2h0ICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHNhdmUgY3VycmVudCBSR0IgdG8gdGVtcCB0ZXh0dXJlXHJcblxyXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xyXG5cdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgcGluayBxdWFkXHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMCApO1xyXG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcclxuXHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRcdFx0c3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXHJcblxyXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcclxuXHRcdFx0XHRnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIHJlc3RvcmUgZ3JhcGhpY3NcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAxICk7XHJcblx0XHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xyXG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gdXBkYXRlIG9iamVjdCBwb3NpdGlvbnNcclxuXHJcblx0XHRcdFx0ZmxhcmUucG9zaXRpb25TY3JlZW4uY29weSggc2NyZWVuUG9zaXRpb24gKTtcclxuXHJcblx0XHRcdFx0aWYgKCBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayApIHtcclxuXHJcblx0XHRcdFx0XHRmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayggZmxhcmUgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmbGFyZS51cGRhdGVMZW5zRmxhcmVzKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIGZsYXJlc1xyXG5cclxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDIgKTtcclxuXHRcdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmbGFyZS5sZW5zRmxhcmVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzcHJpdGUub3BhY2l0eSA+IDAuMDAxICYmIHNwcml0ZS5zY2FsZSA+IDAuMDAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueCA9IHNwcml0ZS54O1xyXG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi55ID0gc3ByaXRlLnk7XHJcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnogPSBzcHJpdGUuejtcclxuXHJcblx0XHRcdFx0XHRcdHNpemUgPSBzcHJpdGUuc2l6ZSAqIHNwcml0ZS5zY2FsZSAvIHZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdFx0c2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XHJcblx0XHRcdFx0XHRcdHNjYWxlLnkgPSBzaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xyXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XHJcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xyXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRcdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIGdsXHJcblxyXG5cdFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0Z2wuZGVwdGhNYXNrKCB0cnVlICk7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCBzaGFkZXIgKSB7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcclxuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcclxuXHJcblx0XHR2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArIFwiIGZsb2F0O1xcblwiO1xyXG5cclxuXHRcdGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIHByZWZpeCArIHNoYWRlci5mcmFnbWVudFNoYWRlciApO1xyXG5cdFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvU3ByaXRlUGx1Z2luLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcHJpdGVQbHVnaW4gPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzcHJpdGVzICkge1xyXG5cclxuXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cdHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xyXG5cclxuXHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xyXG5cdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcclxuXHJcblx0dmFyIHRleHR1cmU7XHJcblxyXG5cdC8vIGRlY29tcG9zZSBtYXRyaXhXb3JsZFxyXG5cclxuXHR2YXIgc3ByaXRlUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBzcHJpdGVSb3RhdGlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblx0dmFyIHNwcml0ZVNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0ZnVuY3Rpb24gaW5pdCgpIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcblx0XHRcdC0gMC41LCAtIDAuNSwgIDAsIDAsXHJcblx0XHRcdCAgMC41LCAtIDAuNSwgIDEsIDAsXHJcblx0XHRcdCAgMC41LCAgIDAuNSwgIDEsIDEsXHJcblx0XHRcdC0gMC41LCAgIDAuNSwgIDAsIDFcclxuXHRcdF0gKTtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcclxuXHRcdFx0MCwgMSwgMixcclxuXHRcdFx0MCwgMiwgM1xyXG5cdFx0XSApO1xyXG5cclxuXHRcdHZlcnRleEJ1ZmZlciAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0YXR0cmlidXRlcyA9IHtcclxuXHRcdFx0cG9zaXRpb246XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAncG9zaXRpb24nICksXHJcblx0XHRcdHV2Olx0XHRcdFx0XHRnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICd1dicgKVxyXG5cdFx0fTtcclxuXHJcblx0XHR1bmlmb3JtcyA9IHtcclxuXHRcdFx0dXZPZmZzZXQ6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZPZmZzZXQnICksXHJcblx0XHRcdHV2U2NhbGU6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZTY2FsZScgKSxcclxuXHJcblx0XHRcdHJvdGF0aW9uOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JvdGF0aW9uJyApLFxyXG5cdFx0XHRzY2FsZTpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxyXG5cclxuXHRcdFx0Y29sb3I6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcclxuXHRcdFx0bWFwOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxyXG5cdFx0XHRvcGFjaXR5Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ29wYWNpdHknICksXHJcblxyXG5cdFx0XHRtb2RlbFZpZXdNYXRyaXg6IFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbW9kZWxWaWV3TWF0cml4JyApLFxyXG5cdFx0XHRwcm9qZWN0aW9uTWF0cml4Olx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncHJvamVjdGlvbk1hdHJpeCcgKSxcclxuXHJcblx0XHRcdGZvZ1R5cGU6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nVHlwZScgKSxcclxuXHRcdFx0Zm9nRGVuc2l0eTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dEZW5zaXR5JyApLFxyXG5cdFx0XHRmb2dOZWFyOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ05lYXInICksXHJcblx0XHRcdGZvZ0ZhcjpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0ZhcicgKSxcclxuXHRcdFx0Zm9nQ29sb3I6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nQ29sb3InICksXHJcblxyXG5cdFx0XHRhbHBoYVRlc3Q6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnYWxwaGFUZXN0JyApXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdFx0Y2FudmFzLndpZHRoID0gODtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSA4O1xyXG5cclxuXHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRcdGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcclxuXHRcdGNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIDgsIDggKTtcclxuXHJcblx0XHR0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGNhbnZhcyApO1xyXG5cdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCBzcHJpdGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcclxuXHJcblx0XHQvLyBzZXR1cCBnbFxyXG5cclxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aW5pdCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG5cdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XHJcblx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xyXG5cclxuXHRcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cdFx0c3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcclxuXHJcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xyXG5cdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcclxuXHJcblx0XHR2YXIgb2xkRm9nVHlwZSA9IDA7XHJcblx0XHR2YXIgc2NlbmVGb2dUeXBlID0gMDtcclxuXHRcdHZhciBmb2cgPSBzY2VuZS5mb2c7XHJcblxyXG5cdFx0aWYgKCBmb2cgKSB7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dOZWFyLCBmb2cubmVhciApO1xyXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRmFyLCBmb2cuZmFyICk7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xyXG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSAxO1xyXG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xyXG5cclxuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0RlbnNpdHksIGZvZy5kZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xyXG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSAyO1xyXG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMCApO1xyXG5cdFx0XHRvbGRGb2dUeXBlID0gMDtcclxuXHRcdFx0c2NlbmVGb2dUeXBlID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0c3ByaXRlLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBzcHJpdGUubWF0cml4V29ybGQgKTtcclxuXHRcdFx0c3ByaXRlLnogPSAtIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNwcml0ZXMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHJcblx0XHQvLyByZW5kZXIgYWxsIHNwcml0ZXNcclxuXHJcblx0XHR2YXIgc2NhbGUgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmFscGhhVGVzdCwgbWF0ZXJpYWwuYWxwaGFUZXN0ICk7XHJcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdHNwcml0ZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHNwcml0ZVBvc2l0aW9uLCBzcHJpdGVSb3RhdGlvbiwgc3ByaXRlU2NhbGUgKTtcclxuXHJcblx0XHRcdHNjYWxlWyAwIF0gPSBzcHJpdGVTY2FsZS54O1xyXG5cdFx0XHRzY2FsZVsgMSBdID0gc3ByaXRlU2NhbGUueTtcclxuXHJcblx0XHRcdHZhciBmb2dUeXBlID0gMDtcclxuXHJcblx0XHRcdGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcclxuXHJcblx0XHRcdFx0Zm9nVHlwZSA9IHNjZW5lRm9nVHlwZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCBmb2dUeXBlICk7XHJcblx0XHRcdFx0b2xkRm9nVHlwZSA9IGZvZ1R5cGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcclxuXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIG1hdGVyaWFsLm1hcC5yZXBlYXQueCwgbWF0ZXJpYWwubWFwLnJlcGVhdC55ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCAwLCAwICk7XHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcclxuXHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgbWF0ZXJpYWwuY29sb3IuciwgbWF0ZXJpYWwuY29sb3IuZywgbWF0ZXJpYWwuY29sb3IuYiApO1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgbWF0ZXJpYWwucm90YXRpb24gKTtcclxuXHRcdFx0Z2wudW5pZm9ybTJmdiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xyXG5cdFx0XHRzdGF0ZS5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xyXG5cdFx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuaW1hZ2UgJiYgbWF0ZXJpYWwubWFwLmltYWdlLndpZHRoICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlKCBtYXRlcmlhbC5tYXAsIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnNldFRleHR1cmUoIHRleHR1cmUsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIGdsXHJcblxyXG5cdFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHRyZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoKSB7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0dmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xyXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcclxuXHJcblx0XHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xyXG5cclxuXHRcdFx0J3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXHJcblxyXG5cdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxyXG5cdFx0XHQndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgcm90YXRpb247JyxcclxuXHRcdFx0J3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxyXG5cdFx0XHQndW5pZm9ybSB2ZWMyIHV2T2Zmc2V0OycsXHJcblx0XHRcdCd1bmlmb3JtIHZlYzIgdXZTY2FsZTsnLFxyXG5cclxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsXHJcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxyXG5cclxuXHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcclxuXHJcblx0XHRcdCd2b2lkIG1haW4oKSB7JyxcclxuXHJcblx0XHRcdFx0J3ZVViA9IHV2T2Zmc2V0ICsgdXYgKiB1dlNjYWxlOycsXHJcblxyXG5cdFx0XHRcdCd2ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICogc2NhbGU7JyxcclxuXHJcblx0XHRcdFx0J3ZlYzIgcm90YXRlZFBvc2l0aW9uOycsXHJcblx0XHRcdFx0J3JvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxyXG5cdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcclxuXHJcblx0XHRcdFx0J3ZlYzQgZmluYWxQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOycsXHJcblx0XHRcdFx0J2ZpbmFsUG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOycsXHJcblx0XHRcdFx0J2ZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0XHQnZ2xfUG9zaXRpb24gPSBmaW5hbFBvc2l0aW9uOycsXHJcblxyXG5cdFx0XHQnfSdcclxuXHJcblx0XHRdLmpvaW4oICdcXG4nICkgKTtcclxuXHJcblx0XHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBbXHJcblxyXG5cdFx0XHQncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcclxuXHJcblx0XHRcdCd1bmlmb3JtIHZlYzMgY29sb3I7JyxcclxuXHRcdFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxyXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXHJcblxyXG5cdFx0XHQndW5pZm9ybSBpbnQgZm9nVHlwZTsnLFxyXG5cdFx0XHQndW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nTmVhcjsnLFxyXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dGYXI7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXHJcblxyXG5cdFx0XHQndmFyeWluZyB2ZWMyIHZVVjsnLFxyXG5cclxuXHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxyXG5cclxuXHRcdFx0XHQndmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXHJcblxyXG5cdFx0XHRcdCdpZiAoIHRleHR1cmUuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7JyxcclxuXHJcblx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxyXG5cclxuXHRcdFx0XHQnaWYgKCBmb2dUeXBlID4gMCApIHsnLFxyXG5cclxuXHRcdFx0XHRcdCdmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7JyxcclxuXHRcdFx0XHRcdCdmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcclxuXHJcblx0XHRcdFx0XHQnaWYgKCBmb2dUeXBlID09IDEgKSB7JyxcclxuXHJcblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7JyxcclxuXHJcblx0XHRcdFx0XHQnfSBlbHNlIHsnLFxyXG5cclxuXHRcdFx0XHRcdFx0J2NvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTsnLFxyXG5cdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7JyxcclxuXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcclxuXHJcblx0XHRcdFx0XHQnfScsXHJcblxyXG5cdFx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IG1peCggZ2xfRnJhZ0NvbG9yLCB2ZWM0KCBmb2dDb2xvciwgZ2xfRnJhZ0NvbG9yLncgKSwgZm9nRmFjdG9yICk7JyxcclxuXHJcblx0XHRcdFx0J30nLFxyXG5cclxuXHRcdFx0J30nXHJcblxyXG5cdFx0XS5qb2luKCAnXFxuJyApICk7XHJcblxyXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XHJcblx0XHRnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XHJcblxyXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XHJcblxyXG5cdFx0aWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiLnogLSBhLno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBiLmlkIC0gYS5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvQ3VydmVVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICovXHJcblxyXG5USFJFRS5DdXJ2ZVV0aWxzID0ge1xyXG5cclxuXHR0YW5nZW50UXVhZHJhdGljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiAoIHAxIC0gcDAgKSArIDIgKiB0ICogKCBwMiAtIHAxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFB1YXkgQmluZywgdGhhbmtzIGZvciBoZWxwaW5nIHdpdGggdGhpcyBkZXJpdmF0aXZlIVxyXG5cclxuXHR0YW5nZW50Q3ViaWNCZXppZXI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIC0gMyAqIHAwICogKCAxIC0gdCApICogKCAxIC0gdCApICArXHJcblx0XHRcdDMgKiBwMSAqICggMSAtIHQgKSAqICggMSAtIHQgKSAtIDYgKiB0ICogcDEgKiAoIDEgLSB0ICkgK1xyXG5cdFx0XHQ2ICogdCAqICBwMiAqICggMSAtIHQgKSAtIDMgKiB0ICogdCAqIHAyICtcclxuXHRcdFx0MyAqIHQgKiB0ICogcDM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRhbmdlbnRTcGxpbmU6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG5cdFx0Ly8gVG8gY2hlY2sgaWYgbXkgZm9ybXVsYXMgYXJlIGNvcnJlY3RcclxuXHJcblx0XHR2YXIgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7IFx0Ly8gZGVyaXZlZCBmcm9tIDJ0XjMg4oiSIDN0XjIgKyAxXHJcblx0XHR2YXIgaDEwID0gMyAqIHQgKiB0IC0gNCAqIHQgKyAxOyAvLyB0XjMg4oiSIDJ0XjIgKyB0XHJcblx0XHR2YXIgaDAxID0gLSA2ICogdCAqIHQgKyA2ICogdDsgXHQvLyDiiJIgMnQzICsgM3QyXHJcblx0XHR2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7XHQvLyB0MyDiiJIgdDJcclxuXHJcblx0XHRyZXR1cm4gaDAwICsgaDEwICsgaDAxICsgaDExO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBDYXRtdWxsLVJvbVxyXG5cclxuXHRpbnRlcnBvbGF0ZTogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xyXG5cclxuXHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xyXG5cdFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblx0XHR2YXIgdDIgPSB0ICogdDtcclxuXHRcdHZhciB0MyA9IHQgKiB0MjtcclxuXHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL0dlb21ldHJ5VXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkdlb21ldHJ5VXRpbHMgPSB7XHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHRtYXRyaXggPSBnZW9tZXRyeTIubWF0cml4O1xyXG5cdFx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIGdlb21ldHJ5LmNlbnRlcigpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL0ltYWdlVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIERhb3NoZW5nIE11IC8gaHR0cHM6Ly9naXRodWIuY29tL0Rhb3NoZW5nTXUvXHJcbiAqL1xyXG5cclxuVEhSRUUuSW1hZ2VVdGlscyA9IHtcclxuXHJcblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcclxuXHJcblx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xyXG5cclxuXHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCB1cmxzLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUgaXMgYmVpbmcgZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcblx0XHRpZiAoIG1hcHBpbmcgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb2FkQ29tcHJlc3NlZFRleHR1cmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxyXG5cclxuXHR9LFxyXG5cclxuXHRsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvU2NlbmVVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2NlbmVVdGlscyA9IHtcclxuXHJcblx0Y3JlYXRlTXVsdGlNYXRlcmlhbE9iamVjdDogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWxzICkge1xyXG5cclxuXHRcdHZhciBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Z3JvdXAuYWRkKCBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsc1sgaSBdICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdyb3VwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZXRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XHJcblxyXG5cdFx0Y2hpbGQuYXBwbHlNYXRyaXgoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0cGFyZW50LnJlbW92ZSggY2hpbGQgKTtcclxuXHRcdHNjZW5lLmFkZCggY2hpbGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xyXG5cclxuXHRcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0bWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0Y2hpbGQuYXBwbHlNYXRyaXgoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcclxuXHRcdHBhcmVudC5hZGQoIGNoaWxkICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvU2hhcGVVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICovXHJcblxyXG5USFJFRS5TaGFwZVV0aWxzID0ge1xyXG5cclxuXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXHJcblxyXG5cdGFyZWE6IGZ1bmN0aW9uICggY29udG91ciApIHtcclxuXHJcblx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cdFx0dmFyIGEgPSAwLjA7XHJcblxyXG5cdFx0Zm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcclxuXHJcblx0XHRcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhICogMC41O1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmlhbmd1bGF0ZTogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xyXG5cdFx0ICogZmxpcGNvZGUuY29tIGJ5IEpvaG4gVy4gUmF0Y2xpZmYgIC8vIEp1bHkgMjIsIDIwMDBcclxuXHRcdCAqIFNlZSBvcmlnaW5hbCBjb2RlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGhlcmU6XHJcblx0XHQgKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXHJcblx0XHQgKlxyXG5cdFx0ICogcG9ydGVkIHRvIGFjdGlvbnNjcmlwdCBieSBaZXZhbiBSb3NzZXJcclxuXHRcdCAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxyXG5cdFx0ICpcclxuXHRcdCAqIHBvcnRlZCB0byBqYXZhc2NyaXB0IGJ5IEpvc2h1YSBLb29cclxuXHRcdCAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuXHRcdCAqXHJcblx0XHQgKi9cclxuXHJcblx0XHRmdW5jdGlvbiBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBuLCB2ZXJ0cyApIHtcclxuXHJcblx0XHRcdHZhciBwO1xyXG5cdFx0XHR2YXIgYXgsIGF5LCBieCwgYnk7XHJcblx0XHRcdHZhciBjeCwgY3ksIHB4LCBweTtcclxuXHJcblx0XHRcdGF4ID0gY29udG91clsgdmVydHNbIHUgXSBdLng7XHJcblx0XHRcdGF5ID0gY29udG91clsgdmVydHNbIHUgXSBdLnk7XHJcblxyXG5cdFx0XHRieCA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS54O1xyXG5cdFx0XHRieSA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS55O1xyXG5cclxuXHRcdFx0Y3ggPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueDtcclxuXHRcdFx0Y3kgPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueTtcclxuXHJcblx0XHRcdGlmICggTnVtYmVyLkVQU0lMT04gPiAoICggKCBieCAtIGF4ICkgKiAoIGN5IC0gYXkgKSApIC0gKCAoIGJ5IC0gYXkgKSAqICggY3ggLSBheCApICkgKSApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdHZhciBhWCwgYVksIGJYLCBiWSwgY1gsIGNZO1xyXG5cdFx0XHR2YXIgYXB4LCBhcHksIGJweCwgYnB5LCBjcHgsIGNweTtcclxuXHRcdFx0dmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XHJcblxyXG5cdFx0XHRhWCA9IGN4IC0gYng7ICBhWSA9IGN5IC0gYnk7XHJcblx0XHRcdGJYID0gYXggLSBjeDsgIGJZID0gYXkgLSBjeTtcclxuXHRcdFx0Y1ggPSBieCAtIGF4OyAgY1kgPSBieSAtIGF5O1xyXG5cclxuXHRcdFx0Zm9yICggcCA9IDA7IHAgPCBuOyBwICsrICkge1xyXG5cclxuXHRcdFx0XHRweCA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS54O1xyXG5cdFx0XHRcdHB5ID0gY29udG91clsgdmVydHNbIHAgXSBdLnk7XHJcblxyXG5cdFx0XHRcdGlmICggKCAoIHB4ID09PSBheCApICYmICggcHkgPT09IGF5ICkgKSB8fFxyXG5cdFx0XHRcdFx0ICggKCBweCA9PT0gYnggKSAmJiAoIHB5ID09PSBieSApICkgfHxcclxuXHRcdFx0XHRcdCAoICggcHggPT09IGN4ICkgJiYgKCBweSA9PT0gY3kgKSApIClcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRhcHggPSBweCAtIGF4OyAgYXB5ID0gcHkgLSBheTtcclxuXHRcdFx0XHRicHggPSBweCAtIGJ4OyAgYnB5ID0gcHkgLSBieTtcclxuXHRcdFx0XHRjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcclxuXHJcblx0XHRcdFx0Ly8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xyXG5cclxuXHRcdFx0XHRhQ1JPU1NicCA9IGFYICogYnB5IC0gYVkgKiBicHg7XHJcblx0XHRcdFx0Y0NST1NTYXAgPSBjWCAqIGFweSAtIGNZICogYXB4O1xyXG5cdFx0XHRcdGJDUk9TU2NwID0gYlggKiBjcHkgLSBiWSAqIGNweDtcclxuXHJcblx0XHRcdFx0aWYgKCAoIGFDUk9TU2JwID49IC0gTnVtYmVyLkVQU0lMT04gKSAmJiAoIGJDUk9TU2NwID49IC0gTnVtYmVyLkVQU0lMT04gKSAmJiAoIGNDUk9TU2FwID49IC0gTnVtYmVyLkVQU0lMT04gKSApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB0YWtlcyBpbiBhbiBjb250b3VyIGFycmF5IGFuZCByZXR1cm5zXHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY29udG91ciwgaW5kaWNlcyApIHtcclxuXHJcblx0XHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIG4gPCAzICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sXHJcblx0XHRcdFx0dmVydHMgPSBbXSxcclxuXHRcdFx0XHR2ZXJ0SW5kaWNlcyA9IFtdO1xyXG5cclxuXHRcdFx0Lyogd2Ugd2FudCBhIGNvdW50ZXItY2xvY2t3aXNlIHBvbHlnb24gaW4gdmVydHMgKi9cclxuXHJcblx0XHRcdHZhciB1LCB2LCB3O1xyXG5cclxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZVV0aWxzLmFyZWEoIGNvbnRvdXIgKSA+IDAuMCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2ICsrICkgdmVydHNbIHYgXSA9IHY7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gKCBuIC0gMSApIC0gdjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBudiA9IG47XHJcblxyXG5cdFx0XHQvKiAgcmVtb3ZlIG52IC0gMiB2ZXJ0aWNlcywgY3JlYXRpbmcgMSB0cmlhbmdsZSBldmVyeSB0aW1lICovXHJcblxyXG5cdFx0XHR2YXIgY291bnQgPSAyICogbnY7ICAgLyogZXJyb3IgZGV0ZWN0aW9uICovXHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xyXG5cclxuXHRcdFx0XHQvKiBpZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiAqL1xyXG5cclxuXHRcdFx0XHRpZiAoICggY291bnQgLS0gKSA8PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdC8vKiogVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXHJcblxyXG5cdFx0XHRcdFx0Ly90aHJvdyAoIFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIgKTtcclxuXHRcdFx0XHRcdC8vcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHQvLyBTb21ldGltZXMgd2FybmluZyBpcyBmaW5lLCBlc3BlY2lhbGx5IHBvbHlnb25zIGFyZSB0cmlhbmd1bGF0ZWQgaW4gcmV2ZXJzZS5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlVXRpbHM6IFVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uISBpbiB0cmlhbmd1bGF0ZSgpJyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcclxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0LyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXHJcblxyXG5cdFx0XHRcdHUgPSB2OyBcdCBcdGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cclxuXHRcdFx0XHR2ID0gdSArIDE7ICBpZiAoIG52IDw9IHYgKSB2ID0gMDsgICAgIC8qIG5ldyB2ICAgICovXHJcblx0XHRcdFx0dyA9IHYgKyAxOyAgaWYgKCBudiA8PSB3ICkgdyA9IDA7ICAgICAvKiBuZXh0ICAgICAqL1xyXG5cclxuXHRcdFx0XHRpZiAoIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG52LCB2ZXJ0cyApICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBhLCBiLCBjLCBzLCB0O1xyXG5cclxuXHRcdFx0XHRcdC8qIHRydWUgbmFtZXMgb2YgdGhlIHZlcnRpY2VzICovXHJcblxyXG5cdFx0XHRcdFx0YSA9IHZlcnRzWyB1IF07XHJcblx0XHRcdFx0XHRiID0gdmVydHNbIHYgXTtcclxuXHRcdFx0XHRcdGMgPSB2ZXJ0c1sgdyBdO1xyXG5cclxuXHRcdFx0XHRcdC8qIG91dHB1dCBUcmlhbmdsZSAqL1xyXG5cclxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBbIGNvbnRvdXJbIGEgXSxcclxuXHRcdFx0XHRcdFx0Y29udG91clsgYiBdLFxyXG5cdFx0XHRcdFx0XHRjb250b3VyWyBjIF0gXSApO1xyXG5cclxuXHJcblx0XHRcdFx0XHR2ZXJ0SW5kaWNlcy5wdXNoKCBbIHZlcnRzWyB1IF0sIHZlcnRzWyB2IF0sIHZlcnRzWyB3IF0gXSApO1xyXG5cclxuXHRcdFx0XHRcdC8qIHJlbW92ZSB2IGZyb20gdGhlIHJlbWFpbmluZyBwb2x5Z29uICovXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggcyA9IHYsIHQgPSB2ICsgMTsgdCA8IG52OyBzICsrLCB0ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmVydHNbIHMgXSA9IHZlcnRzWyB0IF07XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG52IC0tO1xyXG5cclxuXHRcdFx0XHRcdC8qIHJlc2V0IGVycm9yIGRldGVjdGlvbiBjb3VudGVyICovXHJcblxyXG5cdFx0XHRcdFx0Y291bnQgPSAyICogbnY7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKSgpLFxyXG5cclxuXHR0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnUHQxLCBpblNlZ1B0MiwgaW5PdGhlclB0ICkge1xyXG5cclxuXHRcdFx0Ly8gaW5PdGhlclB0IG5lZWRzIHRvIGJlIGNvbGxpbmVhciB0byB0aGUgaW5TZWdtZW50XHJcblx0XHRcdGlmICggaW5TZWdQdDEueCAhPT0gaW5TZWdQdDIueCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpblNlZ1B0MS54IDwgaW5TZWdQdDIueCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0MS54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0Mi54ICkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0Mi54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0MS54ICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpblNlZ1B0MS55IDwgaW5TZWdQdDIueSApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0MS55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0Mi55ICkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0Mi55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0MS55ICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkge1xyXG5cclxuXHRcdFx0dmFyIHNlZzFkeCA9IGluU2VnMVB0Mi54IC0gaW5TZWcxUHQxLngsICAgc2VnMWR5ID0gaW5TZWcxUHQyLnkgLSBpblNlZzFQdDEueTtcclxuXHRcdFx0dmFyIHNlZzJkeCA9IGluU2VnMlB0Mi54IC0gaW5TZWcyUHQxLngsICAgc2VnMmR5ID0gaW5TZWcyUHQyLnkgLSBpblNlZzJQdDEueTtcclxuXHJcblx0XHRcdHZhciBzZWcxc2VnMmR4ID0gaW5TZWcxUHQxLnggLSBpblNlZzJQdDEueDtcclxuXHRcdFx0dmFyIHNlZzFzZWcyZHkgPSBpblNlZzFQdDEueSAtIGluU2VnMlB0MS55O1xyXG5cclxuXHRcdFx0dmFyIGxpbWl0XHRcdD0gc2VnMWR5ICogc2VnMmR4IC0gc2VnMWR4ICogc2VnMmR5O1xyXG5cdFx0XHR2YXIgcGVycFNlZzFcdD0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBsaW1pdCApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxyXG5cclxuXHRcdFx0XHR2YXIgcGVycFNlZzI7XHJcblx0XHRcdFx0aWYgKCBsaW1pdCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxIDwgMCApIHx8ICggcGVycFNlZzEgPiBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XHJcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPCAwICkgfHwgKCBwZXJwU2VnMiA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xyXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcyID4gMCApIHx8ICggcGVycFNlZzIgPCBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBpLmUuIHRvIHJlZHVjZSByb3VuZGluZyBlcnJvcnNcclxuXHRcdFx0XHQvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMxP1xyXG5cdFx0XHRcdGlmICggcGVycFNlZzIgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXHJcblx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggcGVycFNlZzIgPT09IGxpbWl0ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxyXG5cdFx0XHRcdFx0XHQgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApIClcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQyIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMyP1xyXG5cdFx0XHRcdGlmICggcGVycFNlZzEgPT09IDAgKVx0XHRyZXR1cm4gWyBpblNlZzJQdDEgXTtcclxuXHRcdFx0XHRpZiAoIHBlcnBTZWcxID09PSBsaW1pdCApXHRyZXR1cm4gWyBpblNlZzJQdDIgXTtcclxuXHJcblx0XHRcdFx0Ly8gcmV0dXJuIHJlYWwgaW50ZXJzZWN0aW9uIHBvaW50XHJcblx0XHRcdFx0dmFyIGZhY3RvclNlZzEgPSBwZXJwU2VnMiAvIGxpbWl0O1xyXG5cdFx0XHRcdHJldHVyblx0WyB7IHg6IGluU2VnMVB0MS54ICsgZmFjdG9yU2VnMSAqIHNlZzFkeCxcclxuXHRcdFx0XHRcdFx0XHR5OiBpblNlZzFQdDEueSArIGZhY3RvclNlZzEgKiBzZWcxZHkgfSBdO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXHJcblx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxICE9PSAwICkgfHxcclxuXHRcdFx0XHRcdCAoIHNlZzJkeSAqIHNlZzFzZWcyZHggIT09IHNlZzJkeCAqIHNlZzFzZWcyZHkgKSApIFx0XHRcdHJldHVybiBbXTtcclxuXHJcblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIG9yIGRlZ2VuZXJhdGVcclxuXHRcdFx0XHR2YXIgc2VnMVB0ID0gKCAoIHNlZzFkeCA9PT0gMCApICYmICggc2VnMWR5ID09PSAwICkgKTtcdC8vIHNlZ21lbnQxIGlzIGp1c3QgYSBwb2ludD9cclxuXHRcdFx0XHR2YXIgc2VnMlB0ID0gKCAoIHNlZzJkeCA9PT0gMCApICYmICggc2VnMmR5ID09PSAwICkgKTtcdC8vIHNlZ21lbnQyIGlzIGp1c3QgYSBwb2ludD9cclxuXHRcdFx0XHQvLyBib3RoIHNlZ21lbnRzIGFyZSBwb2ludHNcclxuXHRcdFx0XHRpZiAoIHNlZzFQdCAmJiBzZWcyUHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIGluU2VnMVB0MS54ICE9PSBpblNlZzJQdDEueCApIHx8XHJcblx0XHRcdFx0XHRcdCAoIGluU2VnMVB0MS55ICE9PSBpblNlZzJQdDEueSApIClcdFx0cmV0dXJuIFtdO1x0Ly8gdGhleSBhcmUgZGlzdGluY3QgIHBvaW50c1xyXG5cdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQxIF07ICAgICAgICAgICAgICAgICBcdFx0XHRcdFx0XHQvLyB0aGV5IGFyZSB0aGUgc2FtZSBwb2ludFxyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gc2VnbWVudCMxICBpcyBhIHNpbmdsZSBwb2ludFxyXG5cdFx0XHRcdGlmICggc2VnMVB0ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5TZWcxUHQxICkgKVx0XHRyZXR1cm4gW107XHRcdC8vIGJ1dCBub3QgaW4gc2VnbWVudCMyXHJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHNlZ21lbnQjMiAgaXMgYSBzaW5nbGUgcG9pbnRcclxuXHRcdFx0XHRpZiAoIHNlZzJQdCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApIClcdFx0cmV0dXJuIFtdO1x0XHQvLyBidXQgbm90IGluIHNlZ21lbnQjMVxyXG5cdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcyUHQxIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIHNlZ21lbnRzLCB3aGljaCBtaWdodCBvdmVybGFwXHJcblx0XHRcdFx0dmFyIHNlZzFtaW4sIHNlZzFtYXgsIHNlZzFtaW5WYWwsIHNlZzFtYXhWYWw7XHJcblx0XHRcdFx0dmFyIHNlZzJtaW4sIHNlZzJtYXgsIHNlZzJtaW5WYWwsIHNlZzJtYXhWYWw7XHJcblx0XHRcdFx0aWYgKCBzZWcxZHggIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdGhlIHNlZ21lbnRzIGFyZSBOT1Qgb24gYSB2ZXJ0aWNhbCBsaW5lXHJcblx0XHRcdFx0XHRpZiAoIGluU2VnMVB0MS54IDwgaW5TZWcxUHQyLnggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLng7XHJcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xyXG5cdFx0XHRcdFx0XHRzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLng7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBpblNlZzJQdDEueCA8IGluU2VnMlB0Mi54ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS54O1xyXG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLng7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcclxuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS54O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIG9uIGEgdmVydGljYWwgbGluZVxyXG5cdFx0XHRcdFx0aWYgKCBpblNlZzFQdDEueSA8IGluU2VnMVB0Mi55ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0MTsgc2VnMW1pblZhbCA9IGluU2VnMVB0MS55O1xyXG5cdFx0XHRcdFx0XHRzZWcxbWF4ID0gaW5TZWcxUHQyOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLnk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueTtcclxuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS55O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggaW5TZWcyUHQxLnkgPCBpblNlZzJQdDIueSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDE7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueTtcclxuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0Mjsgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi55O1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQyOyBzZWcybWluVmFsID0gaW5TZWcyUHQyLnk7XHJcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIHNlZzFtaW5WYWwgPD0gc2VnMm1pblZhbCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPCAgc2VnMm1pblZhbCApXHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPT09IHNlZzJtaW5WYWwgKVx0e1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRcdHJldHVybiBbIHNlZzJtaW4gXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApXHRyZXR1cm4gWyBzZWcybWluLCBzZWcxbWF4IF07XHJcblx0XHRcdFx0XHRyZXR1cm5cdFsgc2VnMm1pbiwgc2VnMm1heCBdO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggc2VnMW1pblZhbCA+ICBzZWcybWF4VmFsIClcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdGlmICggc2VnMW1pblZhbCA9PT0gc2VnMm1heFZhbCApXHR7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFsgc2VnMW1pbiBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzFtaW4sIHNlZzFtYXggXTtcclxuXHRcdFx0XHRcdHJldHVyblx0WyBzZWcxbWluLCBzZWcybWF4IF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZUFuZ2xlKCBpblZlcnRleCwgaW5MZWdGcm9tUHQsIGluTGVnVG9QdCwgaW5PdGhlclB0ICkge1xyXG5cclxuXHRcdFx0Ly8gVGhlIG9yZGVyIG9mIGxlZ3MgaXMgaW1wb3J0YW50XHJcblxyXG5cdFx0XHQvLyB0cmFuc2xhdGlvbiBvZiBhbGwgcG9pbnRzLCBzbyB0aGF0IFZlcnRleCBpcyBhdCAoMCwwKVxyXG5cdFx0XHR2YXIgbGVnRnJvbVB0WFx0PSBpbkxlZ0Zyb21QdC54IC0gaW5WZXJ0ZXgueCwgIGxlZ0Zyb21QdFlcdD0gaW5MZWdGcm9tUHQueSAtIGluVmVydGV4Lnk7XHJcblx0XHRcdHZhciBsZWdUb1B0WFx0PSBpbkxlZ1RvUHQueFx0LSBpblZlcnRleC54LCAgbGVnVG9QdFlcdFx0PSBpbkxlZ1RvUHQueVx0LSBpblZlcnRleC55O1xyXG5cdFx0XHR2YXIgb3RoZXJQdFhcdD0gaW5PdGhlclB0LnhcdC0gaW5WZXJ0ZXgueCwgIG90aGVyUHRZXHRcdD0gaW5PdGhlclB0LnlcdC0gaW5WZXJ0ZXgueTtcclxuXHJcblx0XHRcdC8vIG1haW4gYW5nbGUgPjA6IDwgMTgwIGRlZy47IDA6IDE4MCBkZWcuOyA8MDogPiAxODAgZGVnLlxyXG5cdFx0XHR2YXIgZnJvbTJ0b0FuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcclxuXHRcdFx0dmFyIGZyb20yb3RoZXJBbmdsZVx0PSBsZWdGcm9tUHRYICogb3RoZXJQdFkgLSBsZWdGcm9tUHRZICogb3RoZXJQdFg7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBmcm9tMnRvQW5nbGUgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHQvLyBhbmdsZSAhPSAxODAgZGVnLlxyXG5cclxuXHRcdFx0XHR2YXIgb3RoZXIydG9BbmdsZVx0XHQ9IG90aGVyUHRYICogbGVnVG9QdFkgLSBvdGhlclB0WSAqIGxlZ1RvUHRYO1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IFwiICsgZnJvbTJ0b0FuZ2xlICsgXCIsIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICsgXCIsIG90aGVyMnRvOiBcIiArIG90aGVyMnRvQW5nbGUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBmcm9tMnRvQW5nbGUgPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIG1haW4gYW5nbGUgPCAxODAgZGVnLlxyXG5cdFx0XHRcdFx0cmV0dXJuXHQoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSAmJiAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbWFpbiBhbmdsZSA+IDE4MCBkZWcuXHJcblx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApIHx8ICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gYW5nbGUgPT0gMTgwIGRlZy5cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJmcm9tMnRvOiAxODAgZGVnLiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgICk7XHJcblx0XHRcdFx0cmV0dXJuXHQoIGZyb20yb3RoZXJBbmdsZSA+IDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApIHtcclxuXHJcblx0XHRcdHZhciBzaGFwZSA9IGNvbnRvdXIuY29uY2F0KCk7IC8vIHdvcmsgb24gdGhpcyBzaGFwZVxyXG5cdFx0XHR2YXIgaG9sZTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGlzQ3V0TGluZUluc2lkZUFuZ2xlcyggaW5TaGFwZUlkeCwgaW5Ib2xlSWR4ICkge1xyXG5cclxuXHRcdFx0XHQvLyBDaGVjayBpZiBob2xlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBzaGFwZSBwb2ludFxyXG5cdFx0XHRcdHZhciBsYXN0U2hhcGVJZHggPSBzaGFwZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0XHR2YXIgcHJldlNoYXBlSWR4ID0gaW5TaGFwZUlkeCAtIDE7XHJcblx0XHRcdFx0aWYgKCBwcmV2U2hhcGVJZHggPCAwIClcdFx0XHRwcmV2U2hhcGVJZHggPSBsYXN0U2hhcGVJZHg7XHJcblxyXG5cdFx0XHRcdHZhciBuZXh0U2hhcGVJZHggPSBpblNoYXBlSWR4ICsgMTtcclxuXHRcdFx0XHRpZiAoIG5leHRTaGFwZUlkeCA+IGxhc3RTaGFwZUlkeCApXHRuZXh0U2hhcGVJZHggPSAwO1xyXG5cclxuXHRcdFx0XHR2YXIgaW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIHNoYXBlWyBpblNoYXBlSWR4IF0sIHNoYXBlWyBwcmV2U2hhcGVJZHggXSwgc2hhcGVbIG5leHRTaGFwZUlkeCBdLCBob2xlWyBpbkhvbGVJZHggXSApO1xyXG5cdFx0XHRcdGlmICggISBpbnNpZGVBbmdsZSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKFNoYXBlKTogXCIgKyBpblNoYXBlSWR4ICsgXCIsIFBvaW50OiBcIiArIGhvbGVbaW5Ib2xlSWR4XS54ICsgXCIvXCIgKyBob2xlW2luSG9sZUlkeF0ueSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBDaGVjayBpZiBzaGFwZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgaG9sZSBwb2ludFxyXG5cdFx0XHRcdHZhciBsYXN0SG9sZUlkeCA9IGhvbGUubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdFx0dmFyIHByZXZIb2xlSWR4ID0gaW5Ib2xlSWR4IC0gMTtcclxuXHRcdFx0XHRpZiAoIHByZXZIb2xlSWR4IDwgMCApXHRcdFx0cHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcclxuXHJcblx0XHRcdFx0dmFyIG5leHRIb2xlSWR4ID0gaW5Ib2xlSWR4ICsgMTtcclxuXHRcdFx0XHRpZiAoIG5leHRIb2xlSWR4ID4gbGFzdEhvbGVJZHggKVx0bmV4dEhvbGVJZHggPSAwO1xyXG5cclxuXHRcdFx0XHRpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggaG9sZVsgaW5Ib2xlSWR4IF0sIGhvbGVbIHByZXZIb2xlSWR4IF0sIGhvbGVbIG5leHRIb2xlSWR4IF0sIHNoYXBlWyBpblNoYXBlSWR4IF0gKTtcclxuXHRcdFx0XHRpZiAoICEgaW5zaWRlQW5nbGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm5cdHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBpbnRlcnNlY3RzU2hhcGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xyXG5cclxuXHRcdFx0XHQvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBzaGFwZSBlZGdlc1xyXG5cdFx0XHRcdHZhciBzSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XHJcblx0XHRcdFx0Zm9yICggc0lkeCA9IDA7IHNJZHggPCBzaGFwZS5sZW5ndGg7IHNJZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bmV4dElkeCA9IHNJZHggKyAxOyBuZXh0SWR4ICU9IHNoYXBlLmxlbmd0aDtcclxuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbIHNJZHggXSwgc2hhcGVbIG5leHRJZHggXSwgdHJ1ZSApO1xyXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGluZGVwSG9sZXMgPSBbXTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNIb2xlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcclxuXHJcblx0XHRcdFx0Ly8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggaG9sZSBlZGdlc1xyXG5cdFx0XHRcdHZhciBpaElkeCwgY2hrSG9sZSxcclxuXHRcdFx0XHRcdGhJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcclxuXHRcdFx0XHRmb3IgKCBpaElkeCA9IDA7IGloSWR4IDwgaW5kZXBIb2xlcy5sZW5ndGg7IGloSWR4ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNoa0hvbGUgPSBob2xlc1sgaW5kZXBIb2xlc1sgaWhJZHggXV07XHJcblx0XHRcdFx0XHRmb3IgKCBoSWR4ID0gMDsgaElkeCA8IGNoa0hvbGUubGVuZ3RoOyBoSWR4ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bmV4dElkeCA9IGhJZHggKyAxOyBuZXh0SWR4ICU9IGNoa0hvbGUubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIGNoa0hvbGVbIGhJZHggXSwgY2hrSG9sZVsgbmV4dElkeCBdLCB0cnVlICk7XHJcblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXHJcblx0XHRcdFx0c2hhcGVQdCwgaG9sZVB0LFxyXG5cdFx0XHRcdGhvbGVJZHgsIGN1dEtleSwgZmFpbGVkQ3V0cyA9IFtdLFxyXG5cdFx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxyXG5cdFx0XHRcdHRtcEhvbGUxLCB0bXBIb2xlMjtcclxuXHJcblx0XHRcdGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0aW5kZXBIb2xlcy5wdXNoKCBoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbWluU2hhcGVJbmRleCA9IDA7XHJcblx0XHRcdHZhciBjb3VudGVyID0gaW5kZXBIb2xlcy5sZW5ndGggKiAyO1xyXG5cdFx0XHR3aGlsZSAoIGluZGVwSG9sZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0Y291bnRlciAtLTtcclxuXHRcdFx0XHRpZiAoIGNvdW50ZXIgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHNlYXJjaCBmb3Igc2hhcGUtdmVydGV4IGFuZCBob2xlLXZlcnRleCxcclxuXHRcdFx0XHQvLyB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xyXG5cdFx0XHRcdGZvciAoIHNoYXBlSW5kZXggPSBtaW5TaGFwZUluZGV4OyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoOyBzaGFwZUluZGV4ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xyXG5cdFx0XHRcdFx0aG9sZUluZGV4XHQ9IC0gMTtcclxuXHJcblx0XHRcdFx0XHQvLyBzZWFyY2ggZm9yIGhvbGUgd2hpY2ggY2FuIGJlIHJlYWNoZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGhvbGVJZHggPSBpbmRlcEhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IG11bHRpcGxlIGNoZWNrc1xyXG5cdFx0XHRcdFx0XHRjdXRLZXkgPSBzaGFwZVB0LnggKyBcIjpcIiArIHNoYXBlUHQueSArIFwiOlwiICsgaG9sZUlkeDtcclxuXHRcdFx0XHRcdFx0aWYgKCBmYWlsZWRDdXRzWyBjdXRLZXkgXSAhPT0gdW5kZWZpbmVkIClcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdGhvbGUgPSBob2xlc1sgaG9sZUlkeCBdO1xyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaDIgPSAwOyBoMiA8IGhvbGUubGVuZ3RoOyBoMiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aG9sZVB0ID0gaG9sZVsgaDIgXTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoICEgaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBzaGFwZUluZGV4LCBoMiApIClcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzU2hhcGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApXHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c0hvbGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApXHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRob2xlSW5kZXggPSBoMjtcclxuXHRcdFx0XHRcdFx0XHRpbmRlcEhvbGVzLnNwbGljZSggaCwgMSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0bXBTaGFwZTEgPSBzaGFwZS5zbGljZSggMCwgc2hhcGVJbmRleCArIDEgKTtcclxuXHRcdFx0XHRcdFx0XHR0bXBTaGFwZTIgPSBzaGFwZS5zbGljZSggc2hhcGVJbmRleCApO1xyXG5cdFx0XHRcdFx0XHRcdHRtcEhvbGUxID0gaG9sZS5zbGljZSggaG9sZUluZGV4ICk7XHJcblx0XHRcdFx0XHRcdFx0dG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXggKyAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHNoYXBlID0gdG1wU2hhcGUxLmNvbmNhdCggdG1wSG9sZTEgKS5jb25jYXQoIHRtcEhvbGUyICkuY29uY2F0KCB0bXBTaGFwZTIgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0bWluU2hhcGVJbmRleCA9IHNoYXBlSW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcclxuXHRcdFx0XHRcdFx0XHQvLyBnbG9iX0N1dExpbmVzLnB1c2goIFsgc2hhcGVQdCwgaG9sZVB0IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmICggaG9sZUluZGV4ID49IDAgKVx0YnJlYWs7XHRcdC8vIGhvbGUtdmVydGV4IGZvdW5kXHJcblxyXG5cdFx0XHRcdFx0XHRmYWlsZWRDdXRzWyBjdXRLZXkgXSA9IHRydWU7XHRcdFx0Ly8gcmVtZW1iZXIgZmFpbHVyZVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggaG9sZUluZGV4ID49IDAgKVx0YnJlYWs7XHRcdC8vIGhvbGUtdmVydGV4IGZvdW5kXHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzaGFwZTsgXHRcdFx0Lyogc2hhcGUgd2l0aCBubyBob2xlcyAqL1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0dmFyIGksIGlsLCBmLCBmYWNlLFxyXG5cdFx0XHRrZXksIGluZGV4LFxyXG5cdFx0XHRhbGxQb2ludHNNYXAgPSB7fTtcclxuXHJcblx0XHQvLyBUbyBtYWludGFpbiByZWZlcmVuY2UgdG8gb2xkIHNoYXBlLCBvbmUgbXVzdCBtYXRjaCBjb29yZGluYXRlcywgb3Igb2Zmc2V0IHRoZSBpbmRpY2VzIGZyb20gb3JpZ2luYWwgYXJyYXlzLiBJdCdzIHByb2JhYmx5IGVhc2llciB0byBkbyB0aGUgZmlyc3QuXHJcblxyXG5cdFx0dmFyIGFsbHBvaW50cyA9IGNvbnRvdXIuY29uY2F0KCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIGFsbHBvaW50cywgaG9sZXNbIGggXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCBcImFsbHBvaW50c1wiLGFsbHBvaW50cywgYWxscG9pbnRzLmxlbmd0aCApO1xyXG5cclxuXHRcdC8vIHByZXBhcmUgYWxsIHBvaW50cyBtYXBcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBhbGxwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRrZXkgPSBhbGxwb2ludHNbIGkgXS54ICsgXCI6XCIgKyBhbGxwb2ludHNbIGkgXS55O1xyXG5cclxuXHRcdFx0aWYgKCBhbGxQb2ludHNNYXBbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5TaGFwZTogRHVwbGljYXRlIHBvaW50XCIsIGtleSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWxsUG9pbnRzTWFwWyBrZXkgXSA9IGk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlbW92ZSBob2xlcyBieSBjdXR0aW5nIHBhdGhzIHRvIGhvbGVzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgc2hhcGVcclxuXHRcdHZhciBzaGFwZVdpdGhvdXRIb2xlcyA9IHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApO1xyXG5cclxuXHRcdHZhciB0cmlhbmdsZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlKCBzaGFwZVdpdGhvdXRIb2xlcywgZmFsc2UgKTsgLy8gVHJ1ZSByZXR1cm5zIGluZGljZXMgZm9yIHBvaW50cyBvZiBzcG9vbGVkIHNoYXBlXHJcblx0XHQvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xyXG5cclxuXHRcdC8vIGNoZWNrIGFsbCBmYWNlIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdHJpYW5nbGVzWyBpIF07XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMDsgZiA8IDM7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcclxuXHJcblx0XHRcdFx0aW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZVsgZiBdID0gaW5kZXg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoKTtcclxuXHJcblx0fSxcclxuXHJcblx0aXNDbG9ja1dpc2U6IGZ1bmN0aW9uICggcHRzICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5TaGFwZVV0aWxzLmFyZWEoIHB0cyApIDwgMDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXHJcblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxyXG5cclxuXHQvLyBRdWFkIEJlemllciBGdW5jdGlvbnNcclxuXHJcblx0YjI6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGIycDAoIHQsIHAgKSB7XHJcblxyXG5cdFx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBiMnAxKCB0LCBwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjJwMiggdCwgcCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0ICogdCAqIHA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYjJwMCggdCwgcDAgKSArIGIycDEoIHQsIHAxICkgKyBiMnAyKCB0LCBwMiApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpLFxyXG5cclxuXHQvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXHJcblxyXG5cdGIzOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmdW5jdGlvbiBiM3AwKCB0LCBwICkge1xyXG5cclxuXHRcdFx0dmFyIGsgPSAxIC0gdDtcclxuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIHA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGIzcDEoIHQsIHAgKSB7XHJcblxyXG5cdFx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0XHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGIzcDIoIHQsIHAgKSB7XHJcblxyXG5cdFx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0XHRyZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGIzcDMoIHQsIHAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYjNwMCggdCwgcDAgKSArIGIzcDEoIHQsIHAxICkgKyBiM3AyKCB0LCBwMiApICsgYjNwMyggdCwgcDMgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9ICkoKVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9hdWRpby9BdWRpby5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQXVkaW8gPSBmdW5jdGlvbiAoIGxpc3RlbmVyICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdBdWRpbyc7XHJcblxyXG5cdHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XHJcblx0dGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XHJcblx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xyXG5cclxuXHR0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcclxuXHR0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcclxuXHJcblx0dGhpcy5hdXRvcGxheSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnN0YXJ0VGltZSA9IDA7XHJcblx0dGhpcy5wbGF5YmFja1JhdGUgPSAxO1xyXG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvO1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIGZpbGUgKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5vcGVuKCAnR0VUJywgZmlsZSwgdHJ1ZSApO1xyXG5cdHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuXHRyZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICggZSApIHtcclxuXHJcblx0XHRzY29wZS5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YSggdGhpcy5yZXNwb25zZSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRzY29wZS5zb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5hdXRvcGxheSApIHNjb3BlLnBsYXkoKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH07XHJcblx0cmVxdWVzdC5zZW5kKCk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiBBdWRpbyBpcyBhbHJlYWR5IHBsYXlpbmcuJyApO1xyXG5cdFx0cmV0dXJuO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG5cdHNvdXJjZS5idWZmZXIgPSB0aGlzLnNvdXJjZS5idWZmZXI7XHJcblx0c291cmNlLmxvb3AgPSB0aGlzLnNvdXJjZS5sb29wO1xyXG5cdHNvdXJjZS5vbmVuZGVkID0gdGhpcy5zb3VyY2Uub25lbmRlZDtcclxuXHRzb3VyY2Uuc3RhcnQoIDAsIHRoaXMuc3RhcnRUaW1lICk7XHJcblx0c291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxuXHR0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cclxuXHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuc291cmNlLnN0b3AoKTtcclxuXHR0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xyXG5cdHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0aWYgKCB0aGlzLmZpbHRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcblx0XHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLnBhbm5lciApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMucGFubmVyICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0aWYgKCB0aGlzLmZpbHRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcblx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLnBhbm5lciApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMucGFubmVyICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcclxuXHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XHJcblx0XHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmZpbHRlciA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMuZmlsdGVyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xyXG5cclxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5vbkVuZGVkID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLnNvdXJjZS5sb29wID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldExvb3AgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLnNvdXJjZS5sb29wO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcblx0XHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW9MaXN0ZW5lci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XHJcblxyXG5cdHRoaXMuY29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpb0xpc3RlbmVyO1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblx0dmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dmFyIG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XHJcblx0XHR2YXIgdXAgPSB0aGlzLnVwO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcclxuXHJcblx0XHRvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XHJcblx0XHRsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3RcclxuICpcclxuICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xyXG4gKiAuZ2V0UG9pbnQodCksIGdldFRhbmdlbnQodClcclxuICogLmdldFBvaW50QXQodSksIGdldFRhZ2VudEF0KHUpXHJcbiAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXHJcbiAqIC5nZXRMZW5ndGgoKVxyXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXHJcbiAqXHJcbiAqIFRoaXMgZm9sbG93aW5nIGNsYXNzZXMgc3ViY2xhc3NlcyBUSFJFRS5DdXJ2ZTpcclxuICpcclxuICogLS0gMmQgY2xhc3NlcyAtLVxyXG4gKiBUSFJFRS5MaW5lQ3VydmVcclxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcclxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxyXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZVxyXG4gKiBUSFJFRS5BcmNDdXJ2ZVxyXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcclxuICpcclxuICogLS0gM2QgY2xhc3NlcyAtLVxyXG4gKiBUSFJFRS5MaW5lQ3VydmUzXHJcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlM1xyXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xyXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZTNcclxuICogVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzXHJcbiAqXHJcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGhcclxuICpcclxuICoqL1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1cnZlID0gZnVuY3Rpb24gKCkge1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkN1cnZlLFxyXG5cclxuXHQvLyBWaXJ0dWFsIGJhc2UgY2xhc3MgbWV0aG9kIHRvIG92ZXJ3cml0ZSBhbmQgaW1wbGVtZW50IGluIHN1YmNsYXNzZXNcclxuXHQvL1x0LSB0IFswIC4uIDFdXHJcblxyXG5cdGdldFBvaW50OiBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLkN1cnZlOiBXYXJuaW5nLCBnZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZCFcIiApO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxyXG5cdC8vIC0gdSBbMCAuLiAxXVxyXG5cclxuXHRnZXRQb2ludEF0OiBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcclxuXHJcblx0Z2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcclxuXHJcblx0XHR2YXIgZCwgcHRzID0gW107XHJcblxyXG5cdFx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdFx0cHRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcHRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxyXG5cclxuXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xyXG5cclxuXHRcdHZhciBkLCBwdHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XHJcblxyXG5cdFx0XHRwdHMucHVzaCggdGhpcy5nZXRQb2ludEF0KCBkIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHB0cztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcclxuXHJcblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHRcdHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcclxuXHJcblx0Z2V0TGVuZ3RoczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApID8gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgOiAyMDA7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Roc1xyXG5cdFx0XHQmJiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PT0gZGl2aXNpb25zICsgMSApXHJcblx0XHRcdCYmICEgdGhpcy5uZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coIFwiY2FjaGVkXCIsIHRoaXMuY2FjaGVBcmNMZW5ndGhzICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHZhciBjYWNoZSA9IFtdO1xyXG5cdFx0dmFyIGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XHJcblx0XHR2YXIgcCwgc3VtID0gMDtcclxuXHJcblx0XHRjYWNoZS5wdXNoKCAwICk7XHJcblxyXG5cdFx0Zm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xyXG5cclxuXHRcdFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQgKCBwIC8gZGl2aXNpb25zICk7XHJcblx0XHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcclxuXHRcdFx0Y2FjaGUucHVzaCggc3VtICk7XHJcblx0XHRcdGxhc3QgPSBjdXJyZW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xyXG5cclxuXHRcdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJjTGVuZ3RoczogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHR0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpZGlzdGFudFxyXG5cclxuXHRnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR2YXIgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xyXG5cclxuXHRcdHZhciBpID0gMCwgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcclxuXHJcblx0XHRpZiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly92YXIgdGltZSA9IERhdGUubm93KCk7XHJcblxyXG5cdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcclxuXHJcblx0XHR2YXIgbG93ID0gMCwgaGlnaCA9IGlsIC0gMSwgY29tcGFyaXNvbjtcclxuXHJcblx0XHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xyXG5cclxuXHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXHJcblxyXG5cdFx0XHRjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcclxuXHJcblx0XHRcdFx0bG93ID0gaSArIDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcclxuXHJcblx0XHRcdFx0aGlnaCA9IGkgLSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aGlnaCA9IGk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdC8vIERPTkVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aSA9IGhpZ2g7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZygnYicgLCBpLCBsb3csIGhpZ2gsIERhdGUubm93KCktIHRpbWUpO1xyXG5cclxuXHRcdGlmICggYXJjTGVuZ3Roc1sgaSBdID09PSB0YXJnZXRBcmNMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR2YXIgdCA9IGkgLyAoIGlsIC0gMSApO1xyXG5cdFx0XHRyZXR1cm4gdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcclxuXHJcblx0XHR2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1sgaSBdO1xyXG5cdFx0dmFyIGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1sgaSArIDEgXTtcclxuXHJcblx0XHR2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xyXG5cclxuXHRcdC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXHJcblxyXG5cdFx0dmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xyXG5cclxuXHRcdC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcclxuXHJcblx0XHR2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcclxuXHJcblx0XHRyZXR1cm4gdDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxyXG5cdC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcclxuXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxyXG5cdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cclxuXHJcblx0Z2V0VGFuZ2VudDogZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhID0gMC4wMDAxO1xyXG5cdFx0dmFyIHQxID0gdCAtIGRlbHRhO1xyXG5cdFx0dmFyIHQyID0gdCArIGRlbHRhO1xyXG5cclxuXHRcdC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcclxuXHJcblx0XHRpZiAoIHQxIDwgMCApIHQxID0gMDtcclxuXHRcdGlmICggdDIgPiAxICkgdDIgPSAxO1xyXG5cclxuXHRcdHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xyXG5cdFx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XHJcblxyXG5cdFx0dmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YiggcHQxICk7XHJcblx0XHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uICggdSApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcclxuXHRcdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuVEhSRUUuQ3VydmUuVXRpbHMgPSBUSFJFRS5DdXJ2ZVV0aWxzOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuLy8gVE9ETzogVHJhbnNmb3JtYXRpb24gZm9yIEN1cnZlcz9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0M0QgQ3VydmVzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8vIEEgRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIG5ldyBjdXJ2ZSBzdWJjbGFzc2VzXHJcblxyXG5USFJFRS5DdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoIGNvbnN0cnVjdG9yLCBnZXRQb2ludEZ1bmMgKSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xyXG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50RnVuYztcclxuXHJcblx0cmV0dXJuIGNvbnN0cnVjdG9yO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlUGF0aC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICoqL1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcclxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1cnZlUGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5jdXJ2ZXMgPSBbXTtcclxuXHJcblx0dGhpcy5hdXRvQ2xvc2UgPSBmYWxzZTsgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdXJ2ZVBhdGg7XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggY3VydmUgKSB7XHJcblxyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG59O1xyXG5cclxuLypcclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuXHQvLyBUT0RPXHJcblx0Ly8gSWYgdGhlIGVuZGluZyBvZiBjdXJ2ZSBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBzdGFydGluZ1xyXG5cdC8vIG9yIHRoZSBuZXh0IGN1cnZlLCB0aGVuLCB0aGlzIGlzIG5vdCBhIHJlYWwgcGF0aFxyXG59O1xyXG4qL1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0Ly8gVE9ETyBUZXN0XHJcblx0Ly8gYW5kIHZlcmlmeSBmb3IgdmVjdG9yMyAobmVlZHMgdG8gaW1wbGVtZW50IGVxdWFscylcclxuXHQvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcclxuXHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcclxuXHR2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1sgdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMSBdLmdldFBvaW50KCAxICk7XHJcblxyXG5cdGlmICggISBzdGFydFBvaW50LmVxdWFscyggZW5kUG9pbnQgKSApIHtcclxuXHJcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgVEhSRUUuTGluZUN1cnZlKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cclxuLy8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxyXG4vLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XHJcblxyXG4vLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXHJcbi8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxyXG4vLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXHJcbi8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xyXG5cdHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdHZhciBpID0gMDtcclxuXHJcblx0Ly8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXHJcblxyXG5cdHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xyXG5cclxuXHRcdFx0dmFyIGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XHJcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XHJcblxyXG5cdFx0XHR2YXIgdSA9IDEgLSBkaWZmIC8gY3VydmUuZ2V0TGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpICsrO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG5cclxuXHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcclxuXHJcbn07XHJcblxyXG4vKlxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcclxufTtcclxuKi9cclxuXHJcbi8vIFdlIGNhbm5vdCB1c2UgdGhlIGRlZmF1bHQgVEhSRUUuQ3VydmUgZ2V0UG9pbnQoKSB3aXRoIGdldExlbmd0aCgpIGJlY2F1c2UgaW5cclxuLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXHJcbi8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuXHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XHJcblxyXG59O1xyXG5cclxuLy8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXHJcbi8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEN1cnZlTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXHJcblxyXG5cdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXHJcblx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XHJcblxyXG5cdHZhciBsZW5ndGhzID0gW10sIHN1bXMgPSAwO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcclxuXHRcdGxlbmd0aHMucHVzaCggc3VtcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcclxuXHJcblx0cmV0dXJuIGxlbmd0aHM7XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdENyZWF0ZSBHZW9tZXRyaWVzIEhlbHBlcnNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLy8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gcGF0aCBwb2ludHMgKGZvciBMaW5lIG9yIFBvaW50cyBvYmplY3RzKVxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBwdHMgPSB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XHJcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xyXG5cclxufTtcclxuXHJcbi8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbnQgc2FtcGxpbmcgYWxvbmcgdGhlIHBhdGhcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xyXG5cclxuXHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xyXG5cdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBvaW50cyApIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL1BhdGguanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxyXG4gKlxyXG4gKiovXHJcblxyXG5USFJFRS5QYXRoID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFRIUkVFLkN1cnZlUGF0aC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucyA9IFtdO1xyXG5cclxuXHRpZiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlICk7XHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGF0aDtcclxuXHJcbi8vIFRPRE8gQ2xlYW4gdXAgUEFUSCBBUElcclxuXHJcbi8vIENyZWF0ZSBwYXRoIHVzaW5nIHN0cmFpZ2h0IGxpbmVzIHRvIGNvbm5lY3QgYWxsIHBvaW50c1xyXG4vLyAtIHZlY3RvcnM6IGFycmF5IG9mIFZlY3RvcjJcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmZyb21Qb2ludHMgPSBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAxLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHRoaXMubGluZVRvKCB2ZWN0b3JzWyBpIF0ueCwgdmVjdG9yc1sgaSBdLnkgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIHN0YXJ0UGF0aCgpIGVuZFBhdGgoKT9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAnbW92ZVRvJywgYXJnczogWyB4LCB5IF0gfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkxpbmVDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLCBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApICk7XHJcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAnbGluZVRvJywgYXJnczogWyB4LCB5IF0gfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUoXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApXHJcblx0KTtcclxuXHJcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAncXVhZHJhdGljQ3VydmVUbycsIGFyZ3M6IFsgYUNQeCwgYUNQeSwgYVgsIGFZIF0gfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZIClcclxuXHQpO1xyXG5cclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdiZXppZXJDdXJ2ZVRvJywgYXJnczogWyBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZIF0gfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnNwbGluZVRocnUgPSBmdW5jdGlvbiggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XHJcblxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR2YXIgbnB0cyA9IFsgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApIF07XHJcblx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIG5wdHMgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdzcGxpbmVUaHJ1JywgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRlVUVVJFOiBDaGFuZ2UgdGhlIEFQSSBvciBmb2xsb3cgY2FudmFzIEFQST9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHRoaXMuYWJzYXJjKCBhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxyXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuIH07XHJcblxyXG4gVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG4gfTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XHJcblxyXG4gfTtcclxuXHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNlbGxpcHNlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBbXHJcblx0XHRhWCwgYVksXHJcblx0XHR4UmFkaXVzLCB5UmFkaXVzLFxyXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSxcclxuXHRcdGFDbG9ja3dpc2UsXHJcblx0XHRhUm90YXRpb24gfHwgMCAvLyBhUm90YXRpb24gaXMgb3B0aW9uYWwuXHJcblx0XTtcclxuXHJcblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcclxuXHRhcmdzLnB1c2goIGxhc3RQb2ludC54ICk7XHJcblx0YXJncy5wdXNoKCBsYXN0UG9pbnQueSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdlbGxpcHNlJywgYXJnczogYXJncyB9ICk7XHJcblxyXG4gfTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xyXG5cclxuXHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNDA7XHJcblxyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpICsrICkge1xyXG5cclxuXHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHQvL2lmICggIXRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApIHRocm93IFwiRElFXCI7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gaWYgKCBjbG9zZWRQYXRoICkge1xyXG5cdC8vXHJcblx0Ly8gXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcclxuXHQvL1xyXG5cdC8vIH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxuXHJcbn07XHJcblxyXG4vKiBSZXR1cm4gYW4gYXJyYXkgb2YgdmVjdG9ycyBiYXNlZCBvbiBjb250b3VyIG9mIHRoZSBwYXRoICovXHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xyXG5cclxuXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XHJcblxyXG5cdHZhciBiMiA9IFRIUkVFLlNoYXBlVXRpbHMuYjI7XHJcblx0dmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcclxuXHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHR2YXIgY3B4LCBjcHksIGNweDIsIGNweTIsIGNweDEsIGNweTEsIGNweDAsIGNweTAsXHJcblx0XHRsYXN0ZSwgdHgsIHR5O1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgaXRlbSA9IHRoaXMuYWN0aW9uc1sgaSBdO1xyXG5cclxuXHRcdHZhciBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcclxuXHRcdHZhciBhcmdzID0gaXRlbS5hcmdzO1xyXG5cclxuXHRcdHN3aXRjaCAoIGFjdGlvbiApIHtcclxuXHJcblx0XHRjYXNlICdtb3ZlVG8nOlxyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICdsaW5lVG8nOlxyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICdxdWFkcmF0aWNDdXJ2ZVRvJzpcclxuXHJcblx0XHRcdGNweCAgPSBhcmdzWyAyIF07XHJcblx0XHRcdGNweSAgPSBhcmdzWyAzIF07XHJcblxyXG5cdFx0XHRjcHgxID0gYXJnc1sgMCBdO1xyXG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xyXG5cclxuXHRcdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0bGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xyXG5cdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcblx0XHRcdFx0Y3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XHJcblx0XHRcdFx0Y3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdCA9IGogLyBkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdHR4ID0gYjIoIHQsIGNweDAsIGNweDEsIGNweCApO1xyXG5cdFx0XHRcdHR5ID0gYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICdiZXppZXJDdXJ2ZVRvJzpcclxuXHJcblx0XHRcdGNweCAgPSBhcmdzWyA0IF07XHJcblx0XHRcdGNweSAgPSBhcmdzWyA1IF07XHJcblxyXG5cdFx0XHRjcHgxID0gYXJnc1sgMCBdO1xyXG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xyXG5cclxuXHRcdFx0Y3B4MiA9IGFyZ3NbIDIgXTtcclxuXHRcdFx0Y3B5MiA9IGFyZ3NbIDMgXTtcclxuXHJcblx0XHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xyXG5cdFx0XHRcdGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ID0gaiAvIGRpdmlzaW9ucztcclxuXHJcblx0XHRcdFx0dHggPSBiMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XHJcblx0XHRcdFx0dHkgPSBiMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ3NwbGluZVRocnUnOlxyXG5cclxuXHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcblx0XHRcdHZhciBsYXN0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF0sIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF0gKTtcclxuXHRcdFx0dmFyIHNwdHMgPSBbIGxhc3QgXTtcclxuXHJcblx0XHRcdHZhciBuID0gZGl2aXNpb25zICogYXJnc1sgMCBdLmxlbmd0aDtcclxuXHJcblx0XHRcdHNwdHMgPSBzcHRzLmNvbmNhdCggYXJnc1sgMCBdICk7XHJcblxyXG5cdFx0XHR2YXIgc3BsaW5lID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBzcHRzICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gbjsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIHNwbGluZS5nZXRQb2ludEF0KCBqIC8gbiApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICdhcmMnOlxyXG5cclxuXHRcdFx0dmFyIGFYID0gYXJnc1sgMCBdLCBhWSA9IGFyZ3NbIDEgXSxcclxuXHRcdFx0XHRhUmFkaXVzID0gYXJnc1sgMiBdLFxyXG5cdFx0XHRcdGFTdGFydEFuZ2xlID0gYXJnc1sgMyBdLCBhRW5kQW5nbGUgPSBhcmdzWyA0IF0sXHJcblx0XHRcdFx0YUNsb2Nrd2lzZSA9ICEhIGFyZ3NbIDUgXTtcclxuXHJcblx0XHRcdHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XHJcblx0XHRcdHZhciBhbmdsZTtcclxuXHRcdFx0dmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ID0gaiAvIHRkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdGlmICggISBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHRcdFx0XHRcdHQgPSAxIC0gdDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblxyXG5cdFx0XHRcdHR4ID0gYVggKyBhUmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHRcdFx0dHkgPSBhWSArIGFSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICdlbGxpcHNlJzpcclxuXHJcblx0XHRcdHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXHJcblx0XHRcdFx0eFJhZGl1cyA9IGFyZ3NbIDIgXSxcclxuXHRcdFx0XHR5UmFkaXVzID0gYXJnc1sgMyBdLFxyXG5cdFx0XHRcdGFTdGFydEFuZ2xlID0gYXJnc1sgNCBdLCBhRW5kQW5nbGUgPSBhcmdzWyA1IF0sXHJcblx0XHRcdFx0YUNsb2Nrd2lzZSA9ICEhIGFyZ3NbIDYgXSxcclxuXHRcdFx0XHRhUm90YXRpb24gPSBhcmdzWyA3IF07XHJcblxyXG5cclxuXHRcdFx0dmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcclxuXHRcdFx0dmFyIGFuZ2xlO1xyXG5cdFx0XHR2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XHJcblxyXG5cdFx0XHR2YXIgY29zLCBzaW47XHJcblx0XHRcdGlmICggYVJvdGF0aW9uICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHRjb3MgPSBNYXRoLmNvcyggYVJvdGF0aW9uICk7XHJcblx0XHRcdFx0c2luID0gTWF0aC5zaW4oIGFSb3RhdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ID0gaiAvIHRkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdGlmICggISBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHRcdFx0XHRcdHQgPSAxIC0gdDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblxyXG5cdFx0XHRcdHR4ID0gYVggKyB4UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHRcdFx0dHkgPSBhWSArIHlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBhUm90YXRpb24gIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHggPSB0eCwgeSA9IHR5O1xyXG5cclxuXHRcdFx0XHRcdC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cclxuXHRcdFx0XHRcdHR4ID0gKCB4IC0gYVggKSAqIGNvcyAtICggeSAtIGFZICkgKiBzaW4gKyBhWDtcclxuXHRcdFx0XHRcdHR5ID0gKCB4IC0gYVggKSAqIHNpbiArICggeSAtIGFZICkgKiBjb3MgKyBhWTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2cocG9pbnRzKTtcclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH0gLy8gZW5kIHN3aXRjaFxyXG5cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gTm9ybWFsaXplIHRvIHJlbW92ZSB0aGUgY2xvc2luZyBwb2ludCBieSBkZWZhdWx0LlxyXG5cdHZhciBsYXN0UG9pbnQgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XHJcblx0aWYgKCBNYXRoLmFicyggbGFzdFBvaW50LnggLSBwb2ludHNbIDAgXS54ICkgPCBOdW1iZXIuRVBTSUxPTiAmJlxyXG5cdFx0XHQgTWF0aC5hYnMoIGxhc3RQb2ludC55IC0gcG9pbnRzWyAwIF0ueSApIDwgTnVtYmVyLkVQU0lMT04gKVxyXG5cdFx0cG9pbnRzLnNwbGljZSggcG9pbnRzLmxlbmd0aCAtIDEsIDEgKTtcclxuXHRpZiAoIGNsb3NlZFBhdGggKSB7XHJcblxyXG5cdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxuXHJcbn07XHJcblxyXG4vL1xyXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xyXG4vL1xyXG4vL1x0QXNzdW1wdGlvbnMgKGlmIHBhcmFtZXRlciBpc0NDVz09dHJ1ZSB0aGUgb3Bwb3NpdGUgaG9sZHMpOlxyXG4vL1x0LSBzb2xpZCBzaGFwZXMgYXJlIGRlZmluZWQgY2xvY2t3aXNlIChDVylcclxuLy9cdC0gaG9sZXMgYXJlIGRlZmluZWQgY291bnRlcmNsb2Nrd2lzZSAoQ0NXKVxyXG4vL1xyXG4vL1x0SWYgcGFyYW1ldGVyIG5vSG9sZXM9PXRydWU6XHJcbi8vICAtIGFsbCBzdWJQYXRocyBhcmUgcmVnYXJkZWQgYXMgc29saWQgc2hhcGVzXHJcbi8vICAtIGRlZmluaXRpb24gb3JkZXIgQ1cvQ0NXIGhhcyBubyByZWxldmFuY2VcclxuLy9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnRvU2hhcGVzID0gZnVuY3Rpb24oIGlzQ0NXLCBub0hvbGVzICkge1xyXG5cclxuXHRmdW5jdGlvbiBleHRyYWN0U3VicGF0aHMoIGluQWN0aW9ucyApIHtcclxuXHJcblx0XHR2YXIgc3ViUGF0aHMgPSBbXSwgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluQWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGl0ZW0gPSBpbkFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHRcdHZhciBhcmdzID0gaXRlbS5hcmdzO1xyXG5cdFx0XHR2YXIgYWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbiA9PT0gJ21vdmVUbycgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuXHRcdFx0XHRcdGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xyXG5cclxuXHRcdFx0c3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coc3ViUGF0aHMpO1xyXG5cclxuXHRcdHJldHVyblx0c3ViUGF0aHM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xyXG5cclxuXHRcdHZhciBzaGFwZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdG1wUGF0aCA9IGluU3VicGF0aHNbIGkgXTtcclxuXHJcblx0XHRcdHZhciB0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG5cdFx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHJcblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XHJcblxyXG5cdFx0dmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xyXG5cclxuXHRcdC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXHJcblx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXHJcblx0XHQvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XHJcblx0XHQvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxyXG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlO1xyXG5cdFx0Zm9yICggdmFyIHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSArKyApIHtcclxuXHJcblx0XHRcdHZhciBlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBwIF07XHJcblx0XHRcdHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XHJcblxyXG5cdFx0XHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XHJcblx0XHRcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGVkZ2VEeSApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxyXG5cdFx0XHRcdGlmICggZWRnZUR5IDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xyXG5cdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSBcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcblx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XHJcblx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlID09PSAwIClcdFx0XHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cclxuXHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPCAwICkgXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXHJcblx0XHRcdFx0aWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgXHRcdGNvbnRpbnVlO1x0XHRcdC8vIHBhcmFsbGVsXHJcblx0XHRcdFx0Ly8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XHJcblx0XHRcdFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxyXG5cdFx0XHRcdFx0ICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApIClcdFx0cmV0dXJuXHR0cnVlO1x0Ly8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXHJcblx0XHRcdFx0Ly8gY29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVyblx0aW5zaWRlO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBpc0Nsb2NrV2lzZSA9IFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XHJcblxyXG5cdHZhciBzdWJQYXRocyA9IGV4dHJhY3RTdWJwYXRocyggdGhpcy5hY3Rpb25zICk7XHJcblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XHJcblxyXG5cdGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcclxuXHJcblxyXG5cdHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGUsIHNoYXBlcyA9IFtdO1xyXG5cclxuXHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcclxuXHJcblx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIDAgXTtcclxuXHRcdHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XHJcblx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHRcdHJldHVybiBzaGFwZXM7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XHJcblx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcclxuXHJcblx0Ly8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcclxuXHJcblx0dmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcclxuXHR2YXIgbmV3U2hhcGVzID0gW107XHJcblx0dmFyIG5ld1NoYXBlSG9sZXMgPSBbXTtcclxuXHR2YXIgbWFpbklkeCA9IDA7XHJcblx0dmFyIHRtcFBvaW50cztcclxuXHJcblx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XHJcblx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XHJcblx0XHR0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xyXG5cdFx0c29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XHJcblx0XHRzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xyXG5cclxuXHRcdGlmICggc29saWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcdG1haW5JZHggKys7XHJcblxyXG5cdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHsgczogbmV3IFRIUkVFLlNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xyXG5cdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXS5zLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XHJcblx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblxyXG5cdFx0XHRpZiAoIGhvbGVzRmlyc3QgKVx0bWFpbklkeCArKztcclxuXHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXHJcblx0aWYgKCAhIG5ld1NoYXBlc1sgMCBdIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xyXG5cclxuXHJcblx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHR2YXIgYW1iaWd1b3VzID0gZmFsc2U7XHJcblx0XHR2YXIgdG9DaGFuZ2UgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaG8gPSBzaG9bIGhJZHggXTtcclxuXHRcdFx0XHR2YXIgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBzSWR4ICE9PSBzMklkeCApXHR0b0NoYW5nZS5wdXNoKCB7IGZyb21zOiBzSWR4LCB0b3M6IHMySWR4LCBob2xlOiBoSWR4IH0gKTtcclxuXHRcdFx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGFtYmlndW91cyA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XHJcblx0XHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcclxuXHRcdFx0aWYgKCAhIGFtYmlndW91cyApXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHRtcEhvbGVzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcclxuXHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xyXG5cclxuXHRyZXR1cm4gc2hhcGVzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL1NoYXBlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXHJcbiAqKi9cclxuXHJcbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxyXG4vLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXHJcbi8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXHJcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcclxuLy8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cclxuXHJcblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5QYXRoLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuXHJcblx0dGhpcy5ob2xlcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlO1xyXG5cclxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xyXG5cclxufTtcclxuXHJcbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5TaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBob2xlc1B0cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBob2xlc1B0cztcclxuXHJcbn07XHJcblxyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5leHRyYWN0QWxsUG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5VdGlscyA9IFRIUkVFLlNoYXBlVXRpbHM7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRMaW5lXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVDdXJ2ZTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcclxuXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gcG9pbnQ7XHJcblxyXG59O1xyXG5cclxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XHJcblxyXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFF1YWRyYXRpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHR0aGlzLnYwID0gdjA7XHJcblx0dGhpcy52MSA9IHYxO1xyXG5cdHRoaXMudjIgPSB2MjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmU7XHJcblxyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcblx0XHRiMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxyXG5cdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKVxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0YW5nZW50UXVhZHJhdGljQmV6aWVyID0gVEhSRUUuQ3VydmVVdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcblx0XHR0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXHJcblx0XHR0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55IClcclxuXHQpLm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdWJpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XHJcblxyXG5cdHRoaXMudjAgPSB2MDtcclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cdHRoaXMudjMgPSB2MztcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmljQmV6aWVyQ3VydmU7XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCBcclxuXHRcdGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcclxuXHRcdGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgdGFuZ2VudEN1YmljQmV6aWVyID0gVEhSRUUuQ3VydmVVdGlscy50YW5nZW50Q3ViaWNCZXppZXI7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggXHJcblx0XHR0YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApLFxyXG5cdFx0dGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxyXG5cdCkubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRTcGxpbmUgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUgPSBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xyXG5cclxuXHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwbGluZUN1cnZlO1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcblx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcblx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xyXG5cdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcblx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XHJcblx0dmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XHJcblxyXG5cdHZhciBpbnRlcnBvbGF0ZSA9IFRIUkVFLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcclxuXHRcdGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXHJcblx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRFbGxpcHNlIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkVsbGlwc2VDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG5cdHRoaXMuYVggPSBhWDtcclxuXHR0aGlzLmFZID0gYVk7XHJcblxyXG5cdHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XHJcblx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcclxuXHJcblx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xyXG5cdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xyXG5cclxuXHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xyXG5cdFxyXG5cdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWxsaXBzZUN1cnZlO1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XHJcblxyXG5cdGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG5cdGlmICggZGVsdGFBbmdsZSA+IE1hdGguUEkgKiAyICkgZGVsdGFBbmdsZSAtPSBNYXRoLlBJICogMjtcclxuXHJcblx0dmFyIGFuZ2xlO1xyXG5cclxuXHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRhbmdsZSA9IHRoaXMuYUVuZEFuZ2xlICsgKCAxIC0gdCApICogKCBNYXRoLlBJICogMiAtIGRlbHRhQW5nbGUgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcblx0fVxyXG5cdFxyXG5cdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xyXG5cclxuXHRcdHZhciBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcclxuXHRcdHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcclxuXHJcblx0XHR2YXIgdHggPSB4LCB0eSA9IHk7XHJcblxyXG5cdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxyXG5cdFx0eCA9ICggdHggLSB0aGlzLmFYICkgKiBjb3MgLSAoIHR5IC0gdGhpcy5hWSApICogc2luICsgdGhpcy5hWDtcclxuXHRcdHkgPSAoIHR4IC0gdGhpcy5hWCApICogc2luICsgKCB0eSAtIHRoaXMuYVkgKSAqIGNvcyArIHRoaXMuYVk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9BcmNDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRBcmMgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQXJjQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0VEhSRUUuRWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJjQ3VydmU7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0TGluZTNEXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcclxuXHRcdHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xyXG5cdFx0dmVjdG9yLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRcdHJldHVybiB2ZWN0b3I7XHJcblxyXG5cdH1cclxuXHJcbik7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciBiMiA9IFRIUkVFLlNoYXBlVXRpbHMuYjI7XHRcdFxyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKSxcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKSxcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKVxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3ViaWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHRcdHRoaXMudjMgPSB2MztcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG5cdFx0XHRiMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICksXHJcblx0XHRcdGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKSxcclxuXHRcdFx0YjMoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnosIHRoaXMudjMueiApXHJcblx0XHQpO1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0U3BsaW5lIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIHdpbGwgYmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzJyApO1xyXG5cdFx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG5cdFx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcblx0XHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XHJcblx0XHR2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xyXG5cdFx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XHJcblx0XHR2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcclxuXHJcblx0XHR2YXIgaW50ZXJwb2xhdGUgPSBUSFJFRS5DdXJ2ZVV0aWxzLmludGVycG9sYXRlO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKSxcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKSxcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKVxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKlxyXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xyXG4gKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cclxuICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcclxuICpcclxuICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXHJcbiAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcclxuICovXHJcblxyXG5USFJFRS5DYXRtdWxsUm9tQ3VydmUzID0gKCBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyXHJcblx0XHR0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0cHggPSBuZXcgQ3ViaWNQb2x5KCksXHJcblx0XHRweSA9IG5ldyBDdWJpY1BvbHkoKSxcclxuXHRcdHB6ID0gbmV3IEN1YmljUG9seSgpO1xyXG5cclxuXHQvKlxyXG5cdEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cclxuXHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xyXG5cdCAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxyXG5cclxuXHRUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXHJcblx0YnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXHJcblx0d2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxyXG5cdCovXHJcblxyXG5cdGZ1bmN0aW9uIEN1YmljUG9seSgpIHtcclxuXHJcblx0fVxyXG5cclxuXHQvKlxyXG5cdCAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcclxuXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcclxuXHQgKiBzdWNoIHRoYXRcclxuXHQgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXHJcblx0ICogIGFuZFxyXG5cdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cclxuXHQgKi9cclxuXHRDdWJpY1BvbHkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiggeDAsIHgxLCB0MCwgdDEgKSB7XHJcblxyXG5cdFx0dGhpcy5jMCA9IHgwO1xyXG5cdFx0dGhpcy5jMSA9IHQwO1xyXG5cdFx0dGhpcy5jMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XHJcblx0XHR0aGlzLmMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcclxuXHJcblx0fTtcclxuXHJcblx0Q3ViaWNQb2x5LnByb3RvdHlwZS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxyXG5cdFx0dmFyIHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcclxuXHRcdHZhciB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XHJcblxyXG5cdFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXHJcblx0XHR0MSAqPSBkdDE7XHJcblx0XHR0MiAqPSBkdDE7XHJcblxyXG5cdFx0Ly8gaW5pdEN1YmljUG9seVxyXG5cdFx0dGhpcy5pbml0KCB4MSwgeDIsIHQxLCB0MiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBzdGFuZGFyZCBDYXRtdWxsLVJvbSBzcGxpbmU6IGludGVycG9sYXRlIGJldHdlZW4geDEgYW5kIHgyIHdpdGggcHJldmlvdXMvZm9sbG93aW5nIHBvaW50cyB4MS94NFxyXG5cdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5pbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XHJcblxyXG5cdH07XHJcblxyXG5cdEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHRcdHZhciB0MiA9IHQgKiB0O1xyXG5cdFx0dmFyIHQzID0gdDIgKiB0O1xyXG5cdFx0cmV0dXJuIHRoaXMuYzAgKyB0aGlzLmMxICogdCArIHRoaXMuYzIgKiB0MiArIHRoaXMuYzMgKiB0MztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gU3ViY2xhc3MgVGhyZWUuanMgY3VydmVcclxuXHRyZXR1cm4gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRcdGZ1bmN0aW9uICggcCAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xyXG5cclxuXHRcdFx0dGhpcy5wb2ludHMgPSBwIHx8IFtdO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxyXG5cdFx0XHRcdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCBsO1xyXG5cclxuXHRcdFx0bCA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIGwgPCAyICkgY29uc29sZS5sb2coICdkdWgsIHlvdSBuZWVkIGF0IGxlYXN0IDIgcG9pbnRzJyApO1xyXG5cclxuXHRcdFx0cG9pbnQgPSAoIGwgLSAxICkgKiB0O1xyXG5cdFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblx0XHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0XHRpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdGludFBvaW50ID0gbCAtIDI7XHJcblx0XHRcdFx0d2VpZ2h0ID0gMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwMCwgcDEsIHAyLCBwMztcclxuXHJcblx0XHRcdGlmICggaW50UG9pbnQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XHJcblx0XHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSApLmFkZCggcG9pbnRzWyAwIF0gKTtcclxuXHRcdFx0XHRwMCA9IHRtcDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHAwID0gcG9pbnRzWyBpbnRQb2ludCAtIDEgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHAxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xyXG5cdFx0XHRwMiA9IHBvaW50c1sgaW50UG9pbnQgKyAxIF07XHJcblxyXG5cdFx0XHRpZiAoIGludFBvaW50ICsgMiA8IGwgKSB7XHJcblxyXG5cdFx0XHRcdHAzID0gcG9pbnRzWyBpbnRQb2ludCArIDIgXVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxyXG5cdFx0XHRcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIGwgLSAxIF0sIHBvaW50c1sgbCAtIDIgXSApLmFkZCggcG9pbnRzWyBsIC0gMiBdICk7XHJcblx0XHRcdFx0cDMgPSB0bXA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyApIHtcclxuXHJcblx0XHRcdFx0Ly8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cclxuXHRcdFx0XHR2YXIgcG93ID0gdGhpcy50eXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xyXG5cdFx0XHRcdHZhciBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xyXG5cdFx0XHRcdHZhciBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xyXG5cdFx0XHRcdHZhciBkdDIgPSBNYXRoLnBvdyggcDIuZGlzdGFuY2VUb1NxdWFyZWQoIHAzICksIHBvdyApO1xyXG5cclxuXHRcdFx0XHQvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xyXG5cdFx0XHRcdGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcclxuXHRcdFx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XHJcblx0XHRcdFx0aWYgKCBkdDIgPCAxZS00ICkgZHQyID0gZHQxO1xyXG5cclxuXHRcdFx0XHRweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcclxuXHRcdFx0XHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcclxuXHRcdFx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMudHlwZSA9PT0gJ2NhdG11bGxyb20nICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdGVuc2lvbiA9IHRoaXMudGVuc2lvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy50ZW5zaW9uIDogMC41O1xyXG5cdFx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0ZW5zaW9uICk7XHJcblx0XHRcdFx0cHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRlbnNpb24gKTtcclxuXHRcdFx0XHRwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGVuc2lvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0XHRweC5jYWxjKCB3ZWlnaHQgKSxcclxuXHRcdFx0XHRweS5jYWxjKCB3ZWlnaHQgKSxcclxuXHRcdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHQpO1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0Nsb3NlZFNwbGluZUN1cnZlMy5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDbG9zZWQgU3BsaW5lIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG5USFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG5cdFx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMCApICogdDsgLy8gVGhpcyBuZWVkcyB0byBiZSBmcm9tIDAtbGVuZ3RoICsxXHJcblxyXG5cdFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHRcdHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuXHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgcG9pbnQwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgcG9pbnRzLmxlbmd0aCBdO1xyXG5cdFx0dmFyIHBvaW50MSA9IHBvaW50c1sgKCBpbnRQb2ludCAgICAgKSAlIHBvaW50cy5sZW5ndGggXTtcclxuXHRcdHZhciBwb2ludDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBwb2ludHMubGVuZ3RoIF07XHJcblx0XHR2YXIgcG9pbnQzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgcG9pbnRzLmxlbmd0aCBdO1xyXG5cclxuXHRcdHZhciBpbnRlcnBvbGF0ZSA9IFRIUkVFLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG5cdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApLFxyXG5cdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApLFxyXG5cdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApXHJcblx0XHQpO1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLkJveEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHRkZXB0aDogZGVwdGgsXHJcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG5cdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xyXG5cdH07XHJcblxyXG5cdHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmRlcHRoU2VnbWVudHMgPSBkZXB0aFNlZ21lbnRzIHx8IDE7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xyXG5cdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XHJcblx0dmFyIGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XHJcblxyXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGhfaGFsZiwgMCApOyAvLyBweFxyXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAgIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aF9oYWxmLCAxICk7IC8vIG54XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgICAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodF9oYWxmLCAyICk7IC8vIHB5XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0X2hhbGYsIDMgKTsgLy8gbnlcclxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgICAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoX2hhbGYsIDQgKTsgLy8gcHpcclxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGhfaGFsZiwgNSApOyAvLyBuelxyXG5cclxuXHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHR2YXIgdywgaXgsIGl5LFxyXG5cdFx0Z3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0Z3JpZFkgPSBzY29wZS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXHJcblx0XHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXHJcblx0XHRvZmZzZXQgPSBzY29wZS52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcclxuXHJcblx0XHRcdHcgPSAneic7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3knO1xyXG5cdFx0XHRncmlkWSA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneicgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3onICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3gnO1xyXG5cdFx0XHRncmlkWCA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncmlkWDEgPSBncmlkWCArIDEsXHJcblx0XHRncmlkWTEgPSBncmlkWSArIDEsXHJcblx0XHRzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWCxcclxuXHRcdHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXHJcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0XHR2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcclxuXHRcdFx0XHR2ZWN0b3JbIHYgXSA9ICggaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmICkgKiB2ZGlyO1xyXG5cdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGg7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIHZlY3RvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xyXG5cdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG5cdFx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XHJcblxyXG5cdFx0XHRcdHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcclxuXHRcdFx0XHR2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcclxuXHRcdFx0XHR2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xyXG5cdFx0XHRcdHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSArIG9mZnNldCwgYiArIG9mZnNldCwgZCArIG9mZnNldCApO1xyXG5cdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XHJcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiICsgb2Zmc2V0LCBjICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XHJcblx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcclxuXHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94R2VvbWV0cnk7XHJcblxyXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxyXG5cdFx0cGFyYW1ldGVycy53aWR0aCxcclxuXHRcdHBhcmFtZXRlcnMuaGVpZ2h0LFxyXG5cdFx0cGFyYW1ldGVycy5kZXB0aCxcclxuXHRcdHBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcclxuXHRcdHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRwYXJhbWV0ZXJzLmRlcHRoU2VnbWVudHNcclxuXHQpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmVHZW9tZXRyeSA9IFRIUkVFLkJveEdlb21ldHJ5OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ2lyY2xlR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGh1Z2hlc1xyXG4gKi9cclxuXHJcblRIUkVFLkNpcmNsZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcclxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuXHR9O1xyXG5cclxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNpcmNsZUdlb21ldHJ5O1xyXG5cclxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcclxuXHRcdHBhcmFtZXRlcnMucmFkaXVzLFxyXG5cdFx0cGFyYW1ldGVycy5zZWdtZW50cyxcclxuXHRcdHBhcmFtZXRlcnMudGhldGFTdGFydCxcclxuXHRcdHBhcmFtZXRlcnMudGhldGFMZW5ndGhcclxuXHQpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUJ1ZmZlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XHJcblxyXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBzZWdtZW50cyArIDI7XHJcblxyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcclxuXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xyXG5cdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDIgKTtcclxuXHJcblx0Ly8gY2VudGVyIGRhdGEgaXMgYWxyZWFkeSB6ZXJvLCBidXQgbmVlZCB0byBzZXQgYSBmZXcgZXh0cmFzXHJcblx0bm9ybWFsc1sgMiBdID0gMS4wO1xyXG5cdHV2c1sgMCBdID0gMC41O1xyXG5cdHV2c1sgMSBdID0gMC41O1xyXG5cclxuXHRmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDIgOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMsIGlpICs9IDIgKSB7XHJcblxyXG5cdFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XHJcblxyXG5cdFx0cG9zaXRpb25zWyBpIF0gPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xyXG5cdFx0cG9zaXRpb25zWyBpICsgMSBdID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcclxuXHJcblx0XHRub3JtYWxzWyBpICsgMiBdID0gMTsgLy8gbm9ybWFsIHpcclxuXHJcblx0XHR1dnNbIGlpIF0gPSAoIHBvc2l0aW9uc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcclxuXHRcdHV2c1sgaWkgKyAxIF0gPSAoIHBvc2l0aW9uc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGluZGljZXMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeTtcclxuXHJcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkoXHJcblx0XHRwYXJhbWV0ZXJzLnJhZGl1cyxcclxuXHRcdHBhcmFtZXRlcnMuc2VnbWVudHMsXHJcblx0XHRwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcblx0XHRwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DeWxpbmRlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRyYWRpdXNUb3A6IHJhZGl1c1RvcCxcclxuXHRcdHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcclxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuXHR9O1xyXG5cclxuXHRyYWRpdXNUb3AgPSByYWRpdXNUb3AgIT09IHVuZGVmaW5lZCA/IHJhZGl1c1RvcCA6IDIwO1xyXG5cdHJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbSAhPT0gdW5kZWZpbmVkID8gcmFkaXVzQm90dG9tIDogMjA7XHJcblx0aGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XHJcblxyXG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcclxuXHRoZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XHJcblxyXG5cdG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XHJcblx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG5cdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogMiAqIE1hdGguUEk7XHJcblxyXG5cdHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcclxuXHJcblx0dmFyIHgsIHksIHZlcnRpY2VzID0gW10sIHV2cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXNSb3cgPSBbXTtcclxuXHRcdHZhciB1dnNSb3cgPSBbXTtcclxuXHJcblx0XHR2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcclxuXHRcdHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcclxuXHJcblx0XHRmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcclxuXHRcdFx0dmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0ICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XHJcblx0XHRcdHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG5cdFx0dXZzLnB1c2goIHV2c1JvdyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciB0YW5UaGV0YSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XHJcblx0dmFyIG5hLCBuYjtcclxuXHJcblx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRpZiAoIHJhZGl1c1RvcCAhPT0gMCApIHtcclxuXHJcblx0XHRcdG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCBdIF0uY2xvbmUoKTtcclxuXHRcdFx0bmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4IF0gXS5jbG9uZSgpO1xyXG5cdFx0XHRuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRuYS5zZXRZKCBNYXRoLnNxcnQoIG5hLnggKiBuYS54ICsgbmEueiAqIG5hLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XHJcblx0XHRuYi5zZXRZKCBNYXRoLnNxcnQoIG5iLnggKiBuYi54ICsgbmIueiAqIG5iLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0Zm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggXTtcclxuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcclxuXHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2NCA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XHJcblxyXG5cdFx0XHR2YXIgbjEgPSBuYS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgbjIgPSBuYS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgbjMgPSBuYi5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgbjQgPSBuYi5jbG9uZSgpO1xyXG5cclxuXHRcdFx0dmFyIHV2MSA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MiA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djMgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2NCA9IHV2c1sgeSBdWyB4ICsgMSBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2NCwgWyBuMSwgbjIsIG40IF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djQgXSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYyLCB2MywgdjQsIFsgbjIuY2xvbmUoKSwgbjMsIG40LmNsb25lKCkgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYyLmNsb25lKCksIHV2MywgdXY0LmNsb25lKCkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyB0b3AgY2FwXHJcblxyXG5cdGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNUb3AgPiAwICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodEhhbGYsIDAgKSApO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgMCBdWyB4IF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyAwIF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblx0XHRcdHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblx0XHRcdHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyAwIF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyAwIF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMCApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdLCB1bmRlZmluZWQsIDEgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBib3R0b20gY2FwXHJcblxyXG5cdGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNCb3R0b20gPiAwICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gaGVpZ2h0SGFsZiwgMCApICk7XHJcblxyXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdO1xyXG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XHJcblx0XHRcdHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xyXG5cclxuXHRcdFx0dmFyIHV2MSA9IHV2c1sgaGVpZ2h0U2VnbWVudHMgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdLCB1bmRlZmluZWQsIDIgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeTtcclxuXHJcblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxyXG5cdFx0cGFyYW1ldGVycy5yYWRpdXNUb3AsXHJcblx0XHRwYXJhbWV0ZXJzLnJhZGl1c0JvdHRvbSxcclxuXHRcdHBhcmFtZXRlcnMuaGVpZ2h0LFxyXG5cdFx0cGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcclxuXHRcdHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRwYXJhbWV0ZXJzLm9wZW5FbmRlZCxcclxuXHRcdHBhcmFtZXRlcnMudGhldGFTdGFydCxcclxuXHRcdHBhcmFtZXRlcnMudGhldGFMZW5ndGhcclxuXHQpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0VkZ2VzR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5FZGdlc0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSB7XHJcblxyXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhyZXNob2xkQW5nbGUgPSAoIHRocmVzaG9sZEFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IHRocmVzaG9sZEFuZ2xlIDogMTtcclxuXHJcblx0dmFyIHRocmVzaG9sZERvdCA9IE1hdGguY29zKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aHJlc2hvbGRBbmdsZSApICk7XHJcblxyXG5cdHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gc29ydEZ1bmN0aW9uKCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBhIC0gYjtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkyO1xyXG5cclxuXHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkyID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0XHRnZW9tZXRyeTIuZnJvbUJ1ZmZlckdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VvbWV0cnkyLm1lcmdlVmVydGljZXMoKTtcclxuXHRnZW9tZXRyeTIuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5Mi52ZXJ0aWNlcztcclxuXHR2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcclxuXHRcdFx0ZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XHJcblx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XHJcblxyXG5cdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRoYXNoWyBrZXkgXSA9IHsgdmVydDE6IGVkZ2VbIDAgXSwgdmVydDI6IGVkZ2VbIDEgXSwgZmFjZTE6IGksIGZhY2UyOiB1bmRlZmluZWQgfTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGhhc2hbIGtleSBdLmZhY2UyID0gaTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIga2V5IGluIGhhc2ggKSB7XHJcblxyXG5cdFx0dmFyIGggPSBoYXNoWyBrZXkgXTtcclxuXHJcblx0XHRpZiAoIGguZmFjZTIgPT09IHVuZGVmaW5lZCB8fCBmYWNlc1sgaC5mYWNlMSBdLm5vcm1hbC5kb3QoIGZhY2VzWyBoLmZhY2UyIF0ubm9ybWFsICkgPD0gdGhyZXNob2xkRG90ICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XHJcblx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xyXG5cdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnkgKTtcclxuXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaC52ZXJ0MiBdO1xyXG5cdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnggKTtcclxuXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC55ICk7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggY29vcmRzICksIDMgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICpcclxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcclxuICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cclxuICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXHJcbiAqXHJcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxyXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcclxuICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgaXMgYmV2ZWxcclxuICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXHJcbiAqXHJcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlUGF0aD4gLy8gM2Qgc3BsaW5lIHBhdGggdG8gZXh0cnVkZSBzaGFwZSBhbG9uZy4gKGNyZWF0ZXMgRnJhbWVzIGlmIC5mcmFtZXMgYXJlbid0IGRlZmluZWQpXHJcbiAqICBmcmFtZXM6IDxUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzPiAvLyBjb250YWluaW5nIGFycmF5cyBvZiB0YW5nZW50cywgbm9ybWFscywgYmlub3JtYWxzXHJcbiAqXHJcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiB9XHJcbiAqKi9cclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuXHRpZiAoIHR5cGVvZiggc2hhcGVzICkgPT09IFwidW5kZWZpbmVkXCIgKSB7XHJcblxyXG5cdFx0c2hhcGVzID0gW107XHJcblx0XHRyZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcclxuXHJcblx0c2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xyXG5cclxuXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XHJcblxyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXHJcblx0Ly8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXHJcblx0Ly8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xyXG5cclxuXHQvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0Ly9jb25zb2xlLmxvZyggXCJ0b29rXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0dmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcclxuXHJcblx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XHJcblxyXG5cdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XHJcblx0XHR0aGlzLmFkZFNoYXBlKCBzaGFwZSwgb3B0aW9ucyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XHJcblxyXG5cdHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XHJcblxyXG5cdHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2OyAvLyAxMFxyXG5cdHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcclxuXHR2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcclxuXHJcblx0dmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXHJcblxyXG5cdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcclxuXHJcblx0dmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XHJcblxyXG5cdHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XHJcblx0dmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcclxuXHJcblx0Ly8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXHJcblx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xyXG5cclxuXHR2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xyXG5cdGlmICggZXh0cnVkZVBhdGggKSB7XHJcblxyXG5cdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcclxuXHJcblx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcclxuXHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cclxuXHJcblx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXHJcblxyXG5cdFx0Ly8gUmV1c2UgVE5CIGZyb20gVHViZUdlb210cnkgZm9yIG5vdy5cclxuXHRcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XHJcblxyXG5cdFx0c3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBleHRydWRlUGF0aCwgc3RlcHMsIGZhbHNlICk7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XHJcblxyXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHBvc2l0aW9uMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXHJcblxyXG5cdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XHJcblxyXG5cdFx0YmV2ZWxTZWdtZW50cyA9IDA7XHJcblx0XHRiZXZlbFRoaWNrbmVzcyA9IDA7XHJcblx0XHRiZXZlbFNpemUgPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxyXG5cclxuXHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xyXG5cdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xyXG5cclxuXHR2YXIgcmV2ZXJzZSA9ICEgVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcclxuXHJcblx0aWYgKCByZXZlcnNlICkge1xyXG5cclxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xyXG5cclxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGFob2xlICkgKSB7XHJcblxyXG5cdFx0XHRcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldmVyc2UgPSBmYWxzZTsgLy8gSWYgdmVydGljZXMgYXJlIGluIG9yZGVyIG5vdywgd2Ugc2hvdWxkbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlbSBhZ2FpbiAoaG9wZWZ1bGx5KSFcclxuXHJcblx0fVxyXG5cclxuXHJcblx0dmFyIGZhY2VzID0gVEhSRUUuU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcclxuXHJcblx0LyogVmVydGljZXMgKi9cclxuXHJcblx0dmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcclxuXHJcblx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBzY2FsZVB0MiAoIHB0LCB2ZWMsIHNpemUgKSB7XHJcblxyXG5cdFx0aWYgKCAhIHZlYyApIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3RcIiApO1xyXG5cclxuXHRcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgYiwgYnMsIHQsIHosXHJcblx0XHR2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxyXG5cdFx0ZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblxyXG5cdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcclxuXHJcblxyXG5cdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcclxuXHJcblx0XHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXHJcblx0XHQvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XHJcblx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcclxuXHRcdC8vXHJcblx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xyXG5cdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cclxuXHJcblx0XHR2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieSA9IDE7XHRcdC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcclxuXHJcblx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXHJcblx0XHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxyXG5cclxuXHRcdHZhciB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LCB2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xyXG5cdFx0dmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsIHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XHJcblxyXG5cdFx0dmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcclxuXHJcblx0XHQvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXHJcblx0XHR2YXIgY29sbGluZWFyMCA9ICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcclxuXHJcblx0XHRcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xyXG5cclxuXHRcdFx0dmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xyXG5cdFx0XHR2YXIgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcclxuXHJcblx0XHRcdC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcclxuXHJcblx0XHRcdHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xyXG5cdFx0XHR2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcclxuXHJcblx0XHRcdHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xyXG5cdFx0XHR2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcclxuXHJcblx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG5cdFx0XHR2YXIgc2YgPSAoICAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXHJcblx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xyXG5cdFx0XHRcdFx0ICAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XHJcblxyXG5cdFx0XHQvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxyXG5cclxuXHRcdFx0dl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xyXG5cdFx0XHR2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XHJcblxyXG5cdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxyXG5cdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXHJcblx0XHRcdHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcclxuXHRcdFx0aWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVyblx0bmV3IFRIUkVFLlZlY3RvcjIoIHZfdHJhbnNfeCwgdl90cmFuc195ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXHJcblxyXG5cdFx0XHR2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7XHRcdC8vIGFzc3VtZXM6IG9wcG9zaXRlXHJcblx0XHRcdGlmICggdl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB2X25leHRfeCA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBNYXRoLnNpZ24oIHZfcHJldl95ICkgPT09IE1hdGguc2lnbiggdl9uZXh0X3kgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRpcmVjdGlvbl9lcSApIHtcclxuXHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcclxuXHRcdFx0XHR2X3RyYW5zX3ggPSAtIHZfcHJldl95O1xyXG5cdFx0XHRcdHZfdHJhbnNfeSA9ICB2X3ByZXZfeDtcclxuXHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzcGlrZVwiKTtcclxuXHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcclxuXHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcclxuXHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSAvIDIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuXHRuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0dmFyIGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcblx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XHJcblx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XHJcblxyXG5cdFx0Ly8gIChqKS0tLShpKS0tLShrKVxyXG5cdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXHJcblxyXG5cdFx0Y29udG91ck1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSwgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xyXG5cclxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XHJcblx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcclxuXHRcdFx0b25lSG9sZU1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGFob2xlWyBpIF0sIGFob2xlWyBqIF0sIGFob2xlWyBrIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cdFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXHJcblxyXG5cdGZvciAoIGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHJcblx0XHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcclxuXHJcblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XHJcblxyXG5cdFx0Ly96ID0gYmV2ZWxUaGlja25lc3MgKiB0O1xyXG5cdFx0YnMgPSBiZXZlbFNpemUgKiAoIE1hdGguc2luICggdCAqIE1hdGguUEkgLyAyICkgKTsgLy8gY3VydmVkXHJcblx0XHQvL2JzID0gYmV2ZWxTaXplICogdDsgLy8gbGluZWFyXHJcblxyXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGV4cGFuZCBob2xlc1xyXG5cclxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0YnMgPSBiZXZlbFNpemU7XHJcblxyXG5cdC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcblx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuXHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xyXG5cclxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcclxuXHJcblx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcclxuXHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcblx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcclxuXHJcblx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cclxuXHQvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXHJcblxyXG5cdHZhciBzO1xyXG5cclxuXHRmb3IgKCBzID0gMTsgcyA8PSBzdGVwczsgcyArKyApIHtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgcyAtIDEgXS55LCBleHRydWRlUHRzWyBzIC0gMSBdLnggKTtcclxuXHJcblx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG5cdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XHJcblxyXG5cdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xyXG5cclxuXHQvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XHJcblx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XHJcblxyXG5cdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xyXG5cdFx0eiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xyXG5cdFx0Ly9icyA9IGJldmVsU2l6ZSAqICggMS1NYXRoLnNpbiAoICggMSAtIHQgKSAqIE1hdGguUEkvMiApICk7XHJcblx0XHRicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luICggdCAqIE1hdGguUEkgLyAyICk7XHJcblxyXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGV4cGFuZCBob2xlc1xyXG5cclxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qIEZhY2VzICovXHJcblxyXG5cdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXHJcblxyXG5cdGJ1aWxkTGlkRmFjZXMoKTtcclxuXHJcblx0Ly8gU2lkZXMgZmFjZXNcclxuXHJcblx0YnVpbGRTaWRlRmFjZXMoKTtcclxuXHJcblxyXG5cdC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcclxuXHJcblx0ZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcclxuXHJcblx0XHRpZiAoIGJldmVsRW5hYmxlZCApIHtcclxuXHJcblx0XHRcdHZhciBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuXHRcdFx0Ly8gQm90dG9tIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XHJcblx0XHRcdG9mZnNldCA9IHZsZW4gKiBsYXllcjtcclxuXHJcblx0XHRcdC8vIFRvcCBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBCb3R0b20gZmFjZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRvcCBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxyXG5cclxuXHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcclxuXHJcblx0XHR2YXIgbGF5ZXJvZmZzZXQgPSAwO1xyXG5cdFx0c2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xyXG5cdFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHQvLywgdHJ1ZVxyXG5cdFx0XHRsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XHJcblxyXG5cdFx0dmFyIGosIGs7XHJcblx0XHRpID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XHJcblxyXG5cdFx0XHRqID0gaTtcclxuXHRcdFx0ayA9IGkgLSAxO1xyXG5cdFx0XHRpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xyXG5cclxuXHRcdFx0dmFyIHMgPSAwLCBzbCA9IHN0ZXBzICArIGJldmVsU2VnbWVudHMgKiAyO1xyXG5cclxuXHRcdFx0Zm9yICggcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNsZW4xID0gdmxlbiAqIHM7XHJcblx0XHRcdFx0dmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcclxuXHJcblx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcclxuXHRcdFx0XHRcdGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcclxuXHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcclxuXHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcclxuXHJcblx0XHRcdFx0ZjQoIGEsIGIsIGMsIGQsIGNvbnRvdXIsIHMsIHNsLCBqLCBrICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcclxuXHJcblx0XHRhICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0YyArPSBzaGFwZXNPZmZzZXQ7XHJcblxyXG5cdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCAwICkgKTtcclxuXHJcblx0XHR2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIGEsIGIsIGMgKTtcclxuXHJcblx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZzICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQsIHdhbGxDb250b3VyLCBzdGVwSW5kZXgsIHN0ZXBzTGVuZ3RoLCBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xyXG5cclxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRjICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGQgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cclxuXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgbnVsbCwgbnVsbCwgMSApICk7XHJcblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIG51bGwsIG51bGwsIDEgKSApO1xyXG5cclxuXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBhLCBiLCBjLCBkICk7XHJcblxyXG5cdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAwIF0sIHV2c1sgMSBdLCB1dnNbIDMgXSBdICk7XHJcblx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDEgXSwgdXZzWyAyIF0sIHV2c1sgMyBdIF0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xyXG5cclxuXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xyXG5cdFx0dmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XHJcblx0XHR2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYS54LCBhLnkgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGIueCwgYi55ICksXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIGMueSApXHJcblx0XHRdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHR2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcclxuXHRcdHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xyXG5cdFx0dmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XHJcblx0XHR2YXIgZCA9IHZlcnRpY2VzWyBpbmRleEQgXTtcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBhLnkgLSBiLnkgKSA8IDAuMDEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIDEgLSBhLnogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYi54LCAxIC0gYi56ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgMSAtIGMueiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBkLngsIDEgLSBkLnogKVxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhLnksIDEgLSBhLnogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYi55LCAxIC0gYi56ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueSwgMSAtIGMueiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBkLnksIDEgLSBkLnogKVxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU2hhcGVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxyXG4gKlxyXG4gKiBDcmVhdGVzIGEgb25lLXNpZGVkIHBvbHlnb25hbCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS4gU2ltaWxhciB0b1xyXG4gKiBFeHRydWRlR2VvbWV0cnkuXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqXHJcbiAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxyXG4gKlxyXG4gKlx0bWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xyXG4gKlx0dXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcclxuICpcclxuICogfVxyXG4gKiovXHJcblxyXG5USFJFRS5TaGFwZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xyXG5cclxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHNoYXBlcyA9IFsgc2hhcGVzIF07XHJcblxyXG5cdHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlR2VvbWV0cnk7XHJcblxyXG4vKipcclxuICogQWRkIGFuIGFycmF5IG9mIHNoYXBlcyB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LlxyXG4gKi9cclxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlc1sgaSBdLCBvcHRpb25zICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBzaGFwZSB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LCBiYXNlZCBvbiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuXHJcbiAqL1xyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XHJcblxyXG5cdGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xyXG5cdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcclxuXHR2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yID09PSB1bmRlZmluZWQgPyBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA6IG9wdGlvbnMuVVZHZW5lcmF0b3I7XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBpLCBsLCBob2xlO1xyXG5cclxuXHR2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblx0dmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcclxuXHR2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcclxuXHJcblx0dmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XHJcblxyXG5cdGlmICggcmV2ZXJzZSApIHtcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcclxuXHJcblx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlLi4uXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aG9sZSA9IGhvbGVzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0aG9sZXNbIGkgXSA9IGhvbGUucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXZlcnNlID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGZhY2VzID0gVEhSRUUuU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcclxuXHJcblx0Ly8gVmVydGljZXNcclxuXHJcblx0Zm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdGhvbGUgPSBob2xlc1sgaSBdO1xyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGhvbGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHR2YXIgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuXHRcdHZlcnQgPSB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnQueCwgdmVydC55LCAwICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0dmFyIGEgPSBmYWNlWyAwIF0gKyBzaGFwZXNPZmZzZXQ7XHJcblx0XHR2YXIgYiA9IGZhY2VbIDEgXSArIHNoYXBlc09mZnNldDtcclxuXHRcdHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCBtYXRlcmlhbCApICk7XHJcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZVRvcFVWKCB0aGlzLCBhLCBiLCBjICkgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0xhdGhlR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzIFxyXG4vLyAgICBsaWtlIHNvOiBbIGEsIGIsIGMsIGQsIGEgXSwgc2VlIGZpcnN0IGlzIHRoZSBzYW1lIGFzIGxhc3QuXHJcbi8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxyXG4vLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cclxuLy8gcGhpTGVuZ3RoIC0gdGhlIHJhZGlhbiAoMCB0byAyKlBJKSByYW5nZSBvZiB0aGUgbGF0aGVkIHNlY3Rpb25cclxuLy8gICAgMipwaSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXHJcblxyXG5USFJFRS5MYXRoZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cG9pbnRzOiBwb2ludHMsXHJcblx0XHRzZWdtZW50czogc2VnbWVudHMsXHJcblx0XHRwaGlTdGFydDogcGhpU3RhcnQsXHJcblx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHNlZ21lbnRzID0gc2VnbWVudHMgfHwgMTI7XHJcblx0cGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xyXG5cdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCB8fCAyICogTWF0aC5QSTtcclxuXHJcblx0dmFyIGludmVyc2VQb2ludExlbmd0aCA9IDEuMCAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcclxuXHR2YXIgaW52ZXJzZVNlZ21lbnRzID0gMS4wIC8gc2VnbWVudHM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8PSBpbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHBoaSApLFxyXG5cdFx0XHRzID0gTWF0aC5zaW4oIHBoaSApO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcHQgPSBwb2ludHNbIGogXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dmVydGV4LnggPSBjICogcHQueCAtIHMgKiBwdC55O1xyXG5cdFx0XHR2ZXJ0ZXgueSA9IHMgKiBwdC54ICsgYyAqIHB0Lnk7XHJcblx0XHRcdHZlcnRleC56ID0gcHQuejtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHZhciBucCA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoIC0gMTsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGJhc2UgPSBqICsgbnAgKiBpO1xyXG5cdFx0XHR2YXIgYSA9IGJhc2U7XHJcblx0XHRcdHZhciBiID0gYmFzZSArIG5wO1xyXG5cdFx0XHR2YXIgYyA9IGJhc2UgKyAxICsgbnA7XHJcblx0XHRcdHZhciBkID0gYmFzZSArIDE7XHJcblxyXG5cdFx0XHR2YXIgdTAgPSBpICogaW52ZXJzZVNlZ21lbnRzO1xyXG5cdFx0XHR2YXIgdjAgPSBqICogaW52ZXJzZVBvaW50TGVuZ3RoO1xyXG5cdFx0XHR2YXIgdTEgPSB1MCArIGludmVyc2VTZWdtZW50cztcclxuXHRcdFx0dmFyIHYxID0gdjAgKyBpbnZlcnNlUG9pbnRMZW5ndGg7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcblxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjAgKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXHJcblxyXG5cdFx0XHRdICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcblxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjAgKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYxICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXHJcblxyXG5cdFx0XHRdICk7XHJcblxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxhdGhlR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXHJcbiAqL1xyXG5cclxuVEhSRUUuUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHR3aWR0aDogd2lkdGgsXHJcblx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcclxuXHR9O1xyXG5cclxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lR2VvbWV0cnk7XHJcblxyXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShcclxuXHRcdHBhcmFtZXRlcnMud2lkdGgsXHJcblx0XHRwYXJhbWV0ZXJzLmhlaWdodCxcclxuXHRcdHBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcclxuXHRcdHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHNcclxuXHQpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcclxuICovXHJcblxyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHdpZHRoOiB3aWR0aCxcclxuXHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xyXG5cdH07XHJcblxyXG5cdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xyXG5cdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XHJcblxyXG5cdHZhciBncmlkWCA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xyXG5cdHZhciBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcclxuXHJcblx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcclxuXHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xyXG5cclxuXHR2YXIgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XHJcblx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcclxuXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcclxuXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMiApO1xyXG5cclxuXHR2YXIgb2Zmc2V0ID0gMDtcclxuXHR2YXIgb2Zmc2V0MiA9IDA7XHJcblxyXG5cdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcclxuXHJcblx0XHR2YXIgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1sgb2Zmc2V0IF0gPSB4O1xyXG5cdFx0XHR2ZXJ0aWNlc1sgb2Zmc2V0ICsgMSBdID0gLSB5O1xyXG5cclxuXHRcdFx0bm9ybWFsc1sgb2Zmc2V0ICsgMiBdID0gMTtcclxuXHJcblx0XHRcdHV2c1sgb2Zmc2V0MiBdID0gaXggLyBncmlkWDtcclxuXHRcdFx0dXZzWyBvZmZzZXQyICsgMSBdID0gMSAtICggaXkgLyBncmlkWSApO1xyXG5cclxuXHRcdFx0b2Zmc2V0ICs9IDM7XHJcblx0XHRcdG9mZnNldDIgKz0gMjtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0b2Zmc2V0ID0gMDtcclxuXHJcblx0dmFyIGluZGljZXMgPSBuZXcgKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBncmlkWCAqIGdyaWRZICogNiApO1xyXG5cclxuXHRmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcclxuXHJcblx0XHRcdHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcclxuXHRcdFx0dmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xyXG5cclxuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0IF0gPSBhO1xyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyAxIF0gPSBiO1xyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyAyIF0gPSBkO1xyXG5cclxuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgMyBdID0gYjtcclxuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgNCBdID0gYztcclxuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgNSBdID0gZDtcclxuXHJcblx0XHRcdG9mZnNldCArPSA2O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoXHJcblx0XHRwYXJhbWV0ZXJzLndpZHRoLFxyXG5cdFx0cGFyYW1ldGVycy5oZWlnaHQsXHJcblx0XHRwYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXHJcblx0XHRwYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9SaW5nR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEthbGViIE11cnBoeVxyXG4gKi9cclxuXHJcblRIUkVFLlJpbmdHZW9tZXRyeSA9IGZ1bmN0aW9uICggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuXHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuXHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXHJcblx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXHJcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0fTtcclxuXHJcblx0aW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCAwO1xyXG5cdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XHJcblxyXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHR0aGV0YVNlZ21lbnRzID0gdGhldGFTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKSA6IDg7XHJcblx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiA4O1xyXG5cclxuXHR2YXIgaSwgbywgdXZzID0gW10sIHJhZGl1cyA9IGlubmVyUmFkaXVzLCByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHMgKyAxOyBpICsrICkge1xyXG5cclxuXHRcdC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuXHRcdGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyArIDE7IG8gKysgKSB7XHJcblxyXG5cdFx0XHQvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIG8gLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XHJcblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcclxuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuXHRcdHZhciB0aGV0YVNlZ21lbnQgPSBpICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xyXG5cclxuXHRcdGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyA7IG8gKysgKSB7XHJcblxyXG5cdFx0XHQvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxyXG5cclxuXHRcdFx0dmFyIHNlZ21lbnQgPSBvICsgdGhldGFTZWdtZW50O1xyXG5cclxuXHRcdFx0dmFyIHYxID0gc2VnbWVudDtcclxuXHRcdFx0dmFyIHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xyXG5cdFx0XHR2YXIgdjMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0djEgPSBzZWdtZW50O1xyXG5cdFx0XHR2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcclxuXHRcdFx0djMgPSBzZWdtZW50ICsgMTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SaW5nR2VvbWV0cnk7XHJcblxyXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXHJcblx0XHRwYXJhbWV0ZXJzLmlubmVyUmFkaXVzLFxyXG5cdFx0cGFyYW1ldGVycy5vdXRlclJhZGl1cyxcclxuXHRcdHBhcmFtZXRlcnMudGhldGFTZWdtZW50cyxcclxuXHRcdHBhcmFtZXRlcnMucGhpU2VnbWVudHMsXHJcblx0XHRwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcblx0XHRwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcclxuXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxyXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlR2VvbWV0cnk7XHJcblxyXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxyXG5cdFx0cGFyYW1ldGVycy5yYWRpdXMsXHJcblx0XHRwYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXHJcblx0XHRwYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxyXG5cdFx0cGFyYW1ldGVycy5waGlTdGFydCxcclxuXHRcdHBhcmFtZXRlcnMucGhpTGVuZ3RoLFxyXG5cdFx0cGFyYW1ldGVycy50aGV0YVN0YXJ0LFxyXG5cdFx0cGFyYW1ldGVycy50aGV0YUxlbmd0aFxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICogYmFzZWQgb24gVEhSRUUuU3BoZXJlR2VvbWV0cnlcclxuICovXHJcblxyXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG5cdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxyXG5cdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXHJcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0fTtcclxuXHJcblx0cmFkaXVzID0gcmFkaXVzIHx8IDUwO1xyXG5cclxuXHR3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCA4ICk7XHJcblx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XHJcblxyXG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcclxuXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XHJcblx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xyXG5cclxuXHR2YXIgdGhldGFFbmQgPSB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGg7XHJcblxyXG5cdHZhciB2ZXJ0ZXhDb3VudCA9ICggKCB3aWR0aFNlZ21lbnRzICsgMSApICogKCBoZWlnaHRTZWdtZW50cyArIDEgKSApO1xyXG5cclxuXHR2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcclxuXHR2YXIgbm9ybWFscyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XHJcblx0dmFyIHV2cyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMiApLCAyICk7XHJcblxyXG5cdHZhciBpbmRleCA9IDAsIHZlcnRpY2VzID0gW10sIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdGZvciAoIHZhciB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXNSb3cgPSBbXTtcclxuXHJcblx0XHR2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcclxuXHJcblx0XHRmb3IgKCB2YXIgeCA9IDA7IHggPD0gd2lkdGhTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB1ID0geCAvIHdpZHRoU2VnbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgcHggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblx0XHRcdHZhciBweSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblx0XHRcdHZhciBweiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdFx0XHRub3JtYWwuc2V0KCBweCwgcHksIHB6ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRwb3NpdGlvbnMuc2V0WFlaKCBpbmRleCwgcHgsIHB5LCBweiApO1xyXG5cdFx0XHRub3JtYWxzLnNldFhZWiggaW5kZXgsIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHRcdFx0dXZzLnNldFhZKCBpbmRleCwgdSwgMSAtIHYgKTtcclxuXHJcblx0XHRcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICk7XHJcblxyXG5cdFx0XHRpbmRleCArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcclxuXHJcblx0XHRcdGlmICggeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggdjEsIHYyLCB2NCApO1xyXG5cdFx0XHRpZiAoIHkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSB8fCB0aGV0YUVuZCA8IE1hdGguUEkgKSBpbmRpY2VzLnB1c2goIHYyLCB2MywgdjQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5zZXRJbmRleCggbmV3ICggcG9zaXRpb25zLmNvdW50ID4gNjU1MzUgPyBUSFJFRS5VaW50MzJBdHRyaWJ1dGUgOiBUSFJFRS5VaW50MTZBdHRyaWJ1dGUgKSggaW5kaWNlcywgMSApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xyXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFscyApO1xyXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeTtcclxuXHJcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoXHJcblx0XHRwYXJhbWV0ZXJzLnJhZGl1cyxcclxuXHRcdHBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcclxuXHRcdHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRwYXJhbWV0ZXJzLnBoaVN0YXJ0LFxyXG5cdFx0cGFyYW1ldGVycy5waGlMZW5ndGgsXHJcblx0XHRwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcblx0XHRwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxyXG4gKi9cclxuXHJcblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHR0dWJlOiB0dWJlLFxyXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRhcmM6IGFyY1xyXG5cdH07XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XHJcblx0dHViZSA9IHR1YmUgfHwgNDA7XHJcblx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG5cdHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xyXG5cdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcclxuXHJcblx0dmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHV2cyA9IFtdLCBub3JtYWxzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xyXG5cdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xyXG5cclxuXHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XHJcblx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xyXG5cdFx0XHRub3JtYWxzLnB1c2goIHZlcnRleC5jbG9uZSgpLnN1YiggY2VudGVyICkubm9ybWFsaXplKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xyXG5cdFx0XHR2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XHJcblx0XHRcdHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG5cdFx0XHR2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgWyBub3JtYWxzWyBhIF0uY2xvbmUoKSwgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBbIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBjIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGMgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzR2VvbWV0cnk7XHJcblxyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcclxuXHRcdHBhcmFtZXRlcnMucmFkaXVzLFxyXG5cdFx0cGFyYW1ldGVycy50dWJlLFxyXG5cdFx0cGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcclxuXHRcdHBhcmFtZXRlcnMudHVidWxhclNlZ21lbnRzLFxyXG5cdFx0cGFyYW1ldGVycy5hcmNcclxuXHQpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RvcnVzS25vdEdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcclxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNEL3NyYy9hd2F5M2QvcHJpbWl0aXZlcy9Ub3J1c0tub3QuYXM/c3BlYz1zdm4yNDczJnI9MjQ3M1xyXG4gKi9cclxuXHJcblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIHAsIHEsIGhlaWdodFNjYWxlICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0dHViZTogdHViZSxcclxuXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxyXG5cdFx0cDogcCxcclxuXHRcdHE6IHEsXHJcblx0XHRoZWlnaHRTY2FsZTogaGVpZ2h0U2NhbGVcclxuXHR9O1xyXG5cclxuXHRyYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xyXG5cdHR1YmUgPSB0dWJlIHx8IDQwO1xyXG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgNjQ7XHJcblx0dHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDg7XHJcblx0cCA9IHAgfHwgMjtcclxuXHRxID0gcSB8fCAzO1xyXG5cdGhlaWdodFNjYWxlID0gaGVpZ2h0U2NhbGUgfHwgMTtcclxuXHJcblx0dmFyIGdyaWQgPSBuZXcgQXJyYXkoIHJhZGlhbFNlZ21lbnRzICk7XHJcblx0dmFyIHRhbmcgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKysgaSApIHtcclxuXHJcblx0XHRncmlkWyBpIF0gPSBuZXcgQXJyYXkoIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cdFx0dmFyIHUgPSBpIC8gcmFkaWFsU2VnbWVudHMgKiAyICogcCAqIE1hdGguUEk7XHJcblx0XHR2YXIgcDEgPSBnZXRQb3MoIHUsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcclxuXHRcdHZhciBwMiA9IGdldFBvcyggdSArIDAuMDEsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcclxuXHRcdHRhbmcuc3ViVmVjdG9ycyggcDIsIHAxICk7XHJcblx0XHRuLmFkZFZlY3RvcnMoIHAyLCBwMSApO1xyXG5cclxuXHRcdGJpdGFuLmNyb3NzVmVjdG9ycyggdGFuZywgbiApO1xyXG5cdFx0bi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XHJcblx0XHRiaXRhbi5ub3JtYWxpemUoKTtcclxuXHRcdG4ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuXHRcdFx0dmFyIHYgPSBqIC8gdHVidWxhclNlZ21lbnRzICogMiAqIE1hdGguUEk7XHJcblx0XHRcdHZhciBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXHJcblx0XHRcdHZhciBjeSA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xyXG5cclxuXHRcdFx0dmFyIHBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHBvcy54ID0gcDEueCArIGN4ICogbi54ICsgY3kgKiBiaXRhbi54O1xyXG5cdFx0XHRwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcclxuXHRcdFx0cG9zLnogPSBwMS56ICsgY3ggKiBuLnogKyBjeSAqIGJpdGFuLno7XHJcblxyXG5cdFx0XHRncmlkWyBpIF1bIGogXSA9IHRoaXMudmVydGljZXMucHVzaCggcG9zICkgLSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKysgaSApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB0dWJ1bGFyU2VnbWVudHM7ICsrIGogKSB7XHJcblxyXG5cdFx0XHR2YXIgaXAgPSAoIGkgKyAxICkgJSByYWRpYWxTZWdtZW50cztcclxuXHRcdFx0dmFyIGpwID0gKCBqICsgMSApICUgdHVidWxhclNlZ21lbnRzO1xyXG5cclxuXHRcdFx0dmFyIGEgPSBncmlkWyBpIF1bIGogXTtcclxuXHRcdFx0dmFyIGIgPSBncmlkWyBpcCBdWyBqIF07XHJcblx0XHRcdHZhciBjID0gZ3JpZFsgaXAgXVsganAgXTtcclxuXHRcdFx0dmFyIGQgPSBncmlkWyBpIF1bIGpwIF07XHJcblxyXG5cdFx0XHR2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cdFx0XHR2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCBqIC8gdHVidWxhclNlZ21lbnRzICk7XHJcblx0XHRcdHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cdFx0XHR2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0UG9zKCB1LCBpbl9xLCBpbl9wLCByYWRpdXMsIGhlaWdodFNjYWxlICkge1xyXG5cclxuXHRcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XHJcblx0XHR2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xyXG5cdFx0dmFyIHF1T3ZlclAgPSBpbl9xIC8gaW5fcCAqIHU7XHJcblx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xyXG5cclxuXHRcdHZhciB0eCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcclxuXHRcdHZhciB0eSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcclxuXHRcdHZhciB0eiA9IGhlaWdodFNjYWxlICogcmFkaXVzICogTWF0aC5zaW4oIHF1T3ZlclAgKSAqIDAuNTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeTtcclxuXHJcblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXHJcblx0XHRwYXJhbWV0ZXJzLnJhZGl1cyxcclxuXHRcdHBhcmFtZXRlcnMudHViZSxcclxuXHRcdHBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXHJcblx0XHRwYXJhbWV0ZXJzLnR1YnVsYXJTZWdtZW50cyxcclxuXHRcdHBhcmFtZXRlcnMucCxcclxuXHRcdHBhcmFtZXRlcnMucSxcclxuXHRcdHBhcmFtZXRlcnMuaGVpZ2h0U2NhbGVcclxuXHQpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1R1YmVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcclxuICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXHJcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25vYnIxXHJcbiAqXHJcbiAqIE1vZGlmaWVkIGZyb20gdGhlIFRvcnVzS25vdEdlb21ldHJ5IGJ5IEBvb3Ntb3hpZWNvZGVcclxuICpcclxuICogQ3JlYXRlcyBhIHR1YmUgd2hpY2ggZXh0cnVkZXMgYWxvbmcgYSAzZCBzcGxpbmVcclxuICpcclxuICogVXNlcyBwYXJhbGxlbCB0cmFuc3BvcnQgZnJhbWVzIGFzIGRlc2NyaWJlZCBpblxyXG4gKiBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcclxuICovXHJcblxyXG5USFJFRS5UdWJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBhdGgsIHNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQsIHRhcGVyICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRwYXRoOiBwYXRoLFxyXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHRjbG9zZWQ6IGNsb3NlZCxcclxuXHRcdHRhcGVyOiB0YXBlclxyXG5cdH07XHJcblxyXG5cdHNlZ21lbnRzID0gc2VnbWVudHMgfHwgNjQ7XHJcblx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XHJcblx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG5cdGNsb3NlZCA9IGNsb3NlZCB8fCBmYWxzZTtcclxuXHR0YXBlciA9IHRhcGVyIHx8IFRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyO1xyXG5cclxuXHR2YXIgZ3JpZCA9IFtdO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzLFxyXG5cclxuXHRcdHRhbmdlbnQsXHJcblx0XHRub3JtYWwsXHJcblx0XHRiaW5vcm1hbCxcclxuXHJcblx0XHRudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXHJcblxyXG5cdFx0dSwgdiwgcixcclxuXHJcblx0XHRjeCwgY3ksXHJcblx0XHRwb3MsIHBvczIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0aSwgaixcclxuXHRcdGlwLCBqcCxcclxuXHRcdGEsIGIsIGMsIGQsXHJcblx0XHR1dmEsIHV2YiwgdXZjLCB1dmQ7XHJcblxyXG5cdHZhciBmcmFtZXMgPSBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApLFxyXG5cdFx0dGFuZ2VudHMgPSBmcmFtZXMudGFuZ2VudHMsXHJcblx0XHRub3JtYWxzID0gZnJhbWVzLm5vcm1hbHMsXHJcblx0XHRiaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xyXG5cclxuXHQvLyBwcm94eSBpbnRlcm5hbHNcclxuXHR0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XHJcblx0dGhpcy5ub3JtYWxzID0gbm9ybWFscztcclxuXHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcclxuXHJcblx0ZnVuY3Rpb24gdmVydCggeCwgeSwgeiApIHtcclxuXHJcblx0XHRyZXR1cm4gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApIC0gMTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBjb25zdHJ1Y3QgdGhlIGdyaWRcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XHJcblxyXG5cdFx0Z3JpZFsgaSBdID0gW107XHJcblxyXG5cdFx0dSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcblx0XHRwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcclxuXHJcblx0XHR0YW5nZW50ID0gdGFuZ2VudHNbIGkgXTtcclxuXHRcdG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcclxuXHRcdGJpbm9ybWFsID0gYmlub3JtYWxzWyBpIF07XHJcblxyXG5cdFx0ciA9IHJhZGl1cyAqIHRhcGVyKCB1ICk7XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRcdHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiAyICogTWF0aC5QSTtcclxuXHJcblx0XHRcdGN4ID0gLSByICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cclxuXHRcdFx0Y3kgPSByICogTWF0aC5zaW4oIHYgKTtcclxuXHJcblx0XHRcdHBvczIuY29weSggcG9zICk7XHJcblx0XHRcdHBvczIueCArPSBjeCAqIG5vcm1hbC54ICsgY3kgKiBiaW5vcm1hbC54O1xyXG5cdFx0XHRwb3MyLnkgKz0gY3ggKiBub3JtYWwueSArIGN5ICogYmlub3JtYWwueTtcclxuXHRcdFx0cG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XHJcblxyXG5cdFx0XHRncmlkWyBpIF1bIGogXSA9IHZlcnQoIHBvczIueCwgcG9zMi55LCBwb3MyLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIGNvbnN0cnVjdCB0aGUgbWVzaFxyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRpcCA9ICggY2xvc2VkICkgPyAoIGkgKyAxICkgJSBzZWdtZW50cyA6IGkgKyAxO1xyXG5cdFx0XHRqcCA9ICggaiArIDEgKSAlIHJhZGlhbFNlZ21lbnRzO1xyXG5cclxuXHRcdFx0YSA9IGdyaWRbIGkgXVsgaiBdO1x0XHQvLyAqKiogTk9UIE5FQ0VTU0FSSUxZIFBMQU5BUiAhICoqKlxyXG5cdFx0XHRiID0gZ3JpZFsgaXAgXVsgaiBdO1xyXG5cdFx0XHRjID0gZ3JpZFsgaXAgXVsganAgXTtcclxuXHRcdFx0ZCA9IGdyaWRbIGkgXVsganAgXTtcclxuXHJcblx0XHRcdHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xyXG5cdFx0XHR1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xyXG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XHJcblx0XHRcdHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UdWJlR2VvbWV0cnk7XHJcblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnBhcmFtZXRlcnMucGF0aCxcclxuXHRcdHRoaXMucGFyYW1ldGVycy5zZWdtZW50cywgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cywgdGhpcy5wYXJhbWV0ZXJzLnJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzLmNsb3NlZCwgdGhpcy5wYXJhbWV0ZXJzLnRhcGVyXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlciA9IGZ1bmN0aW9uICggdSApIHtcclxuXHJcblx0cmV0dXJuIDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5LlNpbnVzb2lkYWxUYXBlciA9IGZ1bmN0aW9uICggdSApIHtcclxuXHJcblx0cmV0dXJuIE1hdGguc2luKCBNYXRoLlBJICogdSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZvciBjb21wdXRpbmcgb2YgRnJlbmV0IGZyYW1lcywgZXhwb3NpbmcgdGhlIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHMgdGhlIHNwbGluZVxyXG5USFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICkge1xyXG5cclxuXHR2YXJcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdFx0dGFuZ2VudHMgPSBbXSxcclxuXHRcdG5vcm1hbHMgPSBbXSxcclxuXHRcdGJpbm9ybWFscyA9IFtdLFxyXG5cclxuXHRcdHZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRtYXQgPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRcdG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcclxuXHRcdHRoZXRhLFxyXG5cdFx0c21hbGxlc3QsXHJcblxyXG5cdFx0dHgsIHR5LCB0eixcclxuXHRcdGksIHU7XHJcblxyXG5cclxuXHQvLyBleHBvc2UgaW50ZXJuYWxzXHJcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xyXG5cdHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XHJcblx0dGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XHJcblxyXG5cdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xyXG5cclxuXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XHJcblxyXG5cdFx0dGFuZ2VudHNbIGkgXSA9IHBhdGguZ2V0VGFuZ2VudEF0KCB1ICk7XHJcblx0XHR0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGluaXRpYWxOb3JtYWwzKCk7XHJcblxyXG5cdC8qXHJcblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDEobGFzdEJpbm9ybWFsKSB7XHJcblx0XHQvLyBmaXhlZCBzdGFydCBiaW5vcm1hbC4gSGFzIGRhbmdlcnMgb2YgMCB2ZWN0b3JzXHJcblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0aWYgKGxhc3RCaW5vcm1hbD09PXVuZGVmaW5lZCkgbGFzdEJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGxhc3RCaW5vcm1hbCwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwyKCkge1xyXG5cclxuXHRcdC8vIFRoaXMgdXNlcyB0aGUgRnJlbmV0LVNlcnJldCBmb3JtdWxhIGZvciBkZXJpdmluZyBiaW5vcm1hbFxyXG5cdFx0dmFyIHQyID0gcGF0aC5nZXRUYW5nZW50QXQoIGVwc2lsb24gKTtcclxuXHJcblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLnN1YlZlY3RvcnMoIHQyLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcclxuXHJcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBiaW5vcm1hbHNbIDAgXSwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpOyAvLyBsYXN0IGJpbm9ybWFsIHggdGFuZ2VudFxyXG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHJcblx0fVxyXG5cdCovXHJcblxyXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwzKCkge1xyXG5cclxuXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXHJcblx0XHQvLyBhbmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc21hbGxlc3QgdGFuZ2VudCB4eXogY29tcG9uZW50XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHNtYWxsZXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHRcdHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xyXG5cdFx0dHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XHJcblx0XHR0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcclxuXHJcblx0XHRpZiAoIHR4IDw9IHNtYWxsZXN0ICkge1xyXG5cclxuXHRcdFx0c21hbGxlc3QgPSB0eDtcclxuXHRcdFx0bm9ybWFsLnNldCggMSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR5IDw9IHNtYWxsZXN0ICkge1xyXG5cclxuXHRcdFx0c21hbGxlc3QgPSB0eTtcclxuXHRcdFx0bm9ybWFsLnNldCggMCwgMSwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR6IDw9IHNtYWxsZXN0ICkge1xyXG5cclxuXHRcdFx0bm9ybWFsLnNldCggMCwgMCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXHJcblxyXG5cdGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xyXG5cclxuXHRcdG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XHJcblxyXG5cdFx0aWYgKCB2ZWMubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdHZlYy5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xyXG5cclxuXHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXHJcblxyXG5cdGlmICggY2xvc2VkICkge1xyXG5cclxuXHRcdHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSwgLSAxLCAxICkgKTtcclxuXHRcdHRoZXRhIC89ICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuXHRcdGlmICggdGFuZ2VudHNbIDAgXS5kb3QoIHZlYy5jcm9zc1ZlY3RvcnMoIG5vcm1hbHNbIDAgXSwgbm9ybWFsc1sgbnVtcG9pbnRzIC0gMSBdICkgKSA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGV0YSA9IC0gdGhldGE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gdHdpc3QgYSBsaXR0bGUuLi5cclxuXHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XHJcblx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUG9seWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuKi9cclxuXHJcblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHR2ZXJ0aWNlczogdmVydGljZXMsXHJcblx0XHRpbmRpY2VzOiBpbmRpY2VzLFxyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRkZXRhaWw6IGRldGFpbFxyXG5cdH07XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xyXG5cdGRldGFpbCA9IGRldGFpbCB8fCAwO1xyXG5cclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRwcmVwYXJlKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIHZlcnRpY2VzWyBpICsgMiBdICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgcCA9IHRoaXMudmVydGljZXM7XHJcblxyXG5cdHZhciBmYWNlcyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMsIGogKysgKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gcFsgaW5kaWNlc1sgaSBdIF07XHJcblx0XHR2YXIgdjIgPSBwWyBpbmRpY2VzWyBpICsgMSBdIF07XHJcblx0XHR2YXIgdjMgPSBwWyBpbmRpY2VzWyBpICsgMiBdIF07XHJcblxyXG5cdFx0ZmFjZXNbIGogXSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0sIHVuZGVmaW5lZCwgaiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBjZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0c3ViZGl2aWRlKCBmYWNlc1sgaSBdLCBkZXRhaWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbVxyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciB1dnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xyXG5cclxuXHRcdHZhciB4MCA9IHV2c1sgMCBdLng7XHJcblx0XHR2YXIgeDEgPSB1dnNbIDEgXS54O1xyXG5cdFx0dmFyIHgyID0gdXZzWyAyIF0ueDtcclxuXHJcblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHgwLCB4MSwgeDIgKTtcclxuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIHgxLCB4MiApO1xyXG5cclxuXHRcdGlmICggbWF4ID4gMC45ICYmIG1pbiA8IDAuMSApIHtcclxuXHJcblx0XHRcdC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcclxuXHJcblx0XHRcdGlmICggeDAgPCAwLjIgKSB1dnNbIDAgXS54ICs9IDE7XHJcblx0XHRcdGlmICggeDEgPCAwLjIgKSB1dnNbIDEgXS54ICs9IDE7XHJcblx0XHRcdGlmICggeDIgPCAwLjIgKSB1dnNbIDIgXS54ICs9IDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBcHBseSByYWRpdXNcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXNbIGkgXS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIE1lcmdlIHZlcnRpY2VzXHJcblxyXG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG5cclxuXHQvLyBQcm9qZWN0IHZlY3RvciBvbnRvIHNwaGVyZSdzIHN1cmZhY2VcclxuXHJcblx0ZnVuY3Rpb24gcHJlcGFyZSggdmVjdG9yICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0ZXggPSB2ZWN0b3Iubm9ybWFsaXplKCkuY2xvbmUoKTtcclxuXHRcdHZlcnRleC5pbmRleCA9IHRoYXQudmVydGljZXMucHVzaCggdmVydGV4ICkgLSAxO1xyXG5cclxuXHRcdC8vIFRleHR1cmUgY29vcmRzIGFyZSBlcXVpdmFsZW50IHRvIG1hcCBjb29yZHMsIGNhbGN1bGF0ZSBhbmdsZSBhbmQgY29udmVydCB0byBmcmFjdGlvbiBvZiBhIGNpcmNsZS5cclxuXHJcblx0XHR2YXIgdSA9IGF6aW11dGgoIHZlY3RvciApIC8gMiAvIE1hdGguUEkgKyAwLjU7XHJcblx0XHR2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZWN0b3IgKSAvIE1hdGguUEkgKyAwLjU7XHJcblx0XHR2ZXJ0ZXgudXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKTtcclxuXHJcblx0XHRyZXR1cm4gdmVydGV4O1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBcHByb3hpbWF0ZSBhIGN1cnZlZCBmYWNlIHdpdGggcmVjdXJzaXZlbHkgc3ViLWRpdmlkZWQgdHJpYW5nbGVzLlxyXG5cclxuXHRmdW5jdGlvbiBtYWtlKCB2MSwgdjIsIHYzLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSwgdW5kZWZpbmVkLCBtYXRlcmlhbEluZGV4ICk7XHJcblx0XHR0aGF0LmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHJcblx0XHRjZW50cm9pZC5jb3B5KCB2MSApLmFkZCggdjIgKS5hZGQoIHYzICkuZGl2aWRlU2NhbGFyKCAzICk7XHJcblxyXG5cdFx0dmFyIGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XHJcblxyXG5cdFx0dGhhdC5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cdFx0XHRjb3JyZWN0VVYoIHYxLnV2LCB2MSwgYXppICksXHJcblx0XHRcdGNvcnJlY3RVViggdjIudXYsIHYyLCBhemkgKSxcclxuXHRcdFx0Y29ycmVjdFVWKCB2My51diwgdjMsIGF6aSApXHJcblx0XHRdICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEFuYWx5dGljYWxseSBzdWJkaXZpZGUgYSBmYWNlIHRvIHRoZSByZXF1aXJlZCBkZXRhaWwgbGV2ZWwuXHJcblxyXG5cdGZ1bmN0aW9uIHN1YmRpdmlkZSggZmFjZSwgZGV0YWlsICkge1xyXG5cclxuXHRcdHZhciBjb2xzID0gTWF0aC5wb3coIDIsIGRldGFpbCApO1xyXG5cdFx0dmFyIGEgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0dmFyIGIgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0dmFyIGMgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cdFx0dmFyIHYgPSBbXTtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHQvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvbi5cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAgOyBpIDw9IGNvbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2WyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdHZhciBhaiA9IHByZXBhcmUoIGEuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XHJcblx0XHRcdHZhciBiaiA9IHByZXBhcmUoIGIuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XHJcblx0XHRcdHZhciByb3dzID0gY29scyAtIGk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcm93czsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhajtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IHByZXBhcmUoIGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlcy5cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb2xzIDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDIgKiAoIGNvbHMgLSBpICkgLSAxOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XHJcblxyXG5cdFx0XHRcdGlmICggaiAlIDIgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWFrZShcclxuXHRcdFx0XHRcdFx0dlsgaSBdWyBrICsgMSBdLFxyXG5cdFx0XHRcdFx0XHR2WyBpICsgMSBdWyBrIF0sXHJcblx0XHRcdFx0XHRcdHZbIGkgXVsgayBdLFxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4XHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG1ha2UoXHJcblx0XHRcdFx0XHRcdHZbIGkgXVsgayArIDEgXSxcclxuXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayArIDEgXSxcclxuXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdLFxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4XHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXHJcblxyXG5cdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxyXG5cclxuXHRmdW5jdGlvbiBpbmNsaW5hdGlvbiggdmVjdG9yICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBUZXh0dXJlIGZpeGluZyBoZWxwZXIuIFNwaGVyZXMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvdXJzLlxyXG5cclxuXHRmdW5jdGlvbiBjb3JyZWN0VVYoIHV2LCB2ZWN0b3IsIGF6aW11dGggKSB7XHJcblxyXG5cdFx0aWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1di54IC0gMSwgdXYueSApO1xyXG5cdFx0aWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggYXppbXV0aCAvIDIgLyBNYXRoLlBJICsgMC41LCB1di55ICk7XHJcblx0XHRyZXR1cm4gdXYuY2xvbmUoKTtcclxuXHJcblx0fVxyXG5cclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnk7XHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkoXHJcblx0XHRwYXJhbWV0ZXJzLnZlcnRpY2VzLFxyXG5cdFx0cGFyYW1ldGVycy5pbmRpY2VzLFxyXG5cdFx0cGFyYW1ldGVycy5yYWRpdXMsXHJcblx0XHRwYXJhbWV0ZXJzLmRldGFpbFxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRG9kZWNhaGVkcm9uR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcclxuXHR2YXIgciA9IDEgLyB0O1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblxyXG5cdFx0Ly8gKMKxMSwgwrExLCDCsTEpXHJcblx0XHQtIDEsIC0gMSwgLSAxLCAgICAtIDEsIC0gMSwgIDEsXHJcblx0XHQtIDEsICAxLCAtIDEsICAgIC0gMSwgIDEsICAxLFxyXG5cdFx0IDEsIC0gMSwgLSAxLCAgICAgMSwgLSAxLCAgMSxcclxuXHRcdCAxLCAgMSwgLSAxLCAgICAgMSwgIDEsICAxLFxyXG5cclxuXHRcdC8vICgwLCDCsTEvz4YsIMKxz4YpXHJcblx0XHQgMCwgLSByLCAtIHQsICAgICAwLCAtIHIsICB0LFxyXG5cdFx0IDAsICByLCAtIHQsICAgICAwLCAgciwgIHQsXHJcblxyXG5cdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcclxuXHRcdC0gciwgLSB0LCAgMCwgICAgLSByLCAgdCwgIDAsXHJcblx0XHQgciwgLSB0LCAgMCwgICAgIHIsICB0LCAgMCxcclxuXHJcblx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxyXG5cdFx0LSB0LCAgMCwgLSByLCAgICAgdCwgIDAsIC0gcixcclxuXHRcdC0gdCwgIDAsICByLCAgICAgdCwgIDAsICByXHJcblx0XTtcclxuXHJcblx0dmFyIGluZGljZXMgPSBbXHJcblx0XHQgMywgMTEsICA3LCAgICAgIDMsICA3LCAxNSwgICAgICAzLCAxNSwgMTMsXHJcblx0XHQgNywgMTksIDE3LCAgICAgIDcsIDE3LCAgNiwgICAgICA3LCAgNiwgMTUsXHJcblx0XHQxNywgIDQsICA4LCAgICAgMTcsICA4LCAxMCwgICAgIDE3LCAxMCwgIDYsXHJcblx0XHQgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXHJcblx0XHQgMCwgMTIsICAxLCAgICAgIDAsICAxLCAxOCwgICAgICAwLCAxOCwgMTYsXHJcblx0XHQgNiwgMTAsICAyLCAgICAgIDYsICAyLCAxMywgICAgICA2LCAxMywgMTUsXHJcblx0XHQgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXHJcblx0XHQxOCwgIDEsICA5LCAgICAgMTgsICA5LCAxMSwgICAgIDE4LCAxMSwgIDMsXHJcblx0XHQgNCwgMTQsIDEyLCAgICAgIDQsIDEyLCAgMCwgICAgICA0LCAgMCwgIDgsXHJcblx0XHQxMSwgIDksICA1LCAgICAgMTEsICA1LCAxOSwgICAgIDExLCAxOSwgIDcsXHJcblx0XHQxOSwgIDUsIDE0LCAgICAgMTksIDE0LCAgNCwgICAgIDE5LCAgNCwgMTcsXHJcblx0XHQgMSwgMTIsIDE0LCAgICAgIDEsIDE0LCAgNSwgICAgICAxLCAgNSwgIDlcclxuXHRdO1xyXG5cclxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5KFxyXG5cdFx0cGFyYW1ldGVycy5yYWRpdXMsXHJcblx0XHRwYXJhbWV0ZXJzLmRldGFpbFxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuICovXHJcblxyXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gW1xyXG5cdFx0LSAxLCAgdCwgIDAsICAgIDEsICB0LCAgMCwgICAtIDEsIC0gdCwgIDAsICAgIDEsIC0gdCwgIDAsXHJcblx0XHQgMCwgLSAxLCAgdCwgICAgMCwgIDEsICB0LCAgICAwLCAtIDEsIC0gdCwgICAgMCwgIDEsIC0gdCxcclxuXHRcdCB0LCAgMCwgLSAxLCAgICB0LCAgMCwgIDEsICAgLSB0LCAgMCwgLSAxLCAgIC0gdCwgIDAsICAxXHJcblx0XTtcclxuXHJcblx0dmFyIGluZGljZXMgPSBbXHJcblx0XHQgMCwgMTEsICA1LCAgICAwLCAgNSwgIDEsICAgIDAsICAxLCAgNywgICAgMCwgIDcsIDEwLCAgICAwLCAxMCwgMTEsXHJcblx0XHQgMSwgIDUsICA5LCAgICA1LCAxMSwgIDQsICAgMTEsIDEwLCAgMiwgICAxMCwgIDcsICA2LCAgICA3LCAgMSwgIDgsXHJcblx0XHQgMywgIDksICA0LCAgICAzLCAgNCwgIDIsICAgIDMsICAyLCAgNiwgICAgMywgIDYsICA4LCAgICAzLCAgOCwgIDksXHJcblx0XHQgNCwgIDksICA1LCAgICAyLCAgNCwgMTEsICAgIDYsICAyLCAxMCwgICAgOCwgIDYsICA3LCAgICA5LCAgOCwgIDFcclxuXHRdO1xyXG5cclxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRkZXRhaWw6IGRldGFpbFxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeTtcclxuXHJcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxyXG5cdFx0cGFyYW1ldGVycy5yYWRpdXMsXHJcblx0XHRwYXJhbWV0ZXJzLmRldGFpbFxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvT2N0YWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IFtcclxuXHRcdDEsIDAsIDAsICAgLSAxLCAwLCAwLCAgICAwLCAxLCAwLCAgICAwLCAtIDEsIDAsICAgIDAsIDAsIDEsICAgIDAsIDAsIC0gMVxyXG5cdF07XHJcblxyXG5cdHZhciBpbmRpY2VzID0gW1xyXG5cdFx0MCwgMiwgNCwgICAgMCwgNCwgMywgICAgMCwgMywgNSwgICAgMCwgNSwgMiwgICAgMSwgMiwgNSwgICAgMSwgNSwgMywgICAgMSwgMywgNCwgICAgMSwgNCwgMlxyXG5cdF07XHJcblxyXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoXHJcblx0XHRwYXJhbWV0ZXJzLnJhZGl1cyxcclxuXHRcdHBhcmFtZXRlcnMuZGV0YWlsXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXRyYWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHQgMSwgIDEsICAxLCAgIC0gMSwgLSAxLCAgMSwgICAtIDEsICAxLCAtIDEsICAgIDEsIC0gMSwgLSAxXHJcblx0XTtcclxuXHJcblx0dmFyIGluZGljZXMgPSBbXHJcblx0XHQgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXHJcblx0XTtcclxuXHJcblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeShcclxuXHRcdHBhcmFtZXRlcnMucmFkaXVzLFxyXG5cdFx0cGFyYW1ldGVycy5kZXRhaWxcclxuXHQpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BhcmFtZXRyaWNHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcclxuICogYmFzZWQgb24gdGhlIGJyaWxsaWFudCBhcnRpY2xlIGJ5IEBwcmlkZW91dCBodHRwOi8vcHJpZGVvdXQubmV0L2Jsb2cvP3A9NDRcclxuICpcclxuICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMgKTtcclxuICpcclxuICovXHJcblxyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRmdW5jOiBmdW5jLFxyXG5cdFx0c2xpY2VzOiBzbGljZXMsXHJcblx0XHRzdGFja3M6IHN0YWNrc1xyXG5cdH07XHJcblxyXG5cdHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XHJcblx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuXHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XHJcblxyXG5cdHZhciBpLCBqLCBwO1xyXG5cdHZhciB1LCB2O1xyXG5cclxuXHR2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDw9IHN0YWNrczsgaSArKyApIHtcclxuXHJcblx0XHR2ID0gaSAvIHN0YWNrcztcclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XHJcblxyXG5cdFx0XHR1ID0gaiAvIHNsaWNlcztcclxuXHJcblx0XHRcdHAgPSBmdW5jKCB1LCB2ICk7XHJcblx0XHRcdHZlcnRzLnB1c2goIHAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGEsIGIsIGMsIGQ7XHJcblx0dmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkgKysgKSB7XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPCBzbGljZXM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xyXG5cdFx0XHRiID0gaSAqIHNsaWNlQ291bnQgKyBqICsgMTtcclxuXHRcdFx0YyA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqICsgMTtcclxuXHRcdFx0ZCA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqO1xyXG5cclxuXHRcdFx0dXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGogLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcclxuXHRcdFx0dXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xyXG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcclxuXHRcdFx0dXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGogLyBzbGljZXMsICggaSArIDEgKSAvIHN0YWNrcyApO1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcclxuXHRcdFx0dXZzLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XHJcblxyXG5cdFx0XHRmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG5cdFx0XHR1dnMucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNvbnNvbGUubG9nKHRoaXMpO1xyXG5cclxuXHQvLyBtYWdpYyBidWxsZXRcclxuXHQvLyB2YXIgZGlmZiA9IHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cdC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9XaXJlZnJhbWVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gc29ydEZ1bmN0aW9uKCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBhIC0gYjtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xyXG5cclxuXHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcclxuXHRcdHZhciBudW1FZGdlcyA9IDA7XHJcblxyXG5cdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXHJcblx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDYgKiBmYWNlcy5sZW5ndGggKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0ZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XHJcblx0XHRcdFx0ZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XHJcblx0XHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0dmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgXSA9IGVkZ2VbIDAgXTtcclxuXHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XHJcblx0XHRcdFx0XHRoYXNoWyBrZXkgXSA9IHRydWU7XHJcblx0XHRcdFx0XHRudW1FZGdlcyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZWRnZXMgWyAyICogaSArIGogXSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xyXG5cdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0ZXgueDtcclxuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGV4Lnk7XHJcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRleC56O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcclxuXHJcblx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Ly8gSW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRcdFx0dmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleC5hcnJheTtcclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHRcdFx0dmFyIGRyYXdjYWxscyA9IGdlb21ldHJ5LmRyYXdjYWxscztcclxuXHRcdFx0dmFyIG51bUVkZ2VzID0gMDtcclxuXHJcblx0XHRcdGlmICggZHJhd2NhbGxzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcclxuXHRcdFx0dmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCAyICogaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBvID0gMCwgb2wgPSBkcmF3Y2FsbHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkcmF3Y2FsbCA9IGRyYXdjYWxsc1sgbyBdO1xyXG5cclxuXHRcdFx0XHR2YXIgc3RhcnQgPSBkcmF3Y2FsbC5zdGFydDtcclxuXHRcdFx0XHR2YXIgY291bnQgPSBkcmF3Y2FsbC5jb3VudDtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZWRnZVsgMCBdID0gaW5kaWNlc1sgaSArIGogXTtcclxuXHRcdFx0XHRcdFx0ZWRnZVsgMSBdID0gaW5kaWNlc1sgaSArICggaiArIDEgKSAlIDMgXTtcclxuXHRcdFx0XHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgXSA9IGVkZ2VbIDAgXTtcclxuXHRcdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xyXG5cdFx0XHRcdFx0XHRcdGhhc2hbIGtleSBdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRudW1FZGdlcyArKztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcclxuXHRcdFx0XHRcdHZhciBpbmRleDIgPSBlZGdlc1sgMiAqIGkgKyBqIF07XHJcblxyXG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzLmdldFgoIGluZGV4MiApO1xyXG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRpY2VzLmdldFkoIGluZGV4MiApO1xyXG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzLmdldFooIGluZGV4MiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblx0XHRcdHZhciBudW1FZGdlcyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XHJcblx0XHRcdHZhciBudW1UcmlzID0gbnVtRWRnZXMgLyAzO1xyXG5cclxuXHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bVRyaXM7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRleCA9IDE4ICogaSArIDYgKiBqO1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRleDEgPSA5ICogaSArIDMgKiBqO1xyXG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDEgXTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMSBdO1xyXG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAyIF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIGluZGV4MiA9IDkgKiBpICsgMyAqICggKCBqICsgMSApICUgMyApO1xyXG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDMgXSA9IHZlcnRpY2VzWyBpbmRleDIgXTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyA0IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMSBdO1xyXG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDUgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAyIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0F4aXNIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQXhpc0hlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSApIHtcclxuXHJcblx0c2l6ZSA9IHNpemUgfHwgMTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG5cdFx0MCwgMCwgMCwgIHNpemUsIDAsIDAsXHJcblx0XHQwLCAwLCAwLCAgMCwgc2l6ZSwgMCxcclxuXHRcdDAsIDAsIDAsICAwLCAwLCBzaXplXHJcblx0XSApO1xyXG5cclxuXHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG5cdFx0MSwgMCwgMCwgIDEsIDAuNiwgMCxcclxuXHRcdDAsIDEsIDAsICAwLjYsIDEsIDAsXHJcblx0XHQwLCAwLCAxLCAgMCwgMC42LCAxXHJcblx0XSApO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XHJcblxyXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BeGlzSGVscGVyO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXJyb3dIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqXHJcbiAqIENyZWF0ZXMgYW4gYXJyb3cgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnNcclxuICpcclxuICogUGFyYW1ldGVyczpcclxuICogIGRpciAtIFZlY3RvcjNcclxuICogIG9yaWdpbiAtIFZlY3RvcjNcclxuICogIGxlbmd0aCAtIE51bWJlclxyXG4gKiAgY29sb3IgLSBjb2xvciBpbiBoZXggdmFsdWVcclxuICogIGhlYWRMZW5ndGggLSBOdW1iZXJcclxuICogIGhlYWRXaWR0aCAtIE51bWJlclxyXG4gKi9cclxuXHJcblRIUkVFLkFycm93SGVscGVyID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRsaW5lR2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xyXG5cclxuXHR2YXIgY29uZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xyXG5cdGNvbmVHZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0gMC41LCAwICk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiBBcnJvd0hlbHBlciggZGlyLCBvcmlnaW4sIGxlbmd0aCwgY29sb3IsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcclxuXHJcblx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XHJcblx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gMTtcclxuXHRcdGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcclxuXHRcdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XHJcblx0XHRcclxuXHRcdGlmICggaGVhZExlbmd0aCA8IGxlbmd0aCApIHtcclxuXHRcdFx0dGhpcy5saW5lID0gbmV3IFRIUkVFLkxpbmUoIGxpbmVHZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcclxuXHRcdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5hZGQoIHRoaXMubGluZSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBjb25lR2VvbWV0cnksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcblx0XHR0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xyXG5cclxuXHRcdHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcclxuXHRcdHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xyXG5cclxuXHR9XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BcnJvd0hlbHBlcjtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciByYWRpYW5zO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKCBkaXIgKSB7XHJcblxyXG5cdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdGlmICggZGlyLnkgPiAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGRpci55IDwgLSAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMSwgMCwgMCwgMCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRheGlzLnNldCggZGlyLnosIDAsIC0gZGlyLnggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdHJhZGlhbnMgPSBNYXRoLmFjb3MoIGRpci55ICk7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn0oKSApO1xyXG5cclxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uICggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XHJcblxyXG5cdGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcclxuXHRpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcclxuXHJcblx0aWYgKCBoZWFkTGVuZ3RoIDwgbGVuZ3RoICl7XHJcblx0XHR0aGlzLmxpbmUuc2NhbGUuc2V0KCAxLCBsZW5ndGggLSBoZWFkTGVuZ3RoLCAxICk7XHJcblx0XHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xyXG5cdHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xyXG5cdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRpZiAoIHRoaXMubGluZSAhPT0gdW5kZWZpbmVkICkgdGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcclxuXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0JveEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQm94SGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICogMyApO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApICk7XHJcblxyXG5cdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoIG9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEhlbHBlcjtcclxuXHJcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Ym94LnNldEZyb21PYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggYm94LmVtcHR5KCkgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIG1pbiA9IGJveC5taW47XHJcblx0XHR2YXIgbWF4ID0gYm94Lm1heDtcclxuXHJcblx0XHQvKlxyXG5cdFx0ICA1X19fXzRcclxuXHRcdDEvX19fMC98XHJcblx0XHR8IDZfX3xfN1xyXG5cdFx0Mi9fX18zL1xyXG5cclxuXHRcdDA6IG1heC54LCBtYXgueSwgbWF4LnpcclxuXHRcdDE6IG1pbi54LCBtYXgueSwgbWF4LnpcclxuXHRcdDI6IG1pbi54LCBtaW4ueSwgbWF4LnpcclxuXHRcdDM6IG1heC54LCBtaW4ueSwgbWF4LnpcclxuXHRcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcclxuXHRcdDU6IG1pbi54LCBtYXgueSwgbWluLnpcclxuXHRcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcclxuXHRcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0dmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0YXJyYXlbICAwIF0gPSBtYXgueDsgYXJyYXlbICAxIF0gPSBtYXgueTsgYXJyYXlbICAyIF0gPSBtYXguejtcclxuXHRcdGFycmF5WyAgMyBdID0gbWluLng7IGFycmF5WyAgNCBdID0gbWF4Lnk7IGFycmF5WyAgNSBdID0gbWF4Lno7XHJcblx0XHRhcnJheVsgIDYgXSA9IG1pbi54OyBhcnJheVsgIDcgXSA9IG1pbi55OyBhcnJheVsgIDggXSA9IG1heC56O1xyXG5cdFx0YXJyYXlbICA5IF0gPSBtYXgueDsgYXJyYXlbIDEwIF0gPSBtaW4ueTsgYXJyYXlbIDExIF0gPSBtYXguejtcclxuXHRcdGFycmF5WyAxMiBdID0gbWF4Lng7IGFycmF5WyAxMyBdID0gbWF4Lnk7IGFycmF5WyAxNCBdID0gbWluLno7XHJcblx0XHRhcnJheVsgMTUgXSA9IG1pbi54OyBhcnJheVsgMTYgXSA9IG1heC55OyBhcnJheVsgMTcgXSA9IG1pbi56O1xyXG5cdFx0YXJyYXlbIDE4IF0gPSBtaW4ueDsgYXJyYXlbIDE5IF0gPSBtaW4ueTsgYXJyYXlbIDIwIF0gPSBtaW4uejtcclxuXHRcdGFycmF5WyAyMSBdID0gbWF4Lng7IGFycmF5WyAyMiBdID0gbWluLnk7IGFycmF5WyAyMyBdID0gbWluLno7XHJcblxyXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdH1cclxuXHJcbn0gKSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm91bmRpbmdCb3hIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG4vLyBhIGhlbHBlciB0byBzaG93IHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhbiBvYmplY3RcclxuXHJcblRIUkVFLkJvdW5kaW5nQm94SGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcclxuXHJcblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHg4ODg4ODg7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHR0aGlzLmJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgbmV3IFRIUkVFLkJveEdlb21ldHJ5KCAxLCAxLCAxICksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHdpcmVmcmFtZTogdHJ1ZSB9ICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3VuZGluZ0JveEhlbHBlcjtcclxuXHJcblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuYm94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XHJcblxyXG5cdHRoaXMuYm94LnNpemUoIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0dGhpcy5ib3guY2VudGVyKCB0aGlzLnBvc2l0aW9uICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxyXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXHJcbiAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxyXG4gKlx0XHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyB9ICk7XHJcblxyXG5cdHZhciBwb2ludE1hcCA9IHt9O1xyXG5cclxuXHQvLyBjb2xvcnNcclxuXHJcblx0dmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcclxuXHR2YXIgaGV4Q29uZSA9IDB4ZmYwMDAwO1xyXG5cdHZhciBoZXhVcCA9IDB4MDBhYWZmO1xyXG5cdHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcclxuXHR2YXIgaGV4Q3Jvc3MgPSAweDMzMzMzMztcclxuXHJcblx0Ly8gbmVhclxyXG5cclxuXHRhZGRMaW5lKCBcIm4xXCIsIFwibjJcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuNFwiLCBcIm4zXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4zXCIsIFwibjFcIiwgaGV4RnJ1c3R1bSApO1xyXG5cclxuXHQvLyBmYXJcclxuXHJcblx0YWRkTGluZSggXCJmMVwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcImYyXCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwiZjRcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJmM1wiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcclxuXHJcblx0Ly8gc2lkZXNcclxuXHJcblx0YWRkTGluZSggXCJuMVwiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4yXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuNFwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcclxuXHJcblx0Ly8gY29uZVxyXG5cclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuMVwiLCBoZXhDb25lICk7XHJcblx0YWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xyXG5cdGFkZExpbmUoIFwicFwiLCBcIm4zXCIsIGhleENvbmUgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuNFwiLCBoZXhDb25lICk7XHJcblxyXG5cdC8vIHVwXHJcblxyXG5cdGFkZExpbmUoIFwidTFcIiwgXCJ1MlwiLCBoZXhVcCApO1xyXG5cdGFkZExpbmUoIFwidTJcIiwgXCJ1M1wiLCBoZXhVcCApO1xyXG5cdGFkZExpbmUoIFwidTNcIiwgXCJ1MVwiLCBoZXhVcCApO1xyXG5cclxuXHQvLyB0YXJnZXRcclxuXHJcblx0YWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJjXCIsIGhleENyb3NzICk7XHJcblxyXG5cdC8vIGNyb3NzXHJcblxyXG5cdGFkZExpbmUoIFwiY24xXCIsIFwiY24yXCIsIGhleENyb3NzICk7XHJcblx0YWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcclxuXHJcblx0YWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgaGV4Q3Jvc3MgKTtcclxuXHRhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xyXG5cclxuXHRmdW5jdGlvbiBhZGRMaW5lKCBhLCBiLCBoZXggKSB7XHJcblxyXG5cdFx0YWRkUG9pbnQoIGEsIGhleCApO1xyXG5cdFx0YWRkUG9pbnQoIGIsIGhleCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgaGV4ICkge1xyXG5cclxuXHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XHJcblxyXG5cdFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cG9pbnRNYXBbIGlkIF0gPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC0gMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblx0dGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5wb2ludE1hcCA9IHBvaW50TWFwO1xyXG5cclxuXHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmFIZWxwZXI7XHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5LCBwb2ludE1hcDtcclxuXHJcblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHZlY3Rvci5zZXQoIHgsIHksIHogKS51bnByb2plY3QoIGNhbWVyYSApO1xyXG5cclxuXHRcdHZhciBwb2ludHMgPSBwb2ludE1hcFsgcG9pbnQgXTtcclxuXHJcblx0XHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIHBvaW50c1sgaSBdIF0uY29weSggdmVjdG9yICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0cG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xyXG5cclxuXHRcdHZhciB3ID0gMSwgaCA9IDE7XHJcblxyXG5cdFx0Ly8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeFxyXG5cdFx0Ly8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcclxuXHJcblx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0Ly8gY2VudGVyIC8gdGFyZ2V0XHJcblxyXG5cdFx0c2V0UG9pbnQoIFwiY1wiLCAwLCAwLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcInRcIiwgMCwgMCwgIDEgKTtcclxuXHJcblx0XHQvLyBuZWFyXHJcblxyXG5cdFx0c2V0UG9pbnQoIFwibjFcIiwgLSB3LCAtIGgsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwibjJcIiwgICB3LCAtIGgsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwibjNcIiwgLSB3LCAgIGgsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwibjRcIiwgICB3LCAgIGgsIC0gMSApO1xyXG5cclxuXHRcdC8vIGZhclxyXG5cclxuXHRcdHNldFBvaW50KCBcImYxXCIsIC0gdywgLSBoLCAxICk7XHJcblx0XHRzZXRQb2ludCggXCJmMlwiLCAgIHcsIC0gaCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiZjNcIiwgLSB3LCAgIGgsIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImY0XCIsICAgdywgICBoLCAxICk7XHJcblxyXG5cdFx0Ly8gdXBcclxuXHJcblx0XHRzZXRQb2ludCggXCJ1MVwiLCAgIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwidTJcIiwgLSB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcInUzXCIsICAgICAgICAgMCwgaCAqIDIsICAgLSAxICk7XHJcblxyXG5cdFx0Ly8gY3Jvc3NcclxuXHJcblx0XHRzZXRQb2ludCggXCJjZjFcIiwgLSB3LCAgIDAsIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImNmMlwiLCAgIHcsICAgMCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY2YzXCIsICAgMCwgLSBoLCAxICk7XHJcblx0XHRzZXRQb2ludCggXCJjZjRcIiwgICAwLCAgIGgsIDEgKTtcclxuXHJcblx0XHRzZXRQb2ludCggXCJjbjFcIiwgLSB3LCAgIDAsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY24yXCIsICAgdywgICAwLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImNuM1wiLCAgIDAsIC0gaCwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggXCJjbjRcIiwgICAwLCAgIGgsIC0gMSApO1xyXG5cclxuXHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9EaXJlY3Rpb25hbExpZ2h0SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNpemUgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0c2l6ZSA9IHNpemUgfHwgMTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoICAgc2l6ZSwgICBzaXplLCAwICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggICBzaXplLCAtIHNpemUsIDAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIC0gc2l6ZSwgMCApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgICBzaXplLCAwIClcclxuXHQpO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHRQbGFuZSApO1xyXG5cclxuXHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoKVxyXG5cdCk7XHJcblxyXG5cdG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy50YXJnZXRMaW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLnRhcmdldExpbmUgKTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2MyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHR2My5zdWJWZWN0b3JzKCB2MiwgdjEgKTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xyXG5cdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDEgXS5jb3B5KCB2MyApO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yICk7XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9FZGdlc0hlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAcGFyYW0gb2JqZWN0IFRIUkVFLk1lc2ggd2hvc2UgZ2VvbWV0cnkgd2lsbCBiZSB1c2VkXHJcbiAqIEBwYXJhbSBoZXggbGluZSBjb2xvclxyXG4gKiBAcGFyYW0gdGhyZXNob2xkQW5nbGUgdGhlIG1pbmltdW0gYW5nbGUgKGluIGRlZ3JlZXMpLFxyXG4gKiBiZXR3ZWVuIHRoZSBmYWNlIG5vcm1hbHMgb2YgYWRqYWNlbnQgZmFjZXMsXHJcbiAqIHRoYXQgaXMgcmVxdWlyZWQgdG8gcmVuZGVyIGFuIGVkZ2UuIEEgdmFsdWUgb2YgMTAgbWVhbnNcclxuICogYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSBpcyBhdCBsZWFzdCAxMCBkZWdyZWVzLlxyXG4gKi9cclxuXHJcblRIUkVFLkVkZ2VzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCwgdGhyZXNob2xkQW5nbGUgKSB7XHJcblxyXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgbmV3IFRIUkVFLkVkZ2VzR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRWRnZXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FZGdlc0hlbHBlcjtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0ZhY2VOb3JtYWxzSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcclxuXHJcblx0Ly8gRmFjZU5vcm1hbHNIZWxwZXIgb25seSBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeVxyXG5cclxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xyXG5cclxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcclxuXHJcblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIG5Ob3JtYWxzID0gMDtcclxuXHJcblx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjogb25seSBUSFJFRS5HZW9tZXRyeSBpcyBzdXBwb3J0ZWQuIFVzZSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLCBpbnN0ZWFkLicgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0dmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XHJcblxyXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XHJcblxyXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyO1xyXG5cclxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG5cdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xyXG5cclxuXHRcdHZhciBpZHggPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKVxyXG5cdFx0XHRcdC5hZGQoIHZlcnRpY2VzWyBmYWNlLmIgXSApXHJcblx0XHRcdFx0LmFkZCggdmVydGljZXNbIGZhY2UuYyBdIClcclxuXHRcdFx0XHQuZGl2aWRlU2NhbGFyKCAzIClcclxuXHRcdFx0XHQuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xyXG5cclxuXHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59KCkgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0dyaWRIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkdyaWRIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUsIHN0ZXAgKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XHJcblxyXG5cdHRoaXMuY29sb3IxID0gbmV3IFRIUkVFLkNvbG9yKCAweDQ0NDQ0NCApO1xyXG5cdHRoaXMuY29sb3IyID0gbmV3IFRIUkVFLkNvbG9yKCAweDg4ODg4OCApO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IC0gc2l6ZTsgaSA8PSBzaXplOyBpICs9IHN0ZXAgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgMCwgaSApLCBuZXcgVEhSRUUuVmVjdG9yMyggc2l6ZSwgMCwgaSApLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgLSBzaXplICksIG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCBzaXplIClcclxuXHRcdCk7XHJcblxyXG5cdFx0dmFyIGNvbG9yID0gaSA9PT0gMCA/IHRoaXMuY29sb3IxIDogdGhpcy5jb2xvcjI7XHJcblxyXG5cdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IsIGNvbG9yICk7XHJcblxyXG5cdH1cclxuXHJcblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkdyaWRIZWxwZXI7XHJcblxyXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiggY29sb3JDZW50ZXJMaW5lLCBjb2xvckdyaWQgKSB7XHJcblxyXG5cdHRoaXMuY29sb3IxLnNldCggY29sb3JDZW50ZXJMaW5lICk7XHJcblx0dGhpcy5jb2xvcjIuc2V0KCBjb2xvckdyaWQgKTtcclxuXHJcblx0dGhpcy5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9IZW1pc3BoZXJlTGlnaHRIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5jb2xvcnMgPSBbIG5ldyBUSFJFRS5Db2xvcigpLCBuZXcgVEhSRUUuQ29sb3IoKSBdO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcclxuXHRnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSA4OyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkuZmFjZXNbIGkgXS5jb2xvciA9IHRoaXMuY29sb3JzWyBpIDwgNCA/IDAgOiAxIF07XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycywgd2lyZWZyYW1lOiB0cnVlIH0gKTtcclxuXHJcblx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHR0aGlzLmFkZCggdGhpcy5saWdodFNwaGVyZSApO1xyXG5cclxuXHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlcjtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0dGhpcy5saWdodFNwaGVyZS5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29sb3JzWyAwIF0uY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cdFx0dGhpcy5jb2xvcnNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0dGhpcy5saWdodFNwaGVyZS5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xyXG5cdFx0dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvUG9pbnRMaWdodEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0VEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHQvKlxyXG5cdHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcclxuXHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcclxuXHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xyXG5cclxuXHR2YXIgZCA9IGxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuXHRpZiAoIGQgPT09IDAuMCApIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XHJcblx0Ki9cclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodEhlbHBlcjtcclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdC8qXHJcblx0dmFyIGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuXHRpZiAoIGQgPT09IDAuMCApIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcclxuXHJcblx0fVxyXG5cdCovXHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU2tlbGV0b25IZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFNlYW4gR3JpZmZpbiAvIGh0dHA6Ly90d2l0dGVyLmNvbS9zZ3JpZlxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuICovXHJcblxyXG5USFJFRS5Ta2VsZXRvbkhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHR0aGlzLmJvbmVzID0gdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0ICk7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcclxuXHJcblx0XHRpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xyXG5cdFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAwLCAxICkgKTtcclxuXHRcdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMSwgMCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlb21ldHJ5LmR5bmFtaWMgPSB0cnVlO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMsIGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XHJcblxyXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0dGhpcy5yb290ID0gb2JqZWN0O1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ta2VsZXRvbkhlbHBlcjtcclxuXHJcblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5nZXRCb25lTGlzdCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XHJcblxyXG5cdHZhciBib25lTGlzdCA9IFtdO1xyXG5cclxuXHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG5cdFx0Ym9uZUxpc3QucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBib25lTGlzdDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cclxuXHR2YXIgbWF0cml4V29ybGRJbnYgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHR2YXIgYm9uZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHZhciBqID0gMDtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XHJcblxyXG5cdFx0aWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG5cdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBqIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XHJcblxyXG5cdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaiArIDEgXS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcclxuXHJcblx0XHRcdGogKz0gMjtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU3BvdExpZ2h0SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0ICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAxLCAxLCA4LCAxLCB0cnVlICk7XHJcblxyXG5cdGdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcclxuXHRnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xyXG5cclxuXHR0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xyXG5cclxuXHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwb3RMaWdodEhlbHBlcjtcclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdmVjdG9yMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDAwO1xyXG5cdFx0dmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xyXG5cclxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XHJcblxyXG5cdFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0dmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dGhpcy5jb25lLmxvb2tBdCggdmVjdG9yMi5zdWIoIHZlY3RvciApICk7XHJcblxyXG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1ZlcnRleE5vcm1hbHNIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuKi9cclxuXHJcblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XHJcblxyXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xyXG5cclxuXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgbk5vcm1hbHMgPSAwO1xyXG5cclxuXHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0aWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcclxuXHJcblx0fSBlbHNlIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmNvdW50XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xyXG5cclxuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXI7XHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuXHRcdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XHJcblxyXG5cdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XHJcblxyXG5cdFx0XHR2YXIgaWR4ID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGZhY2VbIGtleXNbIGogXSBdIF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIG5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHR2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XHJcblxyXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xyXG5cclxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XHJcblxyXG5cdFx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqUG9zID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdHZhciBvYmpOb3JtID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XHJcblxyXG5cdFx0XHR2YXIgaWR4ID0gMDtcclxuXHJcblx0XHRcdC8vIGZvciBzaW1wbGljaXR5LCBpZ25vcmUgaW5kZXggYW5kIGRyYXdjYWxscywgYW5kIHJlbmRlciBldmVyeSBub3JtYWxcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBvYmpQb3MuY291bnQ7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0djEuc2V0KCBvYmpQb3MuZ2V0WCggaiApLCBvYmpQb3MuZ2V0WSggaiApLCBvYmpQb3MuZ2V0WiggaiApICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHR2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcclxuXHJcblx0XHRcdFx0djIuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xyXG5cclxuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xyXG5cclxuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0oKSApO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvV2lyZWZyYW1lSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xyXG5cclxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcclxuXHJcblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLldpcmVmcmFtZUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLldpcmVmcmFtZUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVIZWxwZXI7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9JbW1lZGlhdGVSZW5kZXJPYmplY3QuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCA9IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJDYWxsYmFjayApIHt9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdDtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL01vcnBoQmxlbmRNZXNoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMuYW5pbWF0aW9uc01hcCA9IHt9O1xyXG5cdHRoaXMuYW5pbWF0aW9uc0xpc3QgPSBbXTtcclxuXHJcblx0Ly8gcHJlcGFyZSBkZWZhdWx0IGFuaW1hdGlvblxyXG5cdC8vIChhbGwgZnJhbWVzIHBsYXllZCB0b2dldGhlciBpbiAxIHNlY29uZClcclxuXHJcblx0dmFyIG51bUZyYW1lcyA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDtcclxuXHJcblx0dmFyIG5hbWUgPSBcIl9fZGVmYXVsdFwiO1xyXG5cclxuXHR2YXIgc3RhcnRGcmFtZSA9IDA7XHJcblx0dmFyIGVuZEZyYW1lID0gbnVtRnJhbWVzIC0gMTtcclxuXHJcblx0dmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XHJcblxyXG5cdHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgZnBzICk7XHJcblx0dGhpcy5zZXRBbmltYXRpb25XZWlnaHQoIG5hbWUsIDEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Nb3JwaEJsZW5kTWVzaDtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jcmVhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIHN0YXJ0LCBlbmQsIGZwcyApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHtcclxuXHJcblx0XHRzdGFydDogc3RhcnQsXHJcblx0XHRlbmQ6IGVuZCxcclxuXHJcblx0XHRsZW5ndGg6IGVuZCAtIHN0YXJ0ICsgMSxcclxuXHJcblx0XHRmcHM6IGZwcyxcclxuXHRcdGR1cmF0aW9uOiAoIGVuZCAtIHN0YXJ0ICkgLyBmcHMsXHJcblxyXG5cdFx0bGFzdEZyYW1lOiAwLFxyXG5cdFx0Y3VycmVudEZyYW1lOiAwLFxyXG5cclxuXHRcdGFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0dGltZTogMCxcclxuXHRcdGRpcmVjdGlvbjogMSxcclxuXHRcdHdlaWdodDogMSxcclxuXHJcblx0XHRkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxyXG5cdFx0bWlycm9yZWRMb29wOiBmYWxzZVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXSA9IGFuaW1hdGlvbjtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goIGFuaW1hdGlvbiApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5hdXRvQ3JlYXRlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICggZnBzICkge1xyXG5cclxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcclxuXHJcblx0dmFyIGZpcnN0QW5pbWF0aW9uLCBmcmFtZVJhbmdlcyA9IHt9O1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBtb3JwaCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdO1xyXG5cdFx0dmFyIGNodW5rcyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcclxuXHJcblx0XHRpZiAoIGNodW5rcyAmJiBjaHVua3MubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdHZhciBuYW1lID0gY2h1bmtzWyAxIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XHJcblxyXG5cdFx0XHR2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0aWYgKCBpIDwgcmFuZ2Uuc3RhcnQgKSByYW5nZS5zdGFydCA9IGk7XHJcblx0XHRcdGlmICggaSA+IHJhbmdlLmVuZCApIHJhbmdlLmVuZCA9IGk7XHJcblxyXG5cdFx0XHRpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IG5hbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHZhciBuYW1lIGluIGZyYW1lUmFuZ2VzICkge1xyXG5cclxuXHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcblx0XHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgZnBzICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAtIDE7XHJcblx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25GUFMgPSBmdW5jdGlvbiAoIG5hbWUsIGZwcyApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24uZnBzID0gZnBzO1xyXG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZnBzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBkdXJhdGlvbiApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuXHRcdGFuaW1hdGlvbi5mcHMgPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25XZWlnaHQgPSBmdW5jdGlvbiAoIG5hbWUsIHdlaWdodCApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24ud2VpZ2h0ID0gd2VpZ2h0O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLnRpbWUgPSB0aW1lO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciB0aW1lID0gMDtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHR0aW1lID0gYW5pbWF0aW9uLnRpbWU7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRpbWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgZHVyYXRpb24gPSAtIDE7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0ZHVyYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGR1cmF0aW9uO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi50aW1lID0gMDtcclxuXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSB0cnVlO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5Nb3JwaEJsZW5kTWVzaDogYW5pbWF0aW9uW1wiICsgbmFtZSArIFwiXSB1bmRlZmluZWQgaW4gLnBsYXlBbmltYXRpb24oKVwiICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24uYWN0aXZlID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBkZWx0YSApIHtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYW5pbWF0aW9uc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc0xpc3RbIGkgXTtcclxuXHJcblx0XHRpZiAoICEgYW5pbWF0aW9uLmFjdGl2ZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdHZhciBmcmFtZVRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gLyBhbmltYXRpb24ubGVuZ3RoO1xyXG5cclxuXHRcdGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kaXJlY3Rpb24gKiBkZWx0YTtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5taXJyb3JlZExvb3AgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcblx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiAqPSAtIDE7XHJcblxyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb247XHJcblx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IDA7XHJcblx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24udGltZSAlIGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcblx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIga2V5ZnJhbWUgPSBhbmltYXRpb24uc3RhcnQgKyBUSFJFRS5NYXRoLmNsYW1wKCBNYXRoLmZsb29yKCBhbmltYXRpb24udGltZSAvIGZyYW1lVGltZSApLCAwLCBhbmltYXRpb24ubGVuZ3RoIC0gMSApO1xyXG5cdFx0dmFyIHdlaWdodCA9IGFuaW1hdGlvbi53ZWlnaHQ7XHJcblxyXG5cdFx0aWYgKCBrZXlmcmFtZSAhPT0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAwO1xyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gMSAqIHdlaWdodDtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBrZXlmcmFtZSBdID0gMDtcclxuXHJcblx0XHRcdGFuaW1hdGlvbi5sYXN0RnJhbWUgPSBhbmltYXRpb24uY3VycmVudEZyYW1lO1xyXG5cdFx0XHRhbmltYXRpb24uY3VycmVudEZyYW1lID0ga2V5ZnJhbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtaXggPSAoIGFuaW1hdGlvbi50aW1lICUgZnJhbWVUaW1lICkgLyBmcmFtZVRpbWU7XHJcblxyXG5cdFx0aWYgKCBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzICkgbWl4ID0gMSAtIG1peDtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgIT09IGFuaW1hdGlvbi5sYXN0RnJhbWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gbWl4ICogd2VpZ2h0O1xyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gKCAxIC0gbWl4ICkgKiB3ZWlnaHQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSB3ZWlnaHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIEV4cG9ydCB0aGUgVEhSRUUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxyXG4vLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXHJcbi8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcclxuLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGUuXHJcbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFRIUkVFO1xyXG4gIH1cclxuICBleHBvcnRzLlRIUkVFID0gVEhSRUU7XHJcbn0gZWxzZSB7XHJcbiAgdGhpc1snVEhSRUUnXSA9IFRIUkVFO1xyXG59XHJcbiJdfQ==
